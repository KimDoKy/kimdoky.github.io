---
layout: post
section-type: post
title: HTTP-part1.HTTP 웹의 기초 - chap3. HTTP 메시지
category: http
tags: [ 'http' ]
---

Chap3에서 다루는 내용

- 메시지가 어떻게 흘러가는가
- HTTP 메시지의 세 부분(시작줄, 헤더, 개체 본문)
- 요청과 응답 메시지의 차이
- 요청 메시지가 지원하는 여러 기능(메서드)들
- 응답 메시지가 반환하는 여러 상태 코드들
- 여러 HTTP 헤더들은 무슨 일을 하는가

## 3.1 메시지의 흐흠
HTTP 메시지 : HTTP 애플리케이션 간에 주고받은 데이터 블록들. 클라이언트, 서버, 프락시 사이를 흐른다.  
메타 정보 : 메시지의 내용과 의미를 설명하는 텍스트 정보. HTTP 메시지는 메타 정보로 시작한다.  

### 3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다
- 인바운드 : 메시지가 원 서버로 향하는 것  
- 아웃바운드 : 모든 처리가 끝난 뒤 메시지가 에이전트로 돌아오는 것  

![]({{ site.url }}/img/post/http/3.1.png)

### 3.1.2 다운스트림으로 흐르는 메시지
모든 메시지는 다운스트림으로 흐른다. 업스트림은 다운스트림의 전 단계(데이터의 제공자. 전 처리자 정도)이다.

![]({{ site.url }}/img/post/http/3.2.png)

## 3.2 메시지의 각 부분

- 시작줄 : 어떤 메시지인지 서술한다.
- 헤더 블록 : 메시지의 속성을 서술한다.
- 본문 : 데이터. 없을 수도 있다.

![]({{ site.url }}/img/post/http/3.3.png)

시작줄과 헤더는 단순히 줄 단위로 분리된 아스키 문자열이다.(줄바꿈 문자열을 'CRLF'라고 한다.) 오래되거나 잘못 만들어진 HTTP 애플리케이션들 중이선 개리지 리턴, 개행 문자 모두 전송하지 않는 경우도 있다.  
엔터티 본문이나 메시지 본문은 단순한 데이터 덩어리이다.

### 3.2.1 메시지 문법
모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류된다.

![]({{ site.url }}/img/post/http/3.4.png)

- 요청 메시지 형식

```
<메서드> <요청 URL> <버전>
<헤더>

<엔터티 본문>
```

- 응답 메시지 형식(시작줄만 뭄법이 다르다.)

```
<버전> <상태 코드> <사유 구절>
<헤더>

<엔터티 본문>
```

#### 메서드
클라이언트 측에서 서버에 바라는 동작. 'GET', 'HEAD', 'POST'와 같은 것들이다.

#### 요청 URL
요청 대상이 되는 리소스를 지징하는 완전한 URL 혹은 URL의 구성요소이다.

#### 버전
메시지에서 사용 중인 HTTP의 버전이다.  
`HTTP/<메이저>.<마이너>`  
메이저와 마이너는 모두 정수이다.

#### 상태 코드
요청 과정의 오류나 결과를 알려주는 코드이다.

#### 사유 구절(reason-phrase)
상태 코드를 사람이 이해하기 쉽게 설명해주는 짧은 문구. 오로지 사람이 읽는 것만이 목적이다.

#### 헤더들
이름, 콜론, 선택적인 공백, 값, CRLF가 순서대로 나타나는 0개 이상의 헤더들.  
헤더 목록은 빈 줄(CRLF)로 끝나 헤더 목록의 끝과 엔터티 본문의 시작을 표시한다.

#### 엔터티 본문
엔터티 본문은 임의의 데이터 블록을 포함한다. 엔터티 본문이 없을 수도 있기 때문에, 그냥 CRLF으로 끝나게 된다.

![]({{ site.url }}/img/post/http/3.5.png)

헤더나 엔터티 본문이 업어도 HTTP 헤더의 집합은 CRLF로 끝나야하지만, 실제로는 CSLF를 빠뜨리는 클라이언트와 서버가 많기 때문에, 마지막에 CRLF 없이 끝나도 메시지를 받아들일 수 있어야 한다.

### 3.2.2 시작줄

#### 요청줄
요청줄에는 서버에서 어떤 동작이 일어나야 하는지 설명해주는 메서드와 그 동작에 대한 대상을 지징하는 요청 URL과 HTTP 버전 정보가 들어있다. 이 모든 필드는 공백으로 구분된다.
#### 응답줄
응답 메시지는 수행 결과에 대한 상태 정보과 결과 데이터를 클라이언트에게 돌려준다. 응답 메시지의 응답줄에는 응답 메시지에서 쓰인 HTTP 버전, 숫자로 된 상태코드, 텍스트로 된 사유구절이 들어 있다. 이 모든 필드는 공백으로 구분된다.

#### 메서드

메서드 | 설명 | 메시지 여부
---|---|---
GET | 서버에서 어떤 문서를 가져온다 | 없음
HEAD | 서버에서 어떤 문서에 대해 헤더만 가져온다. | 없음
POST | 서버가 처리해야 할 데이터를 보낸다. | 있음
PUT | 서버에 요청 메시지의 본문을 저장한다. | 있음
TRACE | 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다. | 없음
OPTIONS | 서버가 어떤 메서드를 수행할 수 있는지 확인한다. | 없음
DELETE | 서버에서 문서를 제거한다. | 없음

HTTP는 쉽게 확장할 수 있도록 설계되었기 때문에, 각 서버들만의 메서드를 추가로 구현했을 수도 있다.(확장 메서드)

#### 상태 코드

전체 범위 | 정의된 범위 | 분류
---|---|---
100-199 | 100-101 | 정보
200-299 | 200-206 | 성공
300-399 | 300-305 | 리다이렉션
400-499 | 400_415 | 클라이언트 에러
500-599 | 500-505 | 서버 에러

#### 사유 구절
애플리케이션 개발자들이 사용자에게 요청 중에 무슨 일이 일어났는지 알려주기 위해 넘겨주는, 상태 코드의 사람 이해용이다.

#### 버전 번호
버전 번호는 HTTP/x.y 형식으로 요청과 응답 메시지 양쪽 모두 기술된다. HTTP 애플리케이션이 자신이 따르는 프로토콜의 버전을 상대방에게 알려주기 위한 수단이다.

### 3.2.3 헤더
HTTP 헤더 필드는 요청과 응답 메시지에 추가 정보를 더한다. 기본적으로 이름/값 쌍의 목록이다.

#### 헤더 분류
HTTP 헤더 명세는 여러 헤더 필드를 정의한다. 애플리케이션은 자유롭게 자신만의 헤더를 만들 수도 있다.
##### 일반 헤더
요청과 응답 양족에 모두 나타날 수 있음
##### 요청 헤더
요청에 대한 부가 정보를 제공
##### 응답 헤더
응답에 대한 부가 정보를 제공
##### Entity 헤더
본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술
##### 확장 헤더
명세에 정의되지 않은 새로운 헤더

헤더의 예 | 설명
---|---
Date:Tue,3 Oct 1997 02...GMT | 서버가 응답을 만들어 낸 시각
Content-length: 15040 | 15,040 바이트의 데이터를 포함한 엔터티 본문
Content_type:image/gif | 엔터티 본문은 GIF 이미지이다.
Accept: image/gif, image/jpeg, text/html | 클라이언트는 GIF, JPEG, HTML을 받아들일 수 있다.

#### 헤더를 여러 줄로 나누기
긴 헤더 줄을 여러 줄로 쪼개서 읽기 좋게 만들 수 있다. 추가 줄 앞에는 최소 하나의 스페이스 혹은 탭 문자가 와야 한다.

```
 HTTP/1.0 200 OK
 Content-Type: image/gif
 Content-Length: 8572
 Server: Test Server
     Version 1.0
```

### 3.2.4 엔터티 본문
엔터티 본문은 HTTP 메시지의 화물이라 생각하면 된다. 이미지, 비디오, html문서, 소프트웨어 애플리케이션, 신용카드 트랜잭션, 전자우편 등 여러 종류의 디지털 데이터를 담을 수 있다.

### 3.2.5 버전 0.9 메시지
0.9는 초기 버전이다. 요청과 응답으로 이루어져 있지만, 요청은 메서드와 요청 URL, 응답은 엔티티로만 구성되어 있다.  
지나친 단순함 때문에 HTTP의 기능들 대부분을 구현할 수 없지만, 여전히 0.9를 사용하는 클라이언트, 서버, 기타 애플리케이션들이 존재한다.

## 3.3 메서드
모든 서버가 모든 메서드를 구현하지는 않는다. 사이트마다 서버마다 다를 수 있다.

### 3.3.1 안전한 메서드(Safe Method)
`GET`, `HEAD`. HTTP 요청 결과로 서버에 어떤 작용도 없음을 의미한다.

### 3.3.2 GET
주로 서버에게 리소스를 달라고 요청하기 위해 사용한다.

![]({{ site.url }}/img/post/http/3.6.png)

### 3.3.3 HEAD
서버는 응답으로 헤더만을 돌려준다. 엔터티 본문은 반환하지 않는다.

- 리소스를 가져오지 않고도 그에 대해 무엇인가(타입 등)을 알아낼 수 있다.
- 응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있다.
- 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다.

서버 개발자달은 반드시 반환되는 헤더가 GET으로 얻는 것과 정확히 일치함을 보장해야 한다.
![]({{ site.url }}/img/post/http/3.7.png)

### 3.3.4 PUT
PUT 메서드는 서버에 문서를 저장한다. PUT 메서드의 의미는, 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 존재한다면 본문을 교체하는 것이다.  
PUT은 콘텐츠를 변경할 수 있기 때문에, PUT을 수행하려면 비밀번호를 입력해서 로그인할 것을 요구해야 한다.

![]({{ site.url }}/img/post/http/3.8.png)

### 3.3.5 POST
서버에 입력 데이터를 전송하기 위해 설계되었다.(POST는 서버에 데이터를 보내기 위해 사용, PUT은 서버에 있는 리소스에 데이터를 입력하기 위해 사용)  
실제로 HTML 폼을 지원하기 위해 흔히 사용된다. 채워진 폼에 담긴 데이터는 서버로 전송되며, 서버는 이를 모아서 필요로 하는 곳으로 보낸다.(데이터를 처리할 서버 게이트웨이 프로그램 등)
![]({{ site.url }}/img/post/http/3.9.png)

### 3.3.6 TRACE
클라이언트가 어떤 요청을 할때, 방화벽, 프락시, 게이트웨이 등의 애플리케이션을 통과하는데, TRACE 메서드는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다.
![]({{ site.url }}/img/post/http/3.10.png)

TRACE 요청은 목적지 서버에서 '루프백(loopback)' 진단을 시작한다. 요청 전송의 마지막 단계에 있는 서버는 자신이 받은 요청 메시지를 본문에 넣어 TRACE 응답을 되돌려 준다. 클라이언트는 자신과 목적지 서버 사이에 있는 모든 HTTP 애플리케이션의 요청/응답 연쇄를 따라가면서 메시지가 망가졌거나 수정되었는지, 만약 그렇다면 어떻게 변경되었는지 확인할 수 있다.  

TRACE 메서드는 주로 진단용으로 사용된다. 요청이 의도한 요청/응답 연쇄를 거쳤는지, 프락시나 다른 애플리케이션들이 요청에 어떤 여향을 미쳤는지 확인할 수 있다.

### 3.3.7 OPTIONS
웹 서버에게 여러 종류의 지원 범위에 대해 물어본다.

![]({{ site.url }}/img/post/http/3.11.png)

### 3.3.8 DELETE
서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다. 그러나 클라이언트는 삭제가 수행되는 것을 보장하지 못한다. HTTP 명세는 서버가 클라이언트에게 알리지 않고 요청을 무시하는 것을 허용하기 때문이다.

![]({{ site.url }}/img/post/http/3.12.png)

### 3.3.9 확장 메서드
HTTP는 필요에 따라 확장해도 문제가 없도록 설계되어 있으므로, 새로 기능을 추가해도 과거에 구현된 소프트웨어들의 오동작을 유발하지 않는다.  

모든 확장 메서드는 형식을 갖춘 명세로 정의되어 있지 않기 때문에, 대부분의 HTTP 애플리케이션이 이행할 수 없다. 확장 메서드(그리고 대부분의 HTTP 확장)을 다룰 떄는 "엄격하게 보내고 관대하게 받아들여라"라는 오랜 규칙을 따르는 것이 좋다.
