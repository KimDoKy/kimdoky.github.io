---
layout: post
section-type: post
title: HTTP-part1.HTTP 웹의 기초 - chap3. HTTP 메시지
category: http
tags: [ 'http' ]
---

Chap3에서 다루는 내용

- 메시지가 어떻게 흘러가는가
- HTTP 메시지의 세 부분(시작줄, 헤더, 개체 본문)
- 요청과 응답 메시지의 차이
- 요청 메시지가 지원하는 여러 기능(메서드)들
- 응답 메시지가 반환하는 여러 상태 코드들
- 여러 HTTP 헤더들은 무슨 일을 하는가

## 3.1 메시지의 흐흠
HTTP 메시지 : HTTP 애플리케이션 간에 주고받은 데이터 블록들. 클라이언트, 서버, 프락시 사이를 흐른다.  
메타 정보 : 메시지의 내용과 의미를 설명하는 텍스트 정보. HTTP 메시지는 메타 정보로 시작한다.  

### 3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다
- 인바운드 : 메시지가 원 서버로 향하는 것  
- 아웃바운드 : 모든 처리가 끝난 뒤 메시지가 에이전트로 돌아오는 것  

![]({{ site.url }}/img/post/http/3.1.png)

### 3.1.2 다운스트림으로 흐르는 메시지
모든 메시지는 다운스트림으로 흐른다. 업스트림은 다운스트림의 전 단계(데이터의 제공자. 전 처리자 정도)이다.

![]({{ site.url }}/img/post/http/3.2.png)

## 3.2 메시지의 각 부분

- 시작줄 : 어떤 메시지인지 서술한다.
- 헤더 블록 : 메시지의 속성을 서술한다.
- 본문 : 데이터. 없을 수도 있다.

![]({{ site.url }}/img/post/http/3.3.png)

시작줄과 헤더는 단순히 줄 단위로 분리된 아스키 문자열이다.(줄바꿈 문자열을 'CRLF'라고 한다.) 오래되거나 잘못 만들어진 HTTP 애플리케이션들 중이선 개리지 리턴, 개행 문자 모두 전송하지 않는 경우도 있다.  
엔터티 본문이나 메시지 본문은 단순한 데이터 덩어리이다.

### 3.2.1 메시지 문법
모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류된다.

![]({{ site.url }}/img/post/http/3.4.png)

- 요청 메시지 형식

```
<메서드> <요청 URL> <버전>
<헤더>

<엔터티 본문>
```

- 응답 메시지 형식(시작줄만 뭄법이 다르다.)

```
<버전> <상태 코드> <사유 구절>
<헤더>

<엔터티 본문>
```

#### 메서드
클라이언트 측에서 서버에 바라는 동작. 'GET', 'HEAD', 'POST'와 같은 것들이다.

#### 요청 URL
요청 대상이 되는 리소스를 지징하는 완전한 URL 혹은 URL의 구성요소이다.

#### 버전
메시지에서 사용 중인 HTTP의 버전이다.  
`HTTP/<메이저>.<마이너>`  
메이저와 마이너는 모두 정수이다.

#### 상태 코드
요청 과정의 오류나 결과를 알려주는 코드이다.

#### 사유 구절(reason-phrase)
상태 코드를 사람이 이해하기 쉽게 설명해주는 짧은 문구. 오로지 사람이 읽는 것만이 목적이다.

#### 헤더들
이름, 콜론, 선택적인 공백, 값, CRLF가 순서대로 나타나는 0개 이상의 헤더들.  
헤더 목록은 빈 줄(CRLF)로 끝나 헤더 목록의 끝과 엔터티 본문의 시작을 표시한다.

#### 엔터티 본문
엔터티 본문은 임의의 데이터 블록을 포함한다. 엔터티 본문이 없을 수도 있기 때문에, 그냥 CRLF으로 끝나게 된다.

![]({{ site.url }}/img/post/http/3.5.png)

헤더나 엔터티 본문이 업어도 HTTP 헤더의 집합은 CRLF로 끝나야하지만, 실제로는 CSLF를 빠뜨리는 클라이언트와 서버가 많기 때문에, 마지막에 CRLF 없이 끝나도 메시지를 받아들일 수 있어야 한다.

### 3.2.2 시작줄

#### 요청줄
요청줄에는 서버에서 어떤 동작이 일어나야 하는지 설명해주는 메서드와 그 동작에 대한 대상을 지징하는 요청 URL과 HTTP 버전 정보가 들어있다. 이 모든 필드는 공백으로 구분된다.
#### 응답줄
응답 메시지는 수행 결과에 대한 상태 정보과 결과 데이터를 클라이언트에게 돌려준다. 응답 메시지의 응답줄에는 응답 메시지에서 쓰인 HTTP 버전, 숫자로 된 상태코드, 텍스트로 된 사유구절이 들어 있다. 이 모든 필드는 공백으로 구분된다.

#### 메서드

메서드 | 설명 | 메시지 여부
---|---|---
GET | 서버에서 어떤 문서를 가져온다 | 없음
HEAD | 서버에서 어떤 문서에 대해 헤더만 가져온다. | 없음
POST | 서버가 처리해야 할 데이터를 보낸다. | 있음
PUT | 서버에 요청 메시지의 본문을 저장한다. | 있음
TRACE | 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다. | 없음
OPTIONS | 서버가 어떤 메서드를 수행할 수 있는지 확인한다. | 없음
DELETE | 서버에서 문서를 제거한다. | 없음

HTTP는 쉽게 확장할 수 있도록 설계되었기 때문에, 각 서버들만의 메서드를 추가로 구현했을 수도 있다.(확장 메서드)

#### 상태 코드

전체 범위 | 정의된 범위 | 분류
---|---|---
100-199 | 100-101 | 정보
200-299 | 200-206 | 성공
300-399 | 300-305 | 리다이렉션
400-499 | 400_415 | 클라이언트 에러
500-599 | 500-505 | 서버 에러

#### 사유 구절
애플리케이션 개발자들이 사용자에게 요청 중에 무슨 일이 일어났는지 알려주기 위해 넘겨주는, 상태 코드의 사람 이해용이다.

#### 버전 번호
버전 번호는 HTTP/x.y 형식으로 요청과 응답 메시지 양쪽 모두 기술된다. HTTP 애플리케이션이 자신이 따르는 프로토콜의 버전을 상대방에게 알려주기 위한 수단이다.

### 3.2.3 헤더
HTTP 헤더 필드는 요청과 응답 메시지에 추가 정보를 더한다. 기본적으로 이름/값 쌍의 목록이다.

#### 헤더 분류
HTTP 헤더 명세는 여러 헤더 필드를 정의한다. 애플리케이션은 자유롭게 자신만의 헤더를 만들 수도 있다.
##### 일반 헤더
요청과 응답 양족에 모두 나타날 수 있음
##### 요청 헤더
요청에 대한 부가 정보를 제공
##### 응답 헤더
응답에 대한 부가 정보를 제공
##### Entity 헤더
본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술
##### 확장 헤더
명세에 정의되지 않은 새로운 헤더

헤더의 예 | 설명
---|---
Date:Tue,3 Oct 1997 02...GMT | 서버가 응답을 만들어 낸 시각
Content-length: 15040 | 15,040 바이트의 데이터를 포함한 엔터티 본문
Content_type:image/gif | 엔터티 본문은 GIF 이미지이다.
Accept: image/gif, image/jpeg, text/html | 클라이언트는 GIF, JPEG, HTML을 받아들일 수 있다.

#### 헤더를 여러 줄로 나누기
긴 헤더 줄을 여러 줄로 쪼개서 읽기 좋게 만들 수 있다. 추가 줄 앞에는 최소 하나의 스페이스 혹은 탭 문자가 와야 한다.

```
 HTTP/1.0 200 OK
 Content-Type: image/gif
 Content-Length: 8572
 Server: Test Server
     Version 1.0
```

### 3.2.4 엔터티 본문
엔터티 본문은 HTTP 메시지의 화물이라 생각하면 된다. 이미지, 비디오, html문서, 소프트웨어 애플리케이션, 신용카드 트랜잭션, 전자우편 등 여러 종류의 디지털 데이터를 담을 수 있다.

### 3.2.5 버전 0.9 메시지
0.9는 초기 버전이다. 요청과 응답으로 이루어져 있지만, 요청은 메서드와 요청 URL, 응답은 엔티티로만 구성되어 있다.  
지나친 단순함 때문에 HTTP의 기능들 대부분을 구현할 수 없지만, 여전히 0.9를 사용하는 클라이언트, 서버, 기타 애플리케이션들이 존재한다.

## 3.3 메서드
모든 서버가 모든 메서드를 구현하지는 않는다. 사이트마다 서버마다 다를 수 있다.

### 3.3.1 안전한 메서드(Safe Method)
`GET`, `HEAD`. HTTP 요청 결과로 서버에 어떤 작용도 없음을 의미한다.

### 3.3.2 GET
주로 서버에게 리소스를 달라고 요청하기 위해 사용한다.

![]({{ site.url }}/img/post/http/3.6.png)

### 3.3.3 HEAD
서버는 응답으로 헤더만을 돌려준다. 엔터티 본문은 반환하지 않는다.

- 리소스를 가져오지 않고도 그에 대해 무엇인가(타입 등)을 알아낼 수 있다.
- 응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있다.
- 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다.

서버 개발자달은 반드시 반환되는 헤더가 GET으로 얻는 것과 정확히 일치함을 보장해야 한다.
![]({{ site.url }}/img/post/http/3.7.png)

### 3.3.4 PUT
PUT 메서드는 서버에 문서를 저장한다. PUT 메서드의 의미는, 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 존재한다면 본문을 교체하는 것이다.  
PUT은 콘텐츠를 변경할 수 있기 때문에, PUT을 수행하려면 비밀번호를 입력해서 로그인할 것을 요구해야 한다.

![]({{ site.url }}/img/post/http/3.8.png)

### 3.3.5 POST
서버에 입력 데이터를 전송하기 위해 설계되었다.(POST는 서버에 데이터를 보내기 위해 사용, PUT은 서버에 있는 리소스에 데이터를 입력하기 위해 사용)  
실제로 HTML 폼을 지원하기 위해 흔히 사용된다. 채워진 폼에 담긴 데이터는 서버로 전송되며, 서버는 이를 모아서 필요로 하는 곳으로 보낸다.(데이터를 처리할 서버 게이트웨이 프로그램 등)
![]({{ site.url }}/img/post/http/3.9.png)

### 3.3.6 TRACE
클라이언트가 어떤 요청을 할때, 방화벽, 프락시, 게이트웨이 등의 애플리케이션을 통과하는데, TRACE 메서드는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다.
![]({{ site.url }}/img/post/http/3.10.png)

TRACE 요청은 목적지 서버에서 '루프백(loopback)' 진단을 시작한다. 요청 전송의 마지막 단계에 있는 서버는 자신이 받은 요청 메시지를 본문에 넣어 TRACE 응답을 되돌려 준다. 클라이언트는 자신과 목적지 서버 사이에 있는 모든 HTTP 애플리케이션의 요청/응답 연쇄를 따라가면서 메시지가 망가졌거나 수정되었는지, 만약 그렇다면 어떻게 변경되었는지 확인할 수 있다.  

TRACE 메서드는 주로 진단용으로 사용된다. 요청이 의도한 요청/응답 연쇄를 거쳤는지, 프락시나 다른 애플리케이션들이 요청에 어떤 여향을 미쳤는지 확인할 수 있다.

### 3.3.7 OPTIONS
웹 서버에게 여러 종류의 지원 범위에 대해 물어본다.

![]({{ site.url }}/img/post/http/3.11.png)

### 3.3.8 DELETE
서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다. 그러나 클라이언트는 삭제가 수행되는 것을 보장하지 못한다. HTTP 명세는 서버가 클라이언트에게 알리지 않고 요청을 무시하는 것을 허용하기 때문이다.

![]({{ site.url }}/img/post/http/3.12.png)

### 3.3.9 확장 메서드
HTTP는 필요에 따라 확장해도 문제가 없도록 설계되어 있으므로, 새로 기능을 추가해도 과거에 구현된 소프트웨어들의 오동작을 유발하지 않는다.  

모든 확장 메서드는 형식을 갖춘 명세로 정의되어 있지 않기 때문에, 대부분의 HTTP 애플리케이션이 이행할 수 없다. 확장 메서드(그리고 대부분의 HTTP 확장)을 다룰 떄는 "엄격하게 보내고 관대하게 받아들여라"라는 오랜 규칙을 따르는 것이 좋다.

## 3.4 상태 코드
### 3.4.1 100-199: 정보성 상태 코드
정보성 상태 코드는 HTTP/1.1에서 도입되었다. 비교적 최신의 것이며, 복잡함을 감수할 만한 가치가 있는지에 대한 논란이 있다.

상태 코드 | 사유 구절 | 의미
---|---|---
100 | Continue | 요청의 시작 부분 일부가 받아들여졌으며, 클라이언트는 나머지를 계속 이어서 보내야 함을 의미. 이것을 보낸 후, 서버는 반드시 요청을 받아 응답해야 한다.
101 | Switching Protocols | 클라이언트가 Upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꾸었음을 의미한다.

100 Continue는 HTTP 클라이언트 애플리케이션이 서버에 엔터티 본문을 전송하기 전에 그 엔터티 본문을 서버가 받아들일 것인지 확인하려고 할때, 그 확인 작업을 회적화하기 위한 의도로 도입된 것이다.

#### 클라이언트과 100 Continue
100-Continue는 서버가 다루거나 사용할 수 없는 큰 엔터티를 서버에게 보내지 않으려는 목적으로만 사용해야 한다.  
그리고 클라이언트는 막연히 서버가 100 Continue 응답을 보내주기만을 기다리지 말고, 약간의 타임아웃 후에 그냥 엔터티를 보내야 한다.  
클라이언트 개발자는 예상치 못한  100 Continue 응답에도 대비해야 한다.

#### 서버와 100 Continue
서버가 100 Continue 값이 담긴 Expect 헤더가 포함된 요청을 받는다면, 100 Continue 응답 혹은 에러 코드로 답해야 한다. 서버는 절대로 100-Continue 응답을 받을 것을 의도하지 않은 클라이언트에게 100-Continue 상태 코드를 보내서는 안된다.  

#### 프락시와 100 Continue
클라이언트로부터 100-continue 응답을 의도한 요청을 받은 프락시는 몇 가지 해야 할 일이 있다.  
만약 다음 홉(next hop) 서버가 HTTP/1.1에 따르거나 어떤 버번을 따르는지 모른다면, Expect 헤더를 포함시켜서 요청을 다음으로 전달해야 한다. 만약 다음 홉의 서버가 1.1 보다 이전 버전의 HTTP를 따른다는 것을 알고 있다면, 프락시는 427 Expextation Failed 에러로 응답해야 한다.  
프락시가 다음 홉 서버들에 대한 상태 몇가지와 그들이 지원하는 HTTP 버전을 기억해둔다면, 100-continue 응답을 기대한 요청을 더 잘 다룰 수 있게 되므로 프락시에게 득이 된다.

### 3.4.2 200-299: 성공 상태 코드

상태 코드 | 사유 구절 | 의미
---|---|---
200 | OK | 요청은 정상이고, 엔터티 본문은 요청된 리소스를 포함하고 있다.
201 | Created | 서버 개체를 생성하라는 요청(PUT)을 위한 것. 응답은, 생성된 리소스에 대한 최대한 구체적인 참조가 담긴 Location 헤더와 함께, 그 리소스를 참조할 수 있는 여러 URL을 엔터티 본문에 포함해야 한다. 서버는 상태 코드를 보내기에 앞서 반드시 객체를 생성해야 한다.
202 | Accepted | 요청은 받아들여졌으나 서버는 아직 그에 대한 어떤 동작도 수행하지 않았다. 서버가 요청의 처리를 완료할 것인지에 대한 보장도 없다. 단지 요청이 받아들이기에 적합해 보인다는 의미일 뿐이다. 서버는 엔터티 본문에 요청게 대한 상태와 가급적 요청의 처리가 언제 완료 될 것인지에 대한 추정도 포함해야 한다.
203 | Non-Authoritative Information | 엔터티 헤어에 들어있는 정보가 원래 서버가 아닌 리소스의 사본에서 왔다. 리소스의 사본은 있지만 그에 대한 메타 정보를 검증하지 못한 경우이다. 이 응답코드는 필수가 아니기 때문에, 원래 서버에서 왔다면 200 상태였을 애플리케이션을 위한 선택사항이다.
204 | No Content | 응답 메시지는 헤더와 상태줄을 포함하지만 엔터티 본문은 포함하지 않는다. 웹 브라우저 새로 고침할 때 사용한다.
205 | Reset Content | 브라우저에게 현재 페이지에 있는 HTML 폼의 값을 비우라고 할때 사용한다.
206 | Partial Content | 부분적으로 요청이 성공했다. 206 응답은 Content-Rage와 Date 헤더를 반드시 포함해야 하며, Etag와 Content-Location 중 하나의 헤더도 반드시 포함해야 한다.

### 3.4.3 300-399: 리다이렉션 상태 코드
리다이렉션 상태 코드는 클라이언트가 관심있어 하는 리소스에 대해 다른 위치를 사용하라고 말해주거나 그 리고그의 내용 대신 다른 대안 응답을 제공한다. 만약 리소스가 옮겨졌다면, 클라이언트에게 리소스가 옮겨졌으며 어디서 찾을 수 있는지 알려주기 위해 리다이렉션 상태 코드와 선택적으로 Location 헤더를 보낼 수 있다.(이를 활용해 브라우저는 알아서 새 위치로 이동한다.)

![]({{ site.url }}/img/post/http/3.13.png)

리다이렉션 상태 코드중 몇몇은 로컬 복사본이 갱신되엇는지 확인하기 위해 사용된다.

![]({{ site.url }}/img/post/http/3.14.png)
> 클라이언트는 문서가 1997년 10월 이후 수정된 경우에만 문서를 가져오라고 하기 위해 If-Modified-Since 헤더를 전송한다. 변함이 없다면 콘텐츠 대신 304 코드를 답할 것이다.

일반적으로 HEAD가 아닌 요청에 대해 리다이렉션 상태 코드를 포함한 응답을 할 때, 리다이렉트 될 URL에 대한 링크와 설명을 포함시키는 것은 좋은 습관이다.

상태 코드 | 사유 구절 | 의미
---|---|---
300 | Multiple Choices | 클라이언트가 동시에 여러 리소스를 가리키는 URL을 요청한 경우, 그 리소스 목록을 함께 반환한다. 사용자는 목록에서 원하는 하나를 선택할 수 있다. 예를 들어 서버가 하나의 HTML 문서를 영어와 프랑스어 모두 제공하는 경우에 사용한다. 서버는 Location 헤더에 선호하는 URL을 포함시킬 수 있다.
301 | Moved Permanently | 요청한 URL이 옮겨졌을 때 사용한다. 응답은 Location 헤더에 현재 리소스가 존재하고 있는 URL을 포함해야 한다.
302 | Found | 301과 같다. 그러나 클라이언트는 Location 헤더로 주어진 URL을 리소르를 임시로 가리키기 위한 목적으로 사용해야 한다. 이후 요청은 원래 URL을 사용해야 한다.
303 | See Other | 클라이언트에게 리소스를 다른 URL에서 가져와야 한다고 말할때 사용한다. 새 URL은 응답 메시지의 Location 헤더에 들어있다. 이 상태 코드의 주 목적은 POST 요청에 대한 응답으로 클라이언트에게 리소스의 위치를 알려주는 것이다.
304 | Not Modified | 클라이언트는 헤더를 이용해 조건부 요청을 만들 수 있다. 만약 클라이언트가 GET과 같은 조건부 요청을 보냈고 그 요청한 리소스가 최근에 수정된 일이 없다면, 이 코드는 리소스가 수정되지 않았음을 의미하게 된다. 이 상태 코드를 동반한 응답은 엔터티 본문을 가져와서는 안된다.
305 | Use Proxy | 리소스가 반드시 프락시를 통해서 접근되어야 함을 나타내기 위해 사용한다. 프락시의 위치는 Location 헤더를 통해 주어진다. 프락시가 요청에 잘못 간섭한다면 오동작을 유발하거나 보안 문제를 일으킬 수 있다.
306 | (사용되지 않음) | 현재 사용되지 않는다.
307 | Temporary Redirect | 302와 같다.

302, 303, 307는 중복되는 부분들이 있지만 미묘한 차이가 있다. 주로 HTTP/1.0과 HTTP/1.1 애플리케이션이 이 상태 코드를 다루는 방식의 차이점이다.  
서버는 리다이렉트 응답에 들어갈 가장 적절한 리다이렉트 상태 코드를 선택하기 위해 클라이언트의 HTTP 버전을 검사할 필요가 있다.

### 3.4.4 400-499: 클라이언트 에러 상태 코드
클라이언트는 서버가 다룰 수 없는 무언가를 보내는 경우가 있다. 잘못 구성된 요청 메시지나 존재하지 않는 URL에 대한 요청등이 있다.  
많은 클라이언트 에러는 브라우저선에서 처리된다.(ex. 404 Not Found)

상태 코드 | 사유 구절 | 의미
---|---|---
400 | Bad Request | 클라이언트가 잘못된 요청을 보냄
401 | Unauthorized | 리소스를 얻기 전에 클라이언트에게 스스로 인증하라고 요구
402 | Payment Required | 미래에 사용될 가능성을 위해 준비됨.
403 | Forbidden | 요청이 서버에 의해 거부됨. 거절 이유를 엔터티 본문에 포함시킬 수 있지만, 보통은 서버가 거절 이류를 숨기고 싶을 때 사용.
404 | Not Found | 요청한 URL을 찾을 수 없음
405 | Method Not Allowed | 지원하지 않는 메서드 요청을 받음. 요청한 리소스가 어떤 메스드가 사용 가능한지 알려주기 위해, 요청에 Allow 헤더가 포함되어야 한다.
406 | Not Acceptable | 주어진 URL에 대한 리소스 중 클라이언트가 받아들일 수 있는 것이 없는 경우 사용. 클라이언트는 어떤 종류의 엔터티를 받아들이고자 하는지 매개변수로 명시한다.
407 | Proxy Authentication Required | 401과 같으나, 리소스에 대한 인증을 요구하는 프락시 서버를 위해 사용.
408 | Request Timeout | 클라이언트 요청을 완수하기에 시간이 너무 오래 걸리는 경우, 이 상태 코드를 응답하고 연결을 끊는다. 보통 타임아웃 길이는 어떤 요청도 받아들일 수 있을정도로 충분히 길다.
409 | Conflict | 요청이 리소스에 대해 일으킬수 있는 몇몇 충돌을 지징하기 위해 사용.
410 | Gone | 404와 비슷하나, 서버가 한때 그 리소스를 가지고 있었다는 차이점이 있다. 웹사이트 유지보수하면서 서버 관리자가 클라이언트에게 리소스가 제거된 경우 이를 알려주기 위해 사용.
411 | Length Required | 서버가 요청 메시지에 Content-Length 헤더가 있을 것을 요구할 때 사용.
412 | Precondition Failed | 클라이언트가 조건부 요청을 했는데 그중 하나가 실패한 경우 사용. 조건부 요청은 클라이언트가 Except 헤더를 포함했을 때 발생한다.
413 | Request Entity Too Lage | 서버가 처리할 수 있는, 처리하고자 하는 한계를 넘은 크기의 요청을 클라이언트가 보냈을 경우 사용.
414 | Request URI Too Long | 서버가 처리할 수 있는, 처리하고자 하는 한계를 넘은 길이의 요청 URL이 포함된 요청을 클라이언트가 보냈을 경우 사용.
415 | Unsupported Media Type | 서버가 이해하지 못하거나, 지원하지 못하는 유형의 엔터티를 클라이언트가 보낸 경우.
416 | Requested Range Not Satisfiable | 요청 메시지가 리소스의 특정 범위를 요청했는데, 그 범위가 잘못된 경우.
417 | Expectation Failed | 요청에 포함된 Except 요청 헤더에 서버가 만족시킬 수 없는 기대가 담겨 있는 경우. 프락시나 다른 중개자 애플리케이션은, 원 서버가 요청의 기대를 만족시킬 수 없을 명확한 증거가 있다면 이 응답 코드를 전송할 수 있다.

### 3.4.5 500-599: 서버 에러 상태 코드
클라이언트가 서버의 제란에 걸리거나, 게이트웨이 리소스와 같은 서버의 보조 구성요소에서 발생한 에러일 수도 있다.  

프락시는 클라이언트 입장에서 서버와 대화를 시도할 때 자주 에러를 만나게 된다. 프락시는 문제를 설명하기 위해 5XX 에러 코드를 생성한다.

상태 코드 | 사유 구절 | 의미
---|---|---
500 | Internal Server Error | 서버가 요청을 처리할 수 없게 만드는 에러를 만났을 경우.
501 | Not Implemented | 클라이언트가 서버의 능력을 넘은 요청을 했을 경우.(예: 서버가 지원하지 않는 메서드를 사용)
502 | Bad GateWay | 프락시나 게이트웨어처럼 행동하는 서버가 그 요청 응답 연쇄에 있는 다음 링크로부터 가짜 응답을 만났을 경우(예: 만약 자신의 부모 게이트웨이에 접속하는 것이 불가능한 경우)
503 | Service Unavaliable | 현재는 서버가 요청을 처리할 수 없지만, 나중에 가능함을 의미할 경우.
504 | Gateway Timeout | 408과 비슷하지만, 다른 서버에게 요청을 보내고 응답을 기다리다 타임아웃이 발생한 게이트웨이나 프락시에서 온 응답이라는 차이점이 있다.
505 | HTTP version Not Supported | 서버가 지원하지 않는 버전의 프로토콜로 된 요청을 받은 경우.
