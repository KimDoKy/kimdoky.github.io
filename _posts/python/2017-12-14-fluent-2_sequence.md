 ---
layout: post
section-type: post
title: Fluent Python - part2_chap2. 데이터 구조체 - 시퀀스
category: python
tags: [ 'python' ]
---

# 데이터 구조체

시퀀스, 매핑, 집합 등 컬렉션형의 사용 및 문자열과 바이트의 차이점에 대해 다룹니다. 기존에 제공되는 기능을 돌아보고, 조회하지 않을 때 딕셔너리의 키를 재정렬하거나, 지역화된 유니코드 문자열을 정렬할 때 주의해야 할 점 등 특이한 작동 방식에 대해 설명합니다. 시퀀스와 매칭을 설명하고, dict와 set 형의 기반이 되는 해시 테이블을 살펴봅니다.

# 시퀀스

파이썬을 만들기 전에 귀도는 ABC 언어에 참여하고 있었는데, ABC 언어는 초보자를 위한 프로그래밍 환경을 개발하기 위해 10년간 진행한 연구 프로젝트입니다. ABC는 시퀀스에 대한 범용 연산, 내장된 튜플과 매핑 자료형, 들여쓰기를 이용한 구문 구조 등 '파이썬스러운 것'이라 생각되는 여러 개념을 소개했고 파이썬은 시퀀스를 단일하게 처리하는 ABC의 특징을 물려받았습니다. 문자열, 리스트, 바이스 시퀀스, 배열, XML 요소, 데이터베이스 결과에는 모두 반복, 슬라이싱, 정렬, 연결 등 공통된 연산을 적용할 수 있습니다.

## 2.1 내장 시퀀스 개요
파이썬 표준 라이브러리는 C로 구현된 시퀀스형을 제공합니다.

#### 컨테이너 시퀀스
서로 다른 자료형의 항목들을 담을 수 있는 list, tuple, collections.deque 형

#### 균일 시퀀스
단 하나의 자료형만 담을 수 있는 str, bytes, bytearray, memoryview, array.array형

**컨테이너 시퀀스(container sequence)** 는 객체에 대한 참조를 담고 있으며 객체는 어떠한 자료형도 될 수 있지만, **균일 시퀀스(flat sequence)** 는 객체에 대한 참조 대신 자신의 메모리 공간에 각 항목의 값을 직접 담습니다. 따라서 균일 시퀀스가 메모리를 더 적게 사용하지만, 문자, 바이트, 숫자 등 기본적인 자료형만 담을 수 있습니다.  

시퀀스형은 가변성에 따라 분류할 수도 있습니다.

#### 가변 시퀀스
list, bytearray, array.array, collections.deque, memoryview 형

#### 불변 시퀀스
tuple, str, bytes 형

![]({{site.url}}/img/post/python/fluent/2.1.png)
위 그림을 보면 가변 시퀀스가 불변 시퀀스와 어떻게 다른지, 어느 메서드를 상속하는지 알 수 있습니다. 내장된 구체적인 시퀀스형들이 실제로 Sequence나 MutableSequence 추상 베이스 클래스(abstract base class)(ABC)를 상속하는 것은 아니지만, 추상 베이스 클래스를 이용하면 실제 시퀀스형에서 어느 기능을 제공할지 예측할 수 있습니다.  

가장 기본적인 시퀀스형인 list는 가변적이며 혼합된 자료형을 담을 수 있습니다. 지능형 리스트는 낯선 구문 때문에 많이 사용되지 않습니다. 제네레이터를 사용하면 어떤 자료형의 시퀀스도 쉽게 채울 수 있습니다.

## 2.2 지능형 리스트와 제너레이터 표현식
지능형 리스트(리스트형의 경우)나 제네레이터 표현식(그 외 시퀀스의 경우)을 사용하면 시퀀스를 간단히 생성할 수 있습니다. (지능형 리스트는 컴프리핸션을 말하는 것 같다.)

> tip. 파이썬 프로그래머들은 종종 지능형 리스트를 **listcomp** , 제네레이터 표현식을 **genexp** 으로 표기한다.

### 2.2.1 지능형 리스트와 가독성

```Python
>>> symbols = 'ø∆åˆ¬∫©∂'
>>> codes = []
>>> for symbol in symbols:
...     codes.append(ord(symbol))
...
>>> codes
[248, 8710, 229, 710, 172, 8747, 169, 8706]
```

```Python
>>> symbols = 'ø∆åˆ¬∫©∂'
>>> codes = [ord(symbol) for symbol in symbols]
>>> codes
[248, 8710, 229, 710, 172, 8747, 169, 8706]
```

위의 코드가 읽기 쉽지만 지능형 리스트을 안다면 뒤의 코드가 읽기 좋게 느껴질 수 있습니다.

생성된 리스트를 사용하지 않을 거라면 지능형 리스트 구문을 사용하지 말아야 합니다. 그리고 코드를 짧게 만들어야 합니다. 지능형 리스트 구문이 두 줄 이상 넘어가는 경우에는 코드를 분할하거나 for문을 이용해서 작성하는 것이 낫습니다. 정답은 없기 때문에 상식적으로 판단해야 합니다.
> tip. 파이썬에선 [], {}, () 안에서의 개행이 무시된다. 따라서 줄을 넘기기 위해 역슬래시(\\)를 사용하지 않고도 여러 줄에 걸쳐 리스트, 지능형 리스트, 제네레이터 표현식, 딕셔너리를 작성할 수 있습니다.

### 2.2.2 지능형 리스트와 map()/filter() 비교
`map()`과 `filter()` 함수를 이용해서 수행할 수 있는 작업은 기능적으로 문제가 있는 파이썬 람다(lambda)를 억지로 쓰지 않고도 지능형 리스트를 이용해서 모두 구현할 수 있습니다.

```Python
>>> symbols = 'ø∆åˆ¬∫©∂'
>>> beyond_ascii = [ord(s) for s in symbols if ord(s) > 200]
>>> beyond_ascii
[248, 8710, 229, 710, 8747, 8706]

>>> beyond_ascii = list(filter(lambda c: c > 200, map(ord, symbols)))
>>> beyond_ascii
[248, 8710, 229, 710, 8747, 8706]
````
아래 코드로 지능형 리스트와 map()/filter() 조합의 속도를 간단히 비교할 수 있습니다.

```python
import timeit

TIMES = 10000

SETUP = """
symbols = '$¢£¥€¤'
def non_asc  ii(c):
    return c > 127
"""

def clock(label, cmd):
    res = timeit.repeat(cmd, setup=SETUP, number=TIMES)
    print(label, *('{:.3f}'.format(x) for x in res))

clock('listcomp        :', '[ord(s) for s in symbols if ord(s) > 127]')
clock('listcomp + func :', '[ord(s) for s in symbols if non_ascii(ord(s))]')
clock('filter + lambda :', 'list(filter(lambda c: c > 127, map(ord, symbols)))')
clock('filter + func   :', 'list(filter(non_ascii, map(ord, symbols)))')
```
위 코드의 결과입니다.
```
listcomp        : 0.017 0.015 0.019
listcomp + func : 0.023 0.025 0.028
filter + lambda : 0.023 0.025 0.026
filter + func   : 0.025 0.022 0.023
```

### 2.2.3 데카르트 곱
지능형 리스트는 두 개 이상의 반복 가능한 자료형의 데카르트 곱을 나타내는 일련의 리스트를 만들 수 있습니다. 데카르트 곱 안에 들어 있는 각 항목은 입력으로 받은 반복 가능한 데이터의 각 요소에서 만들어진 튜플로 구성됩니다. 생성된 리스트의 길이는 입력으로 받은 반복 가능한 데이터의 길이와 같습니다.

![]({{site.url}}/img/post/python/fluent/2.2.png)

예를 들어 2가지 색과 3가지 티셔츠 리스트를 지능형 리스트를 이용해 생성해봅니다.

```Python
>>> colors = ['black', 'white']
>>> sizes = ['s', 'm', 'l']
>>> tshirts = [(color, size) for color in colors for size in sizes]
>>> tshirts
[('black', 's'), ('black', 'm'), ('black', 'l'), ('white', 's'), ('white', 'm'), ('white', 'l')]

>>> for color in colors:
...     for size in sizes:
...         print((color, size))
...
('black', 's')
('black', 'm')
('black', 'l')
('white', 's')
('white', 'm')
('white', 'l')
```

지능형 리스트는 단지 리스트를 만들 뿐입니다. 다른 종류의 시퀀스를 채우려면 제네레이터 표현식을 사용해야 합니다.

### 2.2.4 제네레이터 표현식
튜플, 배열 등이 시퀀스를 초기화할 땐 제네레이터 표현식을 사용하는 것이 메모리를 더 적게 사용합니다.(반복자 프로토콜(iterator protocol)을 이용해 항목을 하나씩 생성하기 때문)  

사용법은 지능형 리스트와 같지만 '[ ]' 대신 '( )'를 사용합니다.

```Python
>>> symbols = '¢£¥€¤'
>>> tuple(ord(symbol) for symbol in symbols)
(162, 163, 165, 8364, 164)

>>> import array
>>> array.array('I', (ord(symbol) for symbol in symbols))
array('I', [162, 163, 165, 8364, 164])
# 배열 생성자는 인수를 두 개 받으므로, 제네레이터 표현식 앞위에 반드시 괄호를 넣어야 합니다. 배열의 첫 번째 인수는 배열에 들어 갈 숫자들을 저장할 자료형을 지정합니다.
```

데카르트 곱에서 지능형 리스트로 생성했을 때와는 달리 제네레이터로 생성하면 리셔츠 리스트 6개 항목을 메모리안에 생성하지 않습니다. 제네레이터 표현식은 한 번에 한 항목을 생성할 수 있도록 for 루프에 데이터를 전달하기 때문입니다. 만약 사용할 리스트가 천 개가 있다면 제네레이터 표현식을 사용하면 천개의 항목이 들어 있는 리슽트를 생성하는 일을 피할 수 있습니다.

```python
>>> colors = ['black', 'white']
>>> sizes = ['s', 'm', 'l']
>>> for tshirt in ('%s %s' % (c, s) for c in colors for s in sizes):
...     print(tshirt)
...
black s
black m
black l
white s
white m
white l
# 제네레이터 표현식은 한 번에 하나의 항목을 생성합니다. 6개의 티셔츠 종류를 담고 있는 리스트를 만들지 않습니다.
```

## 2.3 튜플은 단순한 불변 리스트가 아니다
튜플은 '불변 리스트'으로 설명들 하지만, 필드명이 없는 레코드로 사용할 수도 있습니다.

### 2.3.1 레코드로서의 튜플
튜플은 레코드를 담고 있습니다. 튜플의 각 항목은 레코드의 필드 하나를 의미하며 항목의 위치가 의미를 결정합니다.  

튜플은 단지 불변 리스트로 사용한다면 항목의 크기와 순서가 중요하지 않을 수도 있습니다. 하지만 튜플을 필드의 집합으로 사용하는 경우, 항목 수가 고정되어 있고 항목의 순서가 중요합니다.  

아래의 코드는 튜플을 레코드로 사용하는 경우입니다. 튜플 안에서 항목의 위치가 항목을 위미하기 때문에 튜플을 정렬하면 정보가 파괴되는 점을 주의해야 합니다.

```Python
>>> lax_coordinates = (33.9425, -188.408056)
# 로스엔젤레스 국제공항의 위도와 경도
>>> city, year, pop, chg, area = ('Tokyo', 2017, 32450, 0.66, 8014)
# 도쿄에 대한 데이터(지명, 년도, 백만 단위 인구수, 인수 변화율, 제곱킬로미터 단위 면적)
>>> traveler_ids = [('USE', '31195855'), ('BRA', 'CE342567'), ('ESP', 'XDA205856')]
# (국가 코드, 여권 변호) 형태의 튜플로 구성된 리스트
>>> for passport in sorted(traveler_ids):
# 리스트를 반복할 때 passport 변수가 각 튜플로 바인딩된다.
...     print('%s/%s' % passport)
# 퍼센트 포멧 연산자는 튜플을 이해하고 각 항목을 하나의 필드로 처리한다.
...
BRA/CE342567
ESP/XDA205856
USE/31195855
>>> for country, _ in traveler_ids:
...     print(country)
# for 루프는 튜플의 각 항목을 어떻게 가져와야 하는지 알고 있습니다.(이 과정을 '언패킹'이라고 합니다.) 여기서 두 번째 항목에는 관심이 없으므로 더미 변수(dummy variable)를 나타내는 언더바(_)에 할당했습니다.
...
USE
BRA
ESP
```
튜플은 언패킹 메커니즘 덕분에 레코드로도 잘 작동합니다.

### 2.3.2 튜플 언패킹
위 코드의 단 하나의 문장에서 city, year, pop, chg, area 변수에 `{'Tokyo', 2017, 32450, 0.66, 8014}`를 할당했습니다. 그리고 퍼센트(%) 연산자는 print() 함수의 인수로 전달한 포맷 문자열의 각 슬록에 passport 튜플의 각 할목을 할당했습니다. 이 두 가지 예는 **튜플 언패킹(tuple unpacking)** 방법입니다.
> tip. 튜플 언패킹은 반복 가능한 객체라면 어느 객체든 적용할 수 있습니다. 초과된 항목을 잡기 위해 * 를 사용한 경우가 아니라면 반복 가능한 객체는 한 번에 하나의 항목을 생성한다는 점만 기억하면 됩니다. **튜플 언패킹** 이라는 용어를 널리 사용하고 있지만 공식문서엔 **반복형 언패킹(iterable unpacking)** 이라는 용어를 사용하고 있습니다.

튜플 언패킹은 **병렬 항당(parallel assignment)** 을 할 때 가장 빛을 발합니다. 다음 코드는 반복형 데이터를 변수로 구성된 튜플에 할당합니다.

```Python
>>> lax_coordinates = (33.9425, -188.408056)
>>> latitude, longitude = lax_coordinates # 튜플 언패킹
>>> latitude
33.9425
>>> longitude
-188.408056
```

튜플 언패킹을 이용하면 임시 변수를 사용하지 않고도 두 변수의 값을 서로 교환할 수 있습니다.

```Python
>>> b, a = a, b
```

함수를 호출할 때 인수 앞에 * 를 붙여 튜플 언패킹을 할 수 있습니다.

```Python
>>> divmod(20, 8)
(2, 4)
>>> t = (20, 8)
>>> divmod(*t)
(2, 4)
>>> quotient, remainder = divmod(*t)
>>> quotient, remainder
(2, 4)
```

위 코드는 튜플 언패킹의 또 다른 사용법을 보여줍니다. 함수에서 호출자에 여러 값을 간단히 반환하는 기능입니다. 예를 들어 os.path.split() 함수를 이용해서 파일 시스템 경로에서 경로명과 파일멸을 가져올 수 있습니다.

```Python
>>> import os
>>> _, filename = os.path.split('/home/doky/.ssh/idrsa.pub')
>>> filename
'idrsa.pub'
>>> _
'/home/doky/.ssh'
```
'\_'와 같은 더미 변수를 플레이스홀더로 사용해서 관심 없는 부분은 언패킹할 때 무시할 수 있습니다.

### 초과 할목을 잡기 위해 `*` 사용하기
함수 매개변수에 `*`를 연결해서 초과됨 인수를 가져오는 방법은 파이썬의 고전적인 기능입니다.

```Python
>>> a, b, *rest = range(5)
>>> a, b, rest
(0, 1, [2, 3, 4])
>>> a, b, *rest = range(3)
>>> a, b, rest
(0, 1, [2])
>>> a, b, *rest = range(2)
>>> a, b, rest
(0, 1, [])
```
병렬 할당의 경우 `*`는 단 하나의 변수에만 적용할 수 있지만, 어떠한 변수에도 젹용할 수 있습니다.

```Python
>>> a, *body, c, d = range(5)
>>> a, body, c, d
(0, [1, 2], 3, 4)
>>> *head, b, c, d = range(5)
>>> head, b, c, d
([0, 1], 2, 3, 4)
```
튜플 언패킹은 내포된 구조체에도 적용할 수 있습니다.

### 2.3.3 내포된 튜플 언패킹
언패킹할 표현식을 받는 튜플은 (a, b, (c, d))처럼 다른 튜플을 내포할 수 있고, 파이썬은 표현식이 내포된 구조체에 일치하면 제대로 처리합니다.

```Python
# longitude에 접근하기 위해 내포된 튜플 언패킹하기
metro_areas = [
    # 각 튜플은 4개의 필드로 구성된 레코드를 담고 있으며, 마지막 필드는 좌표쌍이다.
    ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)),
    ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)),
    ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)),
    ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)),
]

print('{:15} | {:^9} | {:^9}'.format('', 'let', 'long'))
fmt = '{:15} | {:^9.4f} | {:^9.4f}'
# 마지막 필드를 튜플에 할당함으로써 좌표를 언패킹합니다.
for name, cc, pop, (latitude, longitude) in metro_areas:
    # 이 조건문은 경우가 음수인 서빈구 도시만 출력하게 만듭니다.
    if longitude <= 0:
        print(fmt.format(name, latitude, longitude))
```
실행 결과입니다.
```python
|    let    |   long
Mexico City     |  19.4333  | -99.1333
New York-Newark |  40.8086  | -74.0204
```
튜플은 편리하지만 레코드로 사용하기엔 아직 부족합니다. 때로는 필드에 이름을 붙일 필요가 있는데 `namedtuple()`함수가 고안되어 있습니다.

### 2.3.4 명명된 튜플
`collections.namedtuple()`함수는 필드명과 클래스명을 추가한 튜플의 서브 클래스를 생성하는 팩토리 함수로써, 디버깅할 때 유용합니다.
> note. 필드명이 클래스에 저장되므로 namedtuple()로 생성한 객체는 튜플과 동일한 크기의 메모리만 사용한다. 속성을 객체마다 존재하는 `__dict__`에 저장하지 않으므로 일반적인 객체보다 메모리를 적게 사용한다.

```Python
>>> from collections import namedtuple
# 명명된 튜플을 정의하려면 클래스명과 필드명의 리스트 등 총 2개의 매개변수가 필요합니다. 필드명의 리스트는 반복형 문자열이나 공백으로 구문된 하나의 문자열을 이용해서 지정합니다.
>>> City = namedtuple('City', 'name country population coordinates')
# 데이터는 위치를 맞추고 콤마로 구분해서 생성자에 전달해야 합니다.
>>> tokyo = City('Tokyo', 'JP', 36.933, (35.689722, 139.691667))
>>> tokyo
City(name='Tokyo', country='JP', population=36.933, coordinates=(35.689722, 139.691667))
# 필드명이나 위치를 이용해서 필드에 접근할 수 있습니다.
>>> tokyo.population
36.933
>>> tokyo.coordinates
(35.689722, 139.691667)
>>> tokyo[1]
'JP'
```
명명된 튜플(named tuple)은 튜플에서 상속받은 속성 외에 몇가지 속성을 더 가지고 있습니다. `_fields`클래스 속성, `_make(iterable)`클래스 메서드, `_asdict()`객체 메서드가 있습니다.

```Python
# 명명된 튜플의 속성과 메서드

# _fields틑 클래스의 필드명을 담고 있는 튜플입니다.
>>> City._fields
('name', 'country', 'population', 'coordinates')
>>> LatLong = namedtuple('LatLong', 'lat long')
>>> delhi_data = ('Delhi NCR', 'IN', 21.935, LatLong(28.613889, 77.208889))
# _make()는 반복형 객체로부터 명명된 튜플을 만듭니다. City(*delhi_data)를 호출하는 코드와 동일한 역할을 수행합니다.
>>> delhi = City._make(delhi_data)
# _asdict()는 명명된 튜플 객체에서 만들어진 collections.OrderedDict 객체를 반환합니다. 이 메서드를 이용해 데이터를 보기 좋게 가공할 수 있습니다.
>>> delhi._asdict()
OrderedDict([('name', 'Delhi NCR'), ('country', 'IN'), ('population', 21.935), ('coordinates', LatLong(lat=28.613889, long=77.208889))])
>>> for key, value in delhi._asdict().items():
...     print(key + ':', value)
...
name: Delhi NCR
country: IN
population: 21.935
coordinates: LatLong(lat=28.613889, long=77.208889)
```

### 2.3.5 불변 리스트로서의 튜플
튜플을 불변 리스트로 사용할 때, 튜플과 리스트의 공통점을 알고 있으면 큰 도움이 됩니다. 튜플은 항목을 추가하거나 삭제하는 기능 및 `_reversed__()`메서드를 제외하고 리스트가 제공하는 메서드를 모두 지원합니다. `__reversed__()`는 최적화 때문에 생략했을 뿐이며, `reversed(my_tuple)`메서드는 `__reversed__()`를 이용하지 않습니다.

메서드 | 리스트 | 튜플 | 설명
---|---|---|---
`s.__add__(s2)` | √ | √ | s + s2 : 리스트를 연결한다.
`s.__iadd__(s2)` | √ | | s += s2 : 리스트를 연결하고 s에 저장한다.
`s.append(e)` | √ | | 제일 뒤에 요소를 하나 추가한다.
`s.clear()` | √ | | 모든 항목을 삭제한다.
`s.__contains__(e)` | √ | √ | e in s
`s.copy()` | √ | | 리스트를 얕게 복사한다.
`s.count(e)` | √ | √ | e가 발생한 횟수를 계산한다.
`s.__delitem__(p)` | √ | | p 위치의 요소를 삭제한다.
`s.extend(it)` | √ | | 반복형 it 안에 있는 요소를 추가한다.
`s.__getitem__(p)` | √ | √ | s[p] : p 위치의 요소를 가져온다.
`s.__getnewargs__()` | | √ | pickle을 이용해서 최적화된 직렬화를 지원한다.
`s.index(e)` | √ | √ | s 안에서 e가 처음 나타나는 위치를 삽입한다.
`s.insert(p, e)` | √ | | p 위치에 있는 요소 앞에 e요소를 삽입한다.
`s.__iter__()` | √ | √ | 반복자를 가져온다.
`s.__len__()` | √ | √ | len(s) : 항목 개수를 구한다.
`s.__mul__(n)` | √ | √ | s * n : 문자열을 반복한다.
`s.__imul__(n)` | √ | | s \*= n : 문자열을 반복하여 s에 저장한다.
`s.__rmul__(n)` | √ | √ | n * s : 역순 반복 추가 메서드
`s.pop([p])` | √ | | 마지막 항목이나 p 위치의 항목을 제거하고 반환한다.
`s.remove(e)` | √ | | e 값을 가진 첫 번째 항목을 삭제한다.
`s.reverse()` | √ | | 항목을 역순으로 배치한 후 s에 저장한다.
`s.__reversed__()` | √ | | 마지막에서 첫 번째 항목까지 반복하는 반복자를 반환한다.
`s.__setitem__(p, e)` | √ | | s[p] = e : e를 p위치에 저장하고, 기존 항목을 덮어쓴다.
`s.sort([key], [reverse])` | √ | | 선택적인 키워드 key와 reverse에 따라 항목을 정렬하고 s에 저장한다.


## 2.4 슬라이싱
파이썬의 list, tuple, str, 그외 모든 시퀀스형은 슬라이싱(slicing) 연산을 지원합니다.  

### 2.4.1 슬라이스와 범위 지정시에 마지막 항목이 포함되지 않는 이유

- 세 개의 항목을 생성하는 range(3)이나 my_list[:3]처럼 중단점만 이용해서 슬라이스나 범위를 지정할 때 길이를 계산하기 쉽다.
- 시작점과 중단점을 모두 지정할 때도 길이를 계산하기 쉽다. 단지 중단점에서 시작점을 빼면 된다.
- x 인덱스를 기준으로 겹침 없이 시퀀스를 분할하기 쉽다. my_list[:x]와 my_list[x:]로 지정하면 된다.

```Python
>>> l = [10, 20, 30, 40, 50, 60]
>>> l[:2]
[10, 20]
>>> l[2:]
[30, 40, 50, 60]
>>> l[:3]
[10, 20, 30]
>>> l[3:]
[40, 50, 60]
```

### 2.4.2 슬라이스 객체
`a:b:c` 표기법은 인덱스 연산을 수행하는 '[ ]'안에서만 사용할 수 있으며, `slice(a, b, c)` 객체를 생성합니다. `seq[start:stop:step]` 표현식을 평가하기 위해 파이썬은 `seq.__getitem__(slice(start,stop,step))`을 호출합니다. 시퀀스형을 직접 구현하지 않더라도 슬라이스 객체를 알아두면 도움이 됩니다. 스프레드시트에서 셸 범위에 이름을 붙이는 것처럼 슬라이스 객체는 슬라이스에 이름을 붙일 수 있게 해주기 때문입니다.  

```Python
>>> invoice = """
... 0......6........................40.........52...55.........
... 1909  Pimoroni                          $17.50      3    $52.50
... 1489  6mm Tactile Swich x20              $4.95      2     $9.90
... 1510  Panavise Jr - PV-201              $28.00      1    $28.00
... 1601  PiTFT Mini Kit 320x240            $34.95      1    $34.95
... """
>>> SKU = slice(0, 6)
>>> DESCRIPTION = slice(6, 40)
>>> UNIT_PRICE = slice(40, 52)
>>> QUANTITY = slice(52, 55)
>>> ITEM_TOTAL = slice(55, None)
>>> line_items = invoice.split('\n')[2:]
>>> for item in line_items:
...     print(item[UNIT_PRICE], item[DESCRIPTION])
...
    $17.50       Pimoroni
     $4.95       6mm Tactile Swich x20
    $28.00       Panavise Jr - PV-201
    $34.95       PiTFT Mini Kit 320x240
```
위 코드처럼 슬라이스에 이름을 붙여서 사용할 수 있습니다.

### 2.4.3 다차원 슬라이싱과 생략 기호
'[ ]' 연산자는 콤마로 구분해서 여러 개의 인덱스나 슬라이스를 가질 수 있습니다. 이 방법은 NumPy 패키지에서 `a[i, j]` 구문으로 2차원 numpy.ndarray 배열의 항목이나 `a[m:n], [k:l]`구문으로 2차원 슬라이스를 가져올 때 사용합니다. '[ ]' 연산자를 처리하는 `__getitem__()`과 `__setitem__()` 특수 메서드는 `a[i, j]`에 들어 있는 인덱스들을 튜플로 받습니다. 즉 `a[i, j]`를 평가하기 위해 파이썬은 `a.__getitem__((i,j))`를 호출합니다.  

파이썬에 대장된 시퀀스형은 1차원이므로 단 하나의 인덱스나 슬라이스만 지원하고 튜플은 지원하지 않습니다.  

3개의 마침표(...)로 표현된 생략 기로는 파이썬에 의해 하나의 토큰으로 인식됩니다. 이 기호는 Ellipsis 객체의 별명으로서 하나의 ellipsis 클래스의 객체입니다. 생략 기호 객체는 f(a, ..., z) 처럼 함수의 인수나, a[i,...]처럼 슬라이스의 한 부분으로 전달할 수 있습니다. NumPy는 다차원 배열을 슬라이싱할 때 생략 기호(...)를 사용합니다. 예를 들어 x가 4차원 배열이라면 x[i, ...]는 x[i, :, :, :,] 와 동일합니다.  

슬라이스는 시퀀스에서 정보를 추출할 뿐만 아니라 가변 시퀀스의 값을 변경할 때도 사용할 수 있습니다.(시퀀스를 새로 만드는 것이 아니라 일부 항목의 값을 시퀀스 안에서 직접 변경함)

### 2.4.4 슬라이스에 할당하기
할당문의 왼쪽에 슬라이스 표시법을 사용하거나 del 문의 대상 객체로 지정함으로써 가변 시퀀스를 연결하거나, 잘라 내거나, 값을 변경할 수 있습니다.

```Python
>>> l = list(range(10))
>>> l
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> l[2:5] = [20, 30]
>>> l
[0, 1, 20, 30, 5, 6, 7, 8, 9]
>>> del l[5:7]
>>> l
[0, 1, 20, 30, 5, 8, 9]
>>> l[3::2] = [11, 22]
>>> l
[0, 1, 20, 11, 5, 22, 9]
>>> l[2:5] = 100
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: can only assign an iterable
# 할당문의 대상이 슬라이스인 경우, 항목 하나만 할당하는 경우에도 할당문 오른쪽에는 반복 가능한 객체가 와야 한다.
>>> l[2:5] = [100]
>>> l
[0, 1, 100, 22, 9]
```

## 2.5 시퀀스에 덧셈과 곱셈 연산자 사용하기
일반적으로 덧셈의 경우 피연산자 두 개가 같은 자료형이어야 하며, 동일한 자료형의 시퀀스가 새로 만들어집니다.  

하나의 시퀀스를 여러 번 연결하려면 정수를 곱해서 표현합니다. 이 경우도 새로운 시퀀스가 만들어집니다.

```python
Type "help", "copyright", "credits" or "license" for more information.
>>> l = [1,2,3]
>>> l * 5
[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
>>> 5 * 'abcd'
'abcdabcdabcdabcdabcd'
```
덧셈과 곱셈 연산자는 언제나 객체를 만들고, 피연산자를 연결하지 않습니다.  

> a가 가변 항목을 담고 있을 때 a * n과 같은 표현삭울 사용하려면 주의를 기울여야 합니다. 원하지 않는 결과가 나올 수 있기 때문입니다. 예를 들어 리스트의 리스트를 초기화할 때 `my_list = [[]] * 3`으로 초기화하면 동일한 내부 리스트에 대한 참조 3개를 가진 리스트가 만들어지므로, 원치 않는 결과가 나올 수 있습니다.

### 2.5.1 리스트의 리스트 만들기
리스트 안의 리스트를 초기화해야 하는 경우가 종종 있습니다. 이런 리스트를 초기화할 때는 다음 코드처럼 지능형 리스트를 사용하는 것이 좋습니다.

```Python
# 길이가 3인 리스트 3개로 표현한 틱택토 보드
>>> board = [['_'] * 3 for i in range(3)]
>>> board
[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]
>>> board[1][2] = 'X'
>>> board
[['_', '_', '_'], ['_', '_', 'X'], ['_', '_', '_']]
```

## 2.6 시퀀스의 복합 할당
`+=`과 `*=` 등의 복합 할당 연산자는 첫 번째 피연산자에 따라 다르게 동작합니다.  

`+=` 연산자가 작동하도록 만드는 특수 메서드는 `__iadd__()`입니다.
> i는 in-place를 의미하며, 해당 변수를 직접 변경합니다.

그런데 `__iadd__()` 메서드가 구현되어 있지 않으면, 파이썬은 대신 `__add__()` 메서드를 호출합니다.  

```Python
>>> a += b
```
a가 `__iadd__()` 메서드를 구현하면 구현된 메서드가 호출됩니다. a가 list, bytearray, array.array 등 가변 시퀀스인 경우 a의 값이 변경됩니다.(a.extend(b)와 비슷합니다.) 그런데 a에 `__iadd__()` 메서드를 구현하지 않는 경우 a += b 표현식은 a = a + b가 되어 먼저 a + b를 평가하고, 객체를 새로 생성한 후 a에 할당됩니다. 즉, `__iadd__()` 메서드 구현 여부에 따라 a변수가 가리키는 객체의 정체성이 바뀔 수도 있습니다.  

일반적으로 가변 시퀀스는 `__iadd__()` 메서드를 구현해서 += 연산자가 기존 객체의 내용을 변경하게 만드는 것이 좋습니다. 불변 시퀀스의 경우 이 연산을 수행할 수 없습니다.  

`*=` 연산자도 동일하게 적용되는데, `__imul__()` 메서드를 통해서 구현됩니다.

```Python
>>> l = [1,2,3]
>>> id(l)
4448971016  # 초기 리스트의 ID
>>> l *= 2
>>> l
[1, 2, 3, 1, 2, 3]
>>> id(l)
4448971016  # 곱셈 연산을 수행한 후 새로운 항목이 추가된 리스트는 기존과 같은 객체이다.
>>> t = (1,2,3)
>>> id(t)
4448973448  # 초기 튜플 객체의 ID
>>> t *= 2
>>> id(t)
4448985160  # 곱셈 연산을 수행한 후 새로운 튜플 객체가 만들어졌다.
```
새로운 항목을 추가된 시퀀스 전체를 새로 만들어 타깃 변수에 저장하므로, 불변 시퀀스에 반복적으로 연결 연산을 수행하는 것은 비효율적입니다.

> str 객체의 작동 방식을 다릅니다. 실제로 루프 안에서 += 연산자를 이용해서 문자열을 만드는 작업을 자주 사용하므로 CPython은 이런 용법에 최적화되어 있습니다. str 객체는 메모리 안에 여분의 공간을 갖고 할당되므로 str 객체를 연결할 때 매번 전체 문자열을 다시 생성하지 않습니다.

### 2.6.1 += 복합 할당 퀴즈

```Python
>>> t = (1,2,[30,40])
>>> t[2] += [50,60]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> t
(1, 2, [30, 40, 50, 60])
```

위의 경우 t는 `(1, 2, [30, 40, 50, 60])`가 되면서, '튜플 객체의 항목 할당을 지원하지 않는다'라는 타입에러가 발생한다. 에러는 나지만 동작은 한다.

[온라인 파이썬 튜터](http://www.pythontutor.com)는 파이썬 동작을 시각적으로 보여줍니다. 파이썬 튜터를 통해 시각적으로 t 튜플의 초기 상태와 최종 상태를 볼 수 있습니다.

![]({{site.url}}/img/post/python/fluent/2.3.png)

s[a] += b 표현식에 대해 파이썬이 생성한 바이트코드를 보면 어떻게 이런 일이 발생했는지 알 수 있습니다.

```python
>>> import dis
>>> dis.dis('s[a] += b')
  1           0 LOAD_NAME                0 (s)
              3 LOAD_NAME                1 (a)
              6 DUP_TOP_TWO
              7 BINARY_SUBSCR            # s[a] 값을 스택의 꼭대기(TOS.Top Of Stack)에 놓는다.
              8 LOAD_NAME                2 (b)
             11 INPLACE_ADD              # TOS += b 연산을 수행한다. TOS가 가변 객체를 가리티면 이 연산은 성공한다.
             12 ROT_THREE
             13 STORE_SUBSCR             # TOS를 s[a]에 할당한다. s가 불변 객체면 연산은 실패한다.
             14 LOAD_CONST               0 (None)
             17 RETURN_VALUE
```
이 예는 상당히 드문 경우입니다. 이 코드에서 3가지 교훈을 얻을 수 있습니다.

- 가변 항목을 튜플에 넣는 것은 좋은 생각이 아니다.
- 복합 할당은 원자적인 연산이 아니다.(일부 연산이 수행된 후 예외가 발생한 것처럼)
- 파이썬 바이트코드를 살펴보는 것은 어렵지 않고, 내부에서 어떤 일이 발생하고 잇는지 살펴보는데 도움이 된다.
