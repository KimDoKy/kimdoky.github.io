 ---
layout: post
section-type: post
title: Fluent Python - part2_chap2. 데이터 구조체 - 시퀀스
category: python
tags: [ 'python' ]
---

# 데이터 구조체

시퀀스, 매핑, 집합 등 컬렉션형의 사용 및 문자열과 바이트의 차이점에 대해 다룹니다. 기존에 제공되는 기능을 돌아보고, 조회하지 않을 때 딕셔너리의 키를 재정렬하거나, 지역화된 유니코드 문자열을 정렬할 때 주의해야 할 점 등 특이한 작동 방식에 대해 설명합니다. 시퀀스와 매칭을 설명하고, dict와 set 형의 기반이 되는 해시 테이블을 살펴봅니다.

# 시퀀스

파이썬을 만들기 전에 귀도는 ABC 언어에 참여하고 있었는데, ABC 언어는 초보자를 위한 프로그래밍 환경을 개발하기 위해 10년간 진행한 연구 프로젝트입니다. ABC는 시퀀스에 대한 범용 연산, 내장된 튜플과 매핑 자료형, 들여쓰기를 이용한 구문 구조 등 '파이썬스러운 것'이라 생각되는 여러 개념을 소개했고 파이썬은 시퀀스를 단일하게 처리하는 ABC의 특징을 물려받았습니다. 문자열, 리스트, 바이스 시퀀스, 배열, XML 요소, 데이터베이스 결과에는 모두 반복, 슬라이싱, 정렬, 연결 등 공통된 연산을 적용할 수 있습니다.

## 2.1 내장 시퀀스 개요
파이썬 표준 라이브러리는 C로 구현된 시퀀스형을 제공합니다.

#### 컨테이너 시퀀스
서로 다른 자료형의 항목들을 담을 수 있는 list, tuple, collections.deque 형

#### 균일 시퀀스
단 하나의 자료형만 담을 수 있는 str, bytes, bytearray, memoryview, array.array형

**컨테이너 시퀀스(container sequence)** 는 객체에 대한 참조를 담고 있으며 객체는 어떠한 자료형도 될 수 있지만, **균일 시퀀스(flat sequence)** 는 객체에 대한 참조 대신 자신의 메모리 공간에 각 항목의 값을 직접 담습니다. 따라서 균일 시퀀스가 메모리를 더 적게 사용하지만, 문자, 바이트, 숫자 등 기본적인 자료형만 담을 수 있습니다.  

시퀀스형은 가변성에 따라 분류할 수도 있습니다.

#### 가변 시퀀스
list, bytearray, array.array, collections.deque, memoryview 형

#### 불변 시퀀스
tuple, str, bytes 형

![]({{site.url}}/img/post/python/fluent/2.1.png)
위 그림을 보면 가변 시퀀스가 불변 시퀀스와 어떻게 다른지, 어느 메서드를 상속하는지 알 수 있습니다. 내장된 구체적인 시퀀스형들이 실제로 Sequence나 MutableSequence 추상 베이스 클래스(abstract base class)(ABC)를 상속하는 것은 아니지만, 추상 베이스 클래스를 이용하면 실제 시퀀스형에서 어느 기능을 제공할지 예측할 수 있습니다.  

가장 기본적인 시퀀스형인 list는 가변적이며 혼합된 자료형을 담을 수 있습니다. 지능형 리스트는 낯선 구문 때문에 많이 사용되지 않습니다. 제네레이터를 사용하면 어떤 자료형의 시퀀스도 쉽게 채울 수 있습니다.

## 2.2 지능형 리스트와 제너레이터 표현식
지능형 리스트(리스트형의 경우)나 제네레이터 표현식(그 외 시퀀스의 경우)을 사용하면 시퀀스를 간단히 생성할 수 있습니다. (지능형 리스트는 컴프리핸션을 말하는 것 같다.)

> tip. 파이썬 프로그래머들은 종종 지능형 리스트를 **listcomp** , 제네레이터 표현식을 **genexp** 으로 표기한다.

### 2.2.1 지능형 리스트와 가독성

```Python
>>> symbols = 'ø∆åˆ¬∫©∂'
>>> codes = []
>>> for symbol in symbols:
...     codes.append(ord(symbol))
...
>>> codes
[248, 8710, 229, 710, 172, 8747, 169, 8706]
```

```Python
>>> symbols = 'ø∆åˆ¬∫©∂'
>>> codes = [ord(symbol) for symbol in symbols]
>>> codes
[248, 8710, 229, 710, 172, 8747, 169, 8706]
```

위의 코드가 읽기 쉽지만 지능형 리스트을 안다면 뒤의 코드가 읽기 좋게 느껴질 수 있습니다.

생성된 리스트를 사용하지 않을 거라면 지능형 리스트 구문을 사용하지 말아야 합니다. 그리고 코드를 짧게 만들어야 합니다. 지능형 리스트 구문이 두 줄 이상 넘어가는 경우에는 코드를 분할하거나 for문을 이용해서 작성하는 것이 낫습니다. 정답은 없기 때문에 상식적으로 판단해야 합니다.
> tip. 파이썬에선 [], {}, () 안에서의 개행이 무시된다. 따라서 줄을 넘기기 위해 역슬래시(\\)를 사용하지 않고도 여러 줄에 걸쳐 리스트, 지능형 리스트, 제네레이터 표현식, 딕셔너리를 작성할 수 있습니다.

### 2.2.2 지능형 리스트와 map()/filter() 비교
`map()`과 `filter()` 함수를 이용해서 수행할 수 있는 작업은 기능적으로 문제가 있는 파이썬 람다(lambda)를 억지로 쓰지 않고도 지능형 리스트를 이용해서 모두 구현할 수 있습니다.

```Python
>>> symbols = 'ø∆åˆ¬∫©∂'
>>> beyond_ascii = [ord(s) for s in symbols if ord(s) > 200]
>>> beyond_ascii
[248, 8710, 229, 710, 8747, 8706]

>>> beyond_ascii = list(filter(lambda c: c > 200, map(ord, symbols)))
>>> beyond_ascii
[248, 8710, 229, 710, 8747, 8706]
````
아래 코드로 지능형 리스트와 map()/filter() 조합의 속도를 간단히 비교할 수 있습니다.

```python
import timeit

TIMES = 10000

SETUP = """
symbols = '$¢£¥€¤'
def non_asc  ii(c):
    return c > 127
"""

def clock(label, cmd):
    res = timeit.repeat(cmd, setup=SETUP, number=TIMES)
    print(label, *('{:.3f}'.format(x) for x in res))

clock('listcomp        :', '[ord(s) for s in symbols if ord(s) > 127]')
clock('listcomp + func :', '[ord(s) for s in symbols if non_ascii(ord(s))]')
clock('filter + lambda :', 'list(filter(lambda c: c > 127, map(ord, symbols)))')
clock('filter + func   :', 'list(filter(non_ascii, map(ord, symbols)))')
```
위 코드의 결과입니다.
```
listcomp        : 0.017 0.015 0.019
listcomp + func : 0.023 0.025 0.028
filter + lambda : 0.023 0.025 0.026
filter + func   : 0.025 0.022 0.023
```

### 2.2.3 데카르트 곱
지능형 리스트는 두 개 이상의 반복 가능한 자료형의 데카르트 곱을 나타내는 일련의 리스트를 만들 수 있습니다. 데카르트 곱 안에 들어 있는 각 항목은 입력으로 받은 반복 가능한 데이터의 각 요소에서 만들어진 튜플로 구성됩니다. 생성된 리스트의 길이는 입력으로 받은 반복 가능한 데이터의 길이와 같습니다.

![]({{site.url}}/img/post/python/fluent/2.2.png)

예를 들어 2가지 색과 3가지 티셔츠 리스트를 지능형 리스트를 이용해 생성해봅니다.

```Python
>>> colors = ['black', 'white']
>>> sizes = ['s', 'm', 'l']
>>> tshirts = [(color, size) for color in colors for size in sizes]
>>> tshirts
[('black', 's'), ('black', 'm'), ('black', 'l'), ('white', 's'), ('white', 'm'), ('white', 'l')]

>>> for color in colors:
...     for size in sizes:
...         print((color, size))
...
('black', 's')
('black', 'm')
('black', 'l')
('white', 's')
('white', 'm')
('white', 'l')
```

지능형 리스트는 단지 리스트를 만들 뿐입니다. 다른 종류의 시퀀스를 채우려면 제네레이터 표현식을 사용해야 합니다.

### 2.2.4 제네레이터 표현식
튜플, 배열 등이 시퀀스를 초기화할 땐 제네레이터 표현식을 사용하는 것이 메모리를 더 적게 사용합니다.(반복자 프로토콜(iterator protocol)을 이용해 항목을 하나씩 생성하기 때문)  

사용법은 지능형 리스트와 같지만 '[ ]' 대신 '( )'를 사용합니다.

```Python
>>> symbols = '¢£¥€¤'
>>> tuple(ord(symbol) for symbol in symbols)
(162, 163, 165, 8364, 164)

>>> import array
>>> array.array('I', (ord(symbol) for symbol in symbols))
array('I', [162, 163, 165, 8364, 164])
# 배열 생성자는 인수를 두 개 받으므로, 제네레이터 표현식 앞위에 반드시 괄호를 넣어야 합니다. 배열의 첫 번째 인수는 배열에 들어 갈 숫자들을 저장할 자료형을 지정합니다.
```

데카르트 곱에서 지능형 리스트로 생성했을 때와는 달리 제네레이터로 생성하면 리셔츠 리스트 6개 항목을 메모리안에 생성하지 않습니다. 제네레이터 표현식은 한 번에 한 항목을 생성할 수 있도록 for 루프에 데이터를 전달하기 때문입니다. 만약 사용할 리스트가 천 개가 있다면 제네레이터 표현식을 사용하면 천개의 항목이 들어 있는 리슽트를 생성하는 일을 피할 수 있습니다.

```python
>>> colors = ['black', 'white']
>>> sizes = ['s', 'm', 'l']
>>> for tshirt in ('%s %s' % (c, s) for c in colors for s in sizes):
...     print(tshirt)
...
black s
black m
black l
white s
white m
white l
# 제네레이터 표현식은 한 번에 하나의 항목을 생성합니다. 6개의 티셔츠 종류를 담고 있는 리스트를 만들지 않습니다.
```

## 2.3 튜플은 단순한 불변 리스트가 아니다
튜플은 '불변 리스트'으로 설명들 하지만, 필드명이 없는 레코드로 사용할 수도 있습니다.

### 2.3.1 레코드로서의 튜플
튜플은 레코드를 담고 있습니다. 튜플의 각 항목은 레코드의 필드 하나를 의미하며 항목의 위치가 의미를 결정합니다.  

튜플은 단지 불변 리스트로 사용한다면 항목의 크기와 순서가 중요하지 않을 수도 있습니다. 하지만 튜플을 필드의 집합으로 사용하는 경우, 항목 수가 고정되어 있고 항목의 순서가 중요합니다.  

아래의 코드는 튜플을 레코드로 사용하는 경우입니다. 튜플 안에서 항목의 위치가 항목을 위미하기 때문에 튜플을 정렬하면 정보가 파괴되는 점을 주의해야 합니다.

```Python
>>> lax_coordinates = (33.9425, -188.408056)
# 로스엔젤레스 국제공항의 위도와 경도
>>> city, year, pop, chg, area = ('Tokyo', 2017, 32450, 0.66, 8014)
# 도쿄에 대한 데이터(지명, 년도, 백만 단위 인구수, 인수 변화율, 제곱킬로미터 단위 면적)
>>> traveler_ids = [('USE', '31195855'), ('BRA', 'CE342567'), ('ESP', 'XDA205856')]
# (국가 코드, 여권 변호) 형태의 튜플로 구성된 리스트
>>> for passport in sorted(traveler_ids):
# 리스트를 반복할 때 passport 변수가 각 튜플로 바인딩된다.
...     print('%s/%s' % passport)
# 퍼센트 포멧 연산자는 튜플을 이해하고 각 항목을 하나의 필드로 처리한다.
...
BRA/CE342567
ESP/XDA205856
USE/31195855
>>> for country, _ in traveler_ids:
...     print(country)
# for 루프는 튜플의 각 항목을 어떻게 가져와야 하는지 알고 있습니다.(이 과정을 '언패킹'이라고 합니다.) 여기서 두 번째 항목에는 관심이 없으므로 더미 변수(dummy variable)를 나타내는 언더바(_)에 할당했습니다.
...
USE
BRA
ESP
```
튜플은 언패킹 메커니즘 덕분에 레코드로도 잘 작동합니다.

### 2.3.2 튜플 언패킹
위 코드의 단 하나의 문장에서 city, year, pop, chg, area 변수에 `{'Tokyo', 2017, 32450, 0.66, 8014}`를 할당했습니다. 그리고 퍼센트(%) 연산자는 print() 함수의 인수로 전달한 포맷 문자열의 각 슬록에 passport 튜플의 각 할목을 할당했습니다. 이 두 가지 예는 **튜플 언패킹(tuple unpacking)** 방법입니다.
> tip. 튜플 언패킹은 반복 가능한 객체라면 어느 객체든 적용할 수 있습니다. 초과된 항목을 잡기 위해 * 를 사용한 경우가 아니라면 반복 가능한 객체는 한 번에 하나의 항목을 생성한다는 점만 기억하면 됩니다. **튜플 언패킹** 이라는 용어를 널리 사용하고 있지만 공식문서엔 **반복형 언패킹(iterable unpacking)** 이라는 용어를 사용하고 있습니다.

튜플 언패킹은 **병렬 항당(parallel assignment)** 을 할 때 가장 빛을 발합니다. 다음 코드는 반복형 데이터를 변수로 구성된 튜플에 할당합니다.

```Python
>>> lax_coordinates = (33.9425, -188.408056)
>>> latitude, longitude = lax_coordinates # 튜플 언패킹
>>> latitude
33.9425
>>> longitude
-188.408056
```

튜플 언패킹을 이용하면 임시 변수를 사용하지 않고도 두 변수의 값을 서로 교환할 수 있습니다.

```Python
>>> b, a = a, b
```

함수를 호출할 때 인수 앞에 * 를 붙여 튜플 언패킹을 할 수 있습니다.

```Python
>>> divmod(20, 8)
(2, 4)
>>> t = (20, 8)
>>> divmod(*t)
(2, 4)
>>> quotient, remainder = divmod(*t)
>>> quotient, remainder
(2, 4)
```

위 코드는 튜플 언패킹의 또 다른 사용법을 보여줍니다. 함수에서 호출자에 여러 값을 간단히 반환하는 기능입니다. 예를 들어 os.path.split() 함수를 이용해서 파일 시스템 경로에서 경로명과 파일멸을 가져올 수 있습니다.

```Python
>>> import os
>>> _, filename = os.path.split('/home/doky/.ssh/idrsa.pub')
>>> filename
'idrsa.pub'
>>> _
'/home/doky/.ssh'
```
'\_'와 같은 더미 변수를 플레이스홀더로 사용해서 관심 없는 부분은 언패킹할 때 무시할 수 있습니다.

### 초과 할목을 잡기 위해 `*` 사용하기
함수 매개변수에 `*`를 연결해서 초과됨 인수를 가져오는 방법은 파이썬의 고전적인 기능입니다.

```Python
>>> a, b, *rest = range(5)
>>> a, b, rest
(0, 1, [2, 3, 4])
>>> a, b, *rest = range(3)
>>> a, b, rest
(0, 1, [2])
>>> a, b, *rest = range(2)
>>> a, b, rest
(0, 1, [])
```
병렬 할당의 경우 `*`는 단 하나의 변수에만 적용할 수 있지만, 어떠한 변수에도 젹용할 수 있습니다.

```Python
>>> a, *body, c, d = range(5)
>>> a, body, c, d
(0, [1, 2], 3, 4)
>>> *head, b, c, d = range(5)
>>> head, b, c, d
([0, 1], 2, 3, 4)
```
튜플 언패킹은 내포된 구조체에도 적용할 수 있습니다.

### 2.3.3 내포된 튜플 언패킹
언패킹할 표현식을 받는 튜플은 (a, b, (c, d))처럼 다른 튜플을 내포할 수 있고, 파이썬은 표현식이 내포된 구조체에 일치하면 제대로 처리합니다.

```Python
# longitude에 접근하기 위해 내포된 튜플 언패킹하기
metro_areas = [
    # 각 튜플은 4개의 필드로 구성된 레코드를 담고 있으며, 마지막 필드는 좌표쌍이다.
    ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)),
    ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)),
    ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)),
    ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)),
]

print('{:15} | {:^9} | {:^9}'.format('', 'let', 'long'))
fmt = '{:15} | {:^9.4f} | {:^9.4f}'
# 마지막 필드를 튜플에 할당함으로써 좌표를 언패킹합니다.
for name, cc, pop, (latitude, longitude) in metro_areas:
    # 이 조건문은 경우가 음수인 서빈구 도시만 출력하게 만듭니다.
    if longitude <= 0:
        print(fmt.format(name, latitude, longitude))
```
실행 결과입니다.
```python
|    let    |   long
Mexico City     |  19.4333  | -99.1333
New York-Newark |  40.8086  | -74.0204
```
튜플은 편리하지만 레코드로 사용하기엔 아직 부족합니다. 때로는 필드에 이름을 붙일 필요가 있는데 `namedtuple()`함수가 고안되어 있습니다.

### 2.3.4 명명된 튜플
`collections.namedtuple()`함수는 필드명과 클래스명을 추가한 튜플의 서브 클래스를 생성하는 팩토리 함수로써, 디버깅할 때 유용합니다.
> note. 필드명이 클래스에 저장되므로 namedtuple()로 생성한 객체는 튜플과 동일한 크기의 메모리만 사용한다. 속성을 객체마다 존재하는 `__dict__`에 저장하지 않으므로 일반적인 객체보다 메모리를 적게 사용한다.

```Python
>>> from collections import namedtuple
# 명명된 튜플을 정의하려면 클래스명과 필드명의 리스트 등 총 2개의 매개변수가 필요합니다. 필드명의 리스트는 반복형 문자열이나 공백으로 구문된 하나의 문자열을 이용해서 지정합니다.
>>> City = namedtuple('City', 'name country population coordinates')
# 데이터는 위치를 맞추고 콤마로 구분해서 생성자에 전달해야 합니다.
>>> tokyo = City('Tokyo', 'JP', 36.933, (35.689722, 139.691667))
>>> tokyo
City(name='Tokyo', country='JP', population=36.933, coordinates=(35.689722, 139.691667))
# 필드명이나 위치를 이용해서 필드에 접근할 수 있습니다.
>>> tokyo.population
36.933
>>> tokyo.coordinates
(35.689722, 139.691667)
>>> tokyo[1]
'JP'
```
명명된 튜플(named tuple)은 튜플에서 상속받은 속성 외에 몇가지 속성을 더 가지고 있습니다. `_fields`클래스 속성, `_make(iterable)`클래스 메서드, `_asdict()`객체 메서드가 있습니다.

```Python
# 명명된 튜플의 속성과 메서드

# _fields틑 클래스의 필드명을 담고 있는 튜플입니다.
>>> City._fields
('name', 'country', 'population', 'coordinates')
>>> LatLong = namedtuple('LatLong', 'lat long')
>>> delhi_data = ('Delhi NCR', 'IN', 21.935, LatLong(28.613889, 77.208889))
# _make()는 반복형 객체로부터 명명된 튜플을 만듭니다. City(*delhi_data)를 호출하는 코드와 동일한 역할을 수행합니다.
>>> delhi = City._make(delhi_data)
# _asdict()는 명명된 튜플 객체에서 만들어진 collections.OrderedDict 객체를 반환합니다. 이 메서드를 이용해 데이터를 보기 좋게 가공할 수 있습니다.
>>> delhi._asdict()
OrderedDict([('name', 'Delhi NCR'), ('country', 'IN'), ('population', 21.935), ('coordinates', LatLong(lat=28.613889, long=77.208889))])
>>> for key, value in delhi._asdict().items():
...     print(key + ':', value)
...
name: Delhi NCR
country: IN
population: 21.935
coordinates: LatLong(lat=28.613889, long=77.208889)
```

### 2.3.5 불변 리스트로서의 튜플
튜플을 불변 리스트로 사용할 때, 튜플과 리스트의 공통점을 알고 있으면 큰 도움이 됩니다. 튜플은 항목을 추가하거나 삭제하는 기능 및 `_reversed__()`메서드를 제외하고 리스트가 제공하는 메서드를 모두 지원합니다. `__reversed__()`는 최적화 때문에 생략했을 뿐이며, `reversed(my_tuple)`메서드는 `__reversed__()`를 이용하지 않습니다.

메서드 | 리스트 | 튜플 | 설명
---|---|---|---
`s.__add__(s2)` | √ | √ | s + s2 : 리스트를 연결한다.
`s.__iadd__(s2)` | √ | | s += s2 : 리스트를 연결하고 s에 저장한다.
`s.append(e)` | √ | | 제일 뒤에 요소를 하나 추가한다.
`s.clear()` | √ | | 모든 항목을 삭제한다.
`s.__contains__(e)` | √ | √ | e in s
`s.copy()` | √ | | 리스트를 얕게 복사한다.
`s.count(e)` | √ | √ | e가 발생한 횟수를 계산한다.
`s.__delitem__(p)` | √ | | p 위치의 요소를 삭제한다.
`s.extend(it)` | √ | | 반복형 it 안에 있는 요소를 추가한다.
`s.__getitem__(p)` | √ | √ | s[p] : p 위치의 요소를 가져온다.
`s.__getnewargs__()` | | √ | pickle을 이용해서 최적화된 직렬화를 지원한다.
`s.index(e)` | √ | √ | s 안에서 e가 처음 나타나는 위치를 삽입한다.
`s.insert(p, e)` | √ | | p 위치에 있는 요소 앞에 e요소를 삽입한다.
`s.__iter__()` | √ | √ | 반복자를 가져온다.
`s.__len__()` | √ | √ | len(s) : 항목 개수를 구한다.
`s.__mul__(n)` | √ | √ | s * n : 문자열을 반복한다.
`s.__imul__(n)` | √ | | s \*= n : 문자열을 반복하여 s에 저장한다.
`s.__rmul__(n)` | √ | √ | n * s : 역순 반복 추가 메서드
`s.pop([p])` | √ | | 마지막 항목이나 p 위치의 항목을 제거하고 반환한다.
`s.remove(e)` | √ | | e 값을 가진 첫 번째 항목을 삭제한다.
`s.reverse()` | √ | | 항목을 역순으로 배치한 후 s에 저장한다.
`s.__reversed__()` | √ | | 마지막에서 첫 번째 항목까지 반복하는 반복자를 반환한다.
`s.__setitem__(p, e)` | √ | | s[p] = e : e를 p위치에 저장하고, 기존 항목을 덮어쓴다.
`s.sort([key], [reverse])` | √ | | 선택적인 키워드 key와 reverse에 따라 항목을 정렬하고 s에 저장한다.


## 2.4 슬라이싱
파이썬의 list, tuple, str, 그외 모든 시퀀스형은 슬라이싱(slicing) 연산을 지원합니다.  

### 2.4.1 슬라이스와 범위 지정시에 마지막 항목이 포함되지 않는 이유

- 세 개의 항목을 생성하는 range(3)이나 my_list[:3]처럼 중단점만 이용해서 슬라이스나 범위를 지정할 때 길이를 계산하기 쉽다.
- 시작점과 중단점을 모두 지정할 때도 길이를 계산하기 쉽다. 단지 중단점에서 시작점을 빼면 된다.
- x 인덱스를 기준으로 겹침 없이 시퀀스를 분할하기 쉽다. my_list[:x]와 my_list[x:]로 지정하면 된다.

```Python
>>> l = [10, 20, 30, 40, 50, 60]
>>> l[:2]
[10, 20]
>>> l[2:]
[30, 40, 50, 60]
>>> l[:3]
[10, 20, 30]
>>> l[3:]
[40, 50, 60]
```

### 2.4.2 슬라이스 객체
`a:b:c` 표기법은 인덱스 연산을 수행하는 '[ ]'안에서만 사용할 수 있으며, `slice(a, b, c)` 객체를 생성합니다. `seq[start:stop:step]` 표현식을 평가하기 위해 파이썬은 `seq.__getitem__(slice(start,stop,step))`을 호출합니다. 시퀀스형을 직접 구현하지 않더라도 슬라이스 객체를 알아두면 도움이 됩니다. 스프레드시트에서 셸 범위에 이름을 붙이는 것처럼 슬라이스 객체는 슬라이스에 이름을 붙일 수 있게 해주기 때문입니다.  

```Python
>>> invoice = """
... 0......6........................40.........52...55.........
... 1909  Pimoroni                          $17.50      3    $52.50
... 1489  6mm Tactile Swich x20              $4.95      2     $9.90
... 1510  Panavise Jr - PV-201              $28.00      1    $28.00
... 1601  PiTFT Mini Kit 320x240            $34.95      1    $34.95
... """
>>> SKU = slice(0, 6)
>>> DESCRIPTION = slice(6, 40)
>>> UNIT_PRICE = slice(40, 52)
>>> QUANTITY = slice(52, 55)
>>> ITEM_TOTAL = slice(55, None)
>>> line_items = invoice.split('\n')[2:]
>>> for item in line_items:
...     print(item[UNIT_PRICE], item[DESCRIPTION])
...
    $17.50       Pimoroni
     $4.95       6mm Tactile Swich x20
    $28.00       Panavise Jr - PV-201
    $34.95       PiTFT Mini Kit 320x240
```
위 코드처럼 슬라이스에 이름을 붙여서 사용할 수 있습니다.

### 2.4.3 다차원 슬라이싱과 생략 기호
'[ ]' 연산자는 콤마로 구분해서 여러 개의 인덱스나 슬라이스를 가질 수 있습니다. 이 방법은 NumPy 패키지에서 `a[i, j]` 구문으로 2차원 numpy.ndarray 배열의 항목이나 `a[m:n], [k:l]`구문으로 2차원 슬라이스를 가져올 때 사용합니다. '[ ]' 연산자를 처리하는 `__getitem__()`과 `__setitem__()` 특수 메서드는 `a[i, j]`에 들어 있는 인덱스들을 튜플로 받습니다. 즉 `a[i, j]`를 평가하기 위해 파이썬은 `a.__getitem__((i,j))`를 호출합니다.  

파이썬에 대장된 시퀀스형은 1차원이므로 단 하나의 인덱스나 슬라이스만 지원하고 튜플은 지원하지 않습니다.  

3개의 마침표(...)로 표현된 생략 기로는 파이썬에 의해 하나의 토큰으로 인식됩니다. 이 기호는 Ellipsis 객체의 별명으로서 하나의 ellipsis 클래스의 객체입니다. 생략 기호 객체는 f(a, ..., z) 처럼 함수의 인수나, a[i,...]처럼 슬라이스의 한 부분으로 전달할 수 있습니다. NumPy는 다차원 배열을 슬라이싱할 때 생략 기호(...)를 사용합니다. 예를 들어 x가 4차원 배열이라면 x[i, ...]는 x[i, :, :, :,] 와 동일합니다.  

슬라이스는 시퀀스에서 정보를 추출할 뿐만 아니라 가변 시퀀스의 값을 변경할 때도 사용할 수 있습니다.(시퀀스를 새로 만드는 것이 아니라 일부 항목의 값을 시퀀스 안에서 직접 변경함)

### 2.4.4 슬라이스에 할당하기
할당문의 왼쪽에 슬라이스 표시법을 사용하거나 del 문의 대상 객체로 지정함으로써 가변 시퀀스를 연결하거나, 잘라 내거나, 값을 변경할 수 있습니다.

```Python
>>> l = list(range(10))
>>> l
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> l[2:5] = [20, 30]
>>> l
[0, 1, 20, 30, 5, 6, 7, 8, 9]
>>> del l[5:7]
>>> l
[0, 1, 20, 30, 5, 8, 9]
>>> l[3::2] = [11, 22]
>>> l
[0, 1, 20, 11, 5, 22, 9]
>>> l[2:5] = 100
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: can only assign an iterable
# 할당문의 대상이 슬라이스인 경우, 항목 하나만 할당하는 경우에도 할당문 오른쪽에는 반복 가능한 객체가 와야 한다.
>>> l[2:5] = [100]
>>> l
[0, 1, 100, 22, 9]
```

## 2.5 시퀀스에 덧셈과 곱셈 연산자 사용하기
일반적으로 덧셈의 경우 피연산자 두 개가 같은 자료형이어야 하며, 동일한 자료형의 시퀀스가 새로 만들어집니다.  

하나의 시퀀스를 여러 번 연결하려면 정수를 곱해서 표현합니다. 이 경우도 새로운 시퀀스가 만들어집니다.

```python
Type "help", "copyright", "credits" or "license" for more information.
>>> l = [1,2,3]
>>> l * 5
[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
>>> 5 * 'abcd'
'abcdabcdabcdabcdabcd'
```
덧셈과 곱셈 연산자는 언제나 객체를 만들고, 피연산자를 연결하지 않습니다.  

> a가 가변 항목을 담고 있을 때 a * n과 같은 표현삭울 사용하려면 주의를 기울여야 합니다. 원하지 않는 결과가 나올 수 있기 때문입니다. 예를 들어 리스트의 리스트를 초기화할 때 `my_list = [[]] * 3`으로 초기화하면 동일한 내부 리스트에 대한 참조 3개를 가진 리스트가 만들어지므로, 원치 않는 결과가 나올 수 있습니다.

### 2.5.1 리스트의 리스트 만들기
리스트 안의 리스트를 초기화해야 하는 경우가 종종 있습니다. 이런 리스트를 초기화할 때는 다음 코드처럼 지능형 리스트를 사용하는 것이 좋습니다.

```Python
# 길이가 3인 리스트 3개로 표현한 틱택토 보드
>>> board = [['_'] * 3 for i in range(3)]
>>> board
[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]
>>> board[1][2] = 'X'
>>> board
[['_', '_', '_'], ['_', '_', 'X'], ['_', '_', '_']]
```

## 2.6 시퀀스의 복합 할당
`+=`과 `*=` 등의 복합 할당 연산자는 첫 번째 피연산자에 따라 다르게 동작합니다.  

`+=` 연산자가 작동하도록 만드는 특수 메서드는 `__iadd__()`입니다.
> i는 in-place를 의미하며, 해당 변수를 직접 변경합니다.

그런데 `__iadd__()` 메서드가 구현되어 있지 않으면, 파이썬은 대신 `__add__()` 메서드를 호출합니다.  

```Python
>>> a += b
```
a가 `__iadd__()` 메서드를 구현하면 구현된 메서드가 호출됩니다. a가 list, bytearray, array.array 등 가변 시퀀스인 경우 a의 값이 변경됩니다.(a.extend(b)와 비슷합니다.) 그런데 a에 `__iadd__()` 메서드를 구현하지 않는 경우 a += b 표현식은 a = a + b가 되어 먼저 a + b를 평가하고, 객체를 새로 생성한 후 a에 할당됩니다. 즉, `__iadd__()` 메서드 구현 여부에 따라 a변수가 가리키는 객체의 정체성이 바뀔 수도 있습니다.  

일반적으로 가변 시퀀스는 `__iadd__()` 메서드를 구현해서 += 연산자가 기존 객체의 내용을 변경하게 만드는 것이 좋습니다. 불변 시퀀스의 경우 이 연산을 수행할 수 없습니다.  

`*=` 연산자도 동일하게 적용되는데, `__imul__()` 메서드를 통해서 구현됩니다.

```Python
>>> l = [1,2,3]
>>> id(l)
4448971016  # 초기 리스트의 ID
>>> l *= 2
>>> l
[1, 2, 3, 1, 2, 3]
>>> id(l)
4448971016  # 곱셈 연산을 수행한 후 새로운 항목이 추가된 리스트는 기존과 같은 객체이다.
>>> t = (1,2,3)
>>> id(t)
4448973448  # 초기 튜플 객체의 ID
>>> t *= 2
>>> id(t)
4448985160  # 곱셈 연산을 수행한 후 새로운 튜플 객체가 만들어졌다.
```
새로운 항목을 추가된 시퀀스 전체를 새로 만들어 타깃 변수에 저장하므로, 불변 시퀀스에 반복적으로 연결 연산을 수행하는 것은 비효율적입니다.

> str 객체의 작동 방식을 다릅니다. 실제로 루프 안에서 += 연산자를 이용해서 문자열을 만드는 작업을 자주 사용하므로 CPython은 이런 용법에 최적화되어 있습니다. str 객체는 메모리 안에 여분의 공간을 갖고 할당되므로 str 객체를 연결할 때 매번 전체 문자열을 다시 생성하지 않습니다.

### 2.6.1 += 복합 할당 퀴즈

```Python
>>> t = (1,2,[30,40])
>>> t[2] += [50,60]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> t
(1, 2, [30, 40, 50, 60])
```

위의 경우 t는 `(1, 2, [30, 40, 50, 60])`가 되면서, '튜플 객체의 항목 할당을 지원하지 않는다'라는 타입에러가 발생한다. 에러는 나지만 동작은 한다.

[온라인 파이썬 튜터](http://www.pythontutor.com)는 파이썬 동작을 시각적으로 보여줍니다. 파이썬 튜터를 통해 시각적으로 t 튜플의 초기 상태와 최종 상태를 볼 수 있습니다.

![]({{site.url}}/img/post/python/fluent/2.3.png)

s[a] += b 표현식에 대해 파이썬이 생성한 바이트코드를 보면 어떻게 이런 일이 발생했는지 알 수 있습니다.

```python
>>> import dis
>>> dis.dis('s[a] += b')
  1           0 LOAD_NAME                0 (s)
              3 LOAD_NAME                1 (a)
              6 DUP_TOP_TWO
              7 BINARY_SUBSCR            # s[a] 값을 스택의 꼭대기(TOS.Top Of Stack)에 놓는다.
              8 LOAD_NAME                2 (b)
             11 INPLACE_ADD              # TOS += b 연산을 수행한다. TOS가 가변 객체를 가리티면 이 연산은 성공한다.
             12 ROT_THREE
             13 STORE_SUBSCR             # TOS를 s[a]에 할당한다. s가 불변 객체면 연산은 실패한다.
             14 LOAD_CONST               0 (None)
             17 RETURN_VALUE
```
이 예는 상당히 드문 경우입니다. 이 코드에서 3가지 교훈을 얻을 수 있습니다.

- 가변 항목을 튜플에 넣는 것은 좋은 생각이 아니다.
- 복합 할당은 원자적인 연산이 아니다.(일부 연산이 수행된 후 예외가 발생한 것처럼)
- 파이썬 바이트코드를 살펴보는 것은 어렵지 않고, 내부에서 어떤 일이 발생하고 잇는지 살펴보는데 도움이 된다.


## 2.7 `list.sort()`와 `sorted()` 내장 함수
`list.sort()` 메서드는 사본을 만들지 않고 리스트 내부를 변경해서 정렬합니다. `sort()` 메서드는 타깃 객체를 변경하고 새로운 리스트를 생성하지 않았음을 알려주기 위해 None을 반환합니다. 이것은 파이썬 API의 중요한 관례입니다. 객체를 직접 변경하는 함수나 메서드는 객체가 변경되었고 새로운 객체가 생성되지 않았음을 호출자에 알려주기 위해 None을 반환해야 합니다. `random.shuffle()` 함수도 동일하게 동작합니다.

> Note. 객체를 직접 변경했다고 알려주기 위해 None을 반환하는 관례는 메서드를 연결해서 호출할 수 없다는 단점이 있다. 이와 반대로 str 객체의 메서드들처럼 새로운 객체를 반환하는 메서드는 플루언트 인터페이스 스타일로 메서드를 연결할 수 있다. 메서드 체이닝은 플루언트 인터페이스 형태를 구현하는 하나의 기법이다.

이와 반대로 `sorted()` 내장 함수는 새로운 리스트를 생성해서 반환합니다. `sorted()` 함수는 불변 시퀀스 및 제네레이터를 포함해서 반복 가능한 모든 객체를 인수로 받을 수 있습니다. 입력받은 반복 가능한 객체의 자료형과 무관하게 `sorted()` 함수는 언제나 새로 생성한 리스트를 반환합니다.  

`list.sort()` 메서드와 `sorted()` 함수 모두 선택적으로 두 개의 키워드를 인수로 받습니다.  

#### reverse
이 키워드가 참이면 비교 연산을 반대로 해서 내림차순으로 반환한다. 기본값은 False이다.
#### key
정렬에 사용할 키를 생성하기 위해 각 항목에 적용할 함수로 인수를 받는다. 예를 들어 문자열의 리스트를 정렬할 때 `key=str.lower`로 지정하면 대소문자를 구분하지 않고 정렬하며, `key=len`으로 지정하면 문자열의 길이에 따라 문자열을 정렬한다. 키를 지정하지 않으면 항목 자체를 비교한다.

> tip. 선택적 키워드 매개변쉬는 `min(), max()` 내장 함수 및 'itertools.groupby(), heapq.nlargest()' 등의 표준 라이브러리 함수와 함께 사용할 수 있다.

```python
>>> fruits = ['grape', 'raspberry', 'apple', 'banana']
# 알파벳순으로 정렬된 문자열들을 담은 새로운 리스트를 생성한다.
>>> sorted(fruits)
['apple', 'banana', 'grape', 'raspberry']
# 원래 리스트를 보면 바뀌지 않았음을 알 수 있다.
>>> fruits
['grape', 'raspberry', 'apple', 'banana']
# 알파벳 역순으로 정렬한다.
>>> sorted(fruits, reverse=True)
['raspberry', 'grape', 'banana', 'apple']
# 문자열의 길이에 따라 정렬되어 새로 생성된 리스트. 정렬 알고리즘이 안정적이며 길이가 5인 'grape'와 'apple'은 원래 순서가 유지되어 있다.
>>> sorted(fruits, key=len)
['grape', 'apple', 'banana', 'raspberry']
# 문자열 길이의 역순으로 정렬된 문자열의 리스트. 안정적인 정렬 알고리즘이므로 'grape'가 여전히 'apple' 앞에 나옴에 따라 정확한 역순이 아니다.
>>> sorted(fruits, key=len, reverse=True)
['raspberry', 'banana', 'grape', 'apple']
# 여기까지 원래 fruits 리스트의 순서는 바뀌지 않았다.
>>> fruits
['grape', 'raspberry', 'apple', 'banana']
# sort() 메서드는 원래 객체의 내용을 변경하고 None을 반환한다.(콘솔은 None을 반환할 경우 값을 보여주지 않는다.)
>>> fruits.sort()
# 이제 fruits 리스트가 정렬되었다.
>>> fruits
['apple', 'banana', 'grape', 'raspberry']
# 이 예는 파이썬에서 정렬 알고리즘으로 사용하는 팀정렬(Timsort)이 안정적인지(즉, 비교해서 동일한 항목들이 상대적인 순서르 유지하는지) 보여주는데도 사용된다.
```
일단 시퀀스를 정렬한 후에는 아주 효율적으로 검색할 수 있습니다. 다행히 파이썬 표준 라이브러리의 bisect 모듈에서 이미 표준 이진 검색 알고리즘을 제공하고 있습니다.

## 2.8 정렬된 시퀀스를 bisect로 관리하기
bisect 모듈은 `bisect()`와 `insort()` 함수를 제공합니다. `bisect()`는 이진 검색 알고리즘을 이용해서 검색하고, `insort()`는 정렬된 시퀀스 안에 항목을 삽입합니다.

### 2.8.1 `bisect()`로 검색하기
`bisect(haystack, needle)`은 정렬된 시퀀스인 haystack 안에서 오름차순 정렬 상태를 유지한 채로 needle을 추가할 수 있는 위치를 찾아냅니다. `bisect(haystack, needle)`의 결과값을 인덱스로 사용해서 `haystack.insert(index, needle)`을 호출하면 needle을 추가할 수 있지만, `insort()`함수는 이 두 과정을 더 빨리 처리합니다.

> tip. bisect 모듈을 사용하지만 이런 함수들을 따로 사용하는 것보다 쉽게 정렬할 수 있는 SortedCollection 비법도 있다.

```python
# 정렬된 시퀀스에서 항목을 추가할 위치를 나타내는 bisect
import bisect
import sys

HAYSTACK = [1, 4, 5, 6, 8, 12, 15, 20, 21, 23, 23, 26, 29, 30]
NEEDLES = [0, 1, 2, 5, 8, 10, 22, 23, 29, 30, 31]

ROW_FMT = '{0:2d} @ {1:2d}    {2}{0:<2d}'

def demo(bisect_fn):
    for needle in reversed(NEEDLES):
        # 삽입 위치를 찾아내기 위해 선택한 bisect 함수를 만듭니다.
        position = bisect_fn(HAYSTACK, needle)
        # 간격(offset)에 비례해서 수직 막대 패턴을 만듭니다.
        offset = position * '  |'
        # needle과 삽입 위치를 보여주는 포맷된 행을 출력합니다.
        print(ROW_FMT.format(needle, position, offset))

if __name__ == '__main__':
    # 마지막 명령행 인수에 따라 사용할 bisect 함수를 선택합니다.
    if sys.argv[-1] == 'left':
        bisect_fn = bisect.bisect_left
    else:
        bisect_fn = bisect.bisect
    # 선택된 함수명을 헤더에 출력합니다.
    print('DEMO:', bisect_fn.__name__)
    print('haystack ->', ' '.join('%2d' % n for n in HAYSTACK))
    demo(bisect_fn)
```

```
# bisect를 이용해서 위 코드를 실행한 결과. 각 행은 needle @ position 형태로 시작하며 needle을 삽입할 haystack 위치에 needle 값을 한 번 더 보여줍니다.

fluent(master*) » python 2_17.py
DEMO: bisect
haystack ->  1  4  5  6  8 12 15 20 21 23 23 26 29 30
31 @ 14      |  |  |  |  |  |  |  |  |  |  |  |  |  |31
30 @ 14      |  |  |  |  |  |  |  |  |  |  |  |  |  |30
29 @ 13      |  |  |  |  |  |  |  |  |  |  |  |  |29
23 @ 11      |  |  |  |  |  |  |  |  |  |  |23
22 @  9      |  |  |  |  |  |  |  |  |22
10 @  5      |  |  |  |  |10
 8 @  5      |  |  |  |  |8
 5 @  3      |  |  |5
 2 @  1      |2
 1 @  1      |1
 0 @  0    0
```

bisect의 행동은 두 가지 방식으로 조절할 수 있습니다.  

1. 선택 인수인 lo와 hi를 사용하면 삽입할 때 검색할 시퀀스 영역을 좁힐 수 있습니다. lo의 기본값은 0, hi의 기본값은 시퀀스의 len()입니다.

2. bisect는 실제로 bisect_right() 함수의 별명이며, 이 함수의 자매 함수로 bisect_left()가 있습니다. 이 두 함수는 리스트 안의 항목이 needle과 값이 같을 때만 차이가 납니다. bisect_right()는 기존 항목 바로 뒤를 삽입 위치로 반환하며, bisect_left()는 기존 항목 위치를 삽입 위치로 반환하므로 기존 항목 바로 앞에 삽입됩니다. int와 같은 단순한 자료형의 경우엔 차이가 없지만, 객체를 담고 있는 시퀀스 안에서는 동일하다고 판단되지만 서로 다른 객체가 들어 있으므로 이 두 함수 간에 약간의 차이가 발생합니다. 예를 들어 1과 1.0은 다르지만 1 == 1.0음 참입니다.

```
# bisect_left를 사용해서 실행한 결과. 앞의 결과와 비교해보면 1,8, 23, 29, 30을 haystack 안의 동일 숫자 왼쪽에 삽입하는 것을 알 수 있다.

fluent(master*) » python 2_17.py left
DEMO: bisect_left
haystack ->  1  4  5  6  8 12 15 20 21 23 23 26 29 30
31 @ 14      |  |  |  |  |  |  |  |  |  |  |  |  |  |31
30 @ 13      |  |  |  |  |  |  |  |  |  |  |  |  |30
29 @ 12      |  |  |  |  |  |  |  |  |  |  |  |29
23 @  9      |  |  |  |  |  |  |  |  |23
22 @  9      |  |  |  |  |  |  |  |  |22
10 @  5      |  |  |  |  |10
 8 @  4      |  |  |  |8
 5 @  2      |  |5
 2 @  1      |2
 1 @  0    1
 0 @  0    0
 ```

 bisect를 사용하면 수치형 값으로 테이블을 참조할 수 있으므로, 아래 코드처럼 시험 점수를 등급 문자로 변환할 수 있습니다.

 ```python
 >>> def grade(score, breakpoints = [60, 70, 80, 90], grades='FDCBA'):
...     i = bisect.bisect(breakpoints, score)
...     return grades[i]
...

>>> [grade(score) for score in [33, 99, 77, 70, 89, 90, 100]]
['F', 'A', 'C', 'C', 'B', 'A', 'A']
```

이 함수들은 검색뿐만 아니라 정렬된 시퀀스 안에 항목을 삽입할 때도 사용됩니다.

### 2.8.2 `bisect.insort()`로 삽입하기
정렬은 값비싼 연산이므로 시퀀스를 일단 정렬한 후에는 정렬 상태를 유지하는 것이 좋습니다. 그래서 `bisect.insort()` 함수가 만들어졌습니다.  

`insort(seq, item)`은 seq를 오름차순으로 유지한 채로 item을 seq에 삽입합니다.

```python
# 시퀀스를 항상 정렬된 상태로 유지하는 insort()
import bisect
import random

SIZE = 7

random.seed(1729)

my_list = []
for i in range(SIZE):
    new_item = random.randrange(SIZE*2)
    bisect.insort(my_list, new_item)
    print('%2d ->' % new_item, my_list)
```

```
fluent(master*) » python 2_19.py
10 -> [10]
 0 -> [0, 10]
 6 -> [0, 6, 10]
 8 -> [0, 6, 8, 10]
 7 -> [0, 6, 7, 8, 10]
 2 -> [0, 2, 6, 7, 8, 10]
10 -> [0, 2, 6, 7, 8, 10, 10]
```
bisect 함수와 마찬가지로 insort 함수도 선택적으로 lo와 hi 인수를 받아 시퀀스 안에서 검색할 범위르 제한합니다. 그리고 삽입 위치를 검색하기 위해 bisect_left() 함수를 사용하는 insort_left() 함수도 있습니다.  

지금까지 다룬 내용은 리스트나 튜플뿐만 아니라 시퀀스에도 적용됩니다. 많은 프로그래머들이 리스트형을 남용하지만, 숫자들로 구성된 리스트를 다룬다면 배열을 사용하는 것이 좋습니다.

## 2.9 리스트가 답이 아닐 때
리스트형은 융통성 있고 사용하기 편하지만, 세부 요구사항에 따라 더 나은 자료형도 있습니다. 예를 들어 실수를 천만 개를 저장해야 할 때는 배열이 훨씬 효율적입니다. 배열은 모든 기능을 갖춘 float 객체 대신 C 언어의 배열과 마찬가지로 기계가 사용하는 형태로 표현된 바이트 값만 저장하기 때문입니다. 그리고 리스트의 양쪽 끝에 항목을 계속 추가하거나 삭제하면서 FIFO나  LIFO 데이터 구조를 표현할 때는 덱(deque. 양쪽을 사용하는 큐)가 더 빠릅니다.

> tip. 어떤 항목이 들어 있는지 검사하는데 항목수가 아주 많은 경우에는 set형이 더 나을 수 있다. set 형은 항목이 들어 있는지 검사하는 과정이 최적화되어 있다.

### 2.9.1 배열
리스트 안에 숫자만 들어 있다면 배열(array.array)이 리스트보다 훨씬 효율적입니다. 배열은 `pop(), insert(), extend()`등을 포함해서 가변 시퀀스가 제공하는 모든 연산을 지원하며, 빠르게 파일을 저장하고 읽어올 수 있는 `frombytes(), tofile()`메서드도 추가로 제공합니다.  

파이썬 배열은 C 배열만큼 가볍습니다. 배열을 생성할 때는 배열에 저장되는 각 항목의 C 기반 형을 결정하는 문자인 타입코드(typecode)를 지정합니다. 숫자가 아주 많이 들어 있는 시퀀스의 경우 배열에 저장하면 메모리가 많이 절약됩니다. 그리고 파이썬은 배열형에 맞지 않는 숫자를 저장할 수 없게 합니다.

```python
# 커다란 실수 배열의 생성, 저장, 로딩

>>> from array import array
>>> from random import random
# 반복 가능한 객체에서 배밀도 실수(타입코드 'd')의 배열을 생성한다.
>>> floats = array('d', (random() for i in range(10**7)))
# 배열의 마지막 숫자를 조사한다.
>>> floats[-1]
0.48593781287850435
>>> fp = open('floats.bin', 'wb')
# 배열을 이진 파일에 저장한다.
>>> floats.tofile(fp)
>>> fp.close()
# 비어 있는 배밀도 실수 배열을 생성한다.
>>> floats2 = array('d')
>>> fp = open('floats.bin', 'rb')
# 이진 파일에서 천만 개의 숫자를 읽어온다.
>>> floats2.fromfile(fp, 10**7)
>>> fp.close()
# 배열의 마지막 숫자를 조사한다.
>>> floats2[-1]
0.48593781287850435
# 배열의 내용이 일치하는지 확인한다.
>>> floats2 == floats
True
```
이 코드에서처럼 `array.tofile(), array.fromfile()` 메서드는 사용하기 쉽습니다. 실행 속도 또한 빠릅니다. `array.fromfile()`메서드가 `array.tofile()`메서드로 생성한 이진 파일에서 배밀도 실수 천만 개를 로드하는데 0.1초 정도의 시간이 걸렸습니다. 이 속도는 `float()` 내장 함수를 이용해서 파싱하면서 텍스트 파일에서 숫자를 읽어오는 것보다 거의 60배나 빠릅니다. `array.tofile()` 메서드로 저장하는 것은 각 행마다 실수 하나씩 텍스트 파일에 저장하는 것보다 약 7배 빠릅니다. 게다가 배밀도 실수 천만 개를 저장한 이진 파일의 크기는 80,000,000바이트(배밀도 실수 하나는 8바이트씩이고, 오버헤드가 전혀 없다)인 반면, 동일한 데이터를 저장한 텍스트 파일의 크기는 181,515,739바이트입니다.  

> tip. 객체를 직렬화하는 `pickle` 모듈도 숫자 데이터를 빠르고 융통성 있게 저장할 수 있다. `pickle.dump()`메서드는 실수 배열을 `array.tofile()`메서드만큼 빠르게 저장할 뿐만 아니라 복소수, 내포된 컬렉션, (저장하기 까다롭게 구현한 경우가 아니라면) 심지어 사용자 정의 객체 등 거의 모든 내장 자료형을 처리할 수 있다.

래스터 이미지(raster images)처럼 이진 데이터를 표현하는 숫자 배열을 위해 파이썬에서는 bytes와 bytearray 형을 제공합니다.

#### 리스트와 배열에서 볼 수 있는 메서드와 속성

메서드 | 리스트 | 배열 | 설명
---|---|---|---
`s.__add__(s2)`|√|√|s + s2 - 연결한다.
`s.__iadd__(s2)`|√|√|s += s2 - 연결하고 s에 할당한다.
`s.append(e)`|√|√|마지막 요소 뒤에 e를 추가한다.
`s.byteswap()`| |√|엔디언 변환을 위해 배열 안의 모든 요소의 바이트 순서를 바꾼다.
`s.clear()`|√| |모든 항목을 삭제한다.
`s.__contains__(e)`|√|√|e in s
`s.copy()`|√| |리스트를 얕게 복사한다.
`s.__copy__()`| |√|copy.copy() 메서드를 지원한다.
`s.count(e)`|√| |s 안에 e 요소가 발생한 횟수를 반환한다.
`s.__deepcopy__()`| |√|copy.deepcopy()를 최적화해서 지원한다.
`s.__delitem__(p)`|√|√|p 위치의 요소를 삭제한다.
`s.extend(it)`|√|√|반복형 it에서 요소들을 가져와서 추가한다.

`s.frombytes(b)`| |√|패킹된 기계값으로 해석한 바이트 시퀀스에서 요소를 가져와서 추가한다.
`s.fromfile(f, n)`| |√|패킹된 기계값으로 해석한 이진 파일 f에서 n개의 항목을 가져와서 추가한다.
`s.fromlist(l)`| |√|리스트 l의 요소를 추가한다. TypeError가 한번이라도 발생하면 아무 것도 추가하지 않는다.
`s.__getitem__(p)`|√|√|s[p] - p 위치의 항목을 가져온다.
`s.index(e)`|√|√|e가 처음 나타나는 위치르 찾아낸다.
`s.insert(p, e)`|√|√|p 위치에 있는 항목 앞에 e 요소를 추가한다.
`s.itemsize`| |√|각 배열 항목의 바이트 단위 크기
`s.__iter__()`|√|√|반복자를 가져온다.
`s.__len__()`|√|√|len(s) - 항목 수를 반환한다.
`s.__mul__(n)`|√|√|s * n - n회 반복해서 연결한다.
`s.__imul__(n)`|√|√|s \*= n - n회 반복해서 연결한 후 s에 저장한다.
`s.__rmul__(n)`|√|√|n * s - 역순 반복 연결 메서드
`s.pop([p])`|√|√|p 위치 혹은 제일 마지막 항목을 제거하고 반환한다.
`s.remove(e)`|√|√|값이 e와 일치하는 항목을 제거한다.
`s.reverse()`|√|√|항목들의 순서를 역으로 나열해서 다시 s에 저장한다.
`s.__reversed__()`|√| |마지막부터 처음까지 반복하는 반복자를 가져온다.
`s.__setitem__(p, e)`|√|√|s[p] = e - p 위치에 e 요소를 저장하고, 기존 값을 덮어쓴다.
`s.sort([key], [reverse])`|√| |선택적인 키워드 key와 reverse에 따라 항목을 정렬하고 s에 저장한다.
`s.tobytes()`| |√|bytes 객체에 패킹된 기계값으로 항목을 반환한다.
`s.tofile(f)`| |√|이진 파일 f에 패킹된 기계값으로 항목을 저장한다.
`s.tolist()`| |√|항목을 수치형 객체로 변환해서 넣은 리스트를 반환한다.
`s.typecode`| |√|항목의 C 형을 나타내는 한 글자짜리 문자열

### 2.9.2 메모리 뷰
메모리 뷰(memoryview) 내장 클래스는 공유 메모리 시퀀스형으로서 bytes를 복사하지 않고 배열의 슬라이스를 다룰 수 있게 해줍니다. 이 클레스는 NumPy 라이브러리에서 영감을 받아 만들어졌습니다. NumPy 개발자인 트래비스는 '언제 메모리 뷰를 사용해야 하는가?'라는 질문에 **"메모리 뷰는 본질적으로 (math를 포함하지 않은) 파이썬 자체에 들어 있는 NumPy 배열 구조체를 일반화한 것이다. 메모리 뷰는 PIL 이미지, SQLlite 데이터베이스, NumPy 배열 등 데이터 구조체를 복사하지 않고 메모리를 공유할 수 있게 해준다. 데이터 셋이 커지는 경우 이것이 아주 중요한 기법이다."** 라고 답했습니다.  

array 모듈과 비슷한 표기법을 사용하는 `memoryview.cast()`메서드는 바이트를 이동시키지 않고 C 언어의 형변환 연산자처럼 여러 바이트로 된 데이터를 읽거나 쓰는 방식을 바꿀 수 있게 해줍니다. `memoryview.cast()`는 또 다른 memoryview 객체를 반환하며 언제나 동일한 메모리를 공유합니다.  

```python
# 배열 항목 값의 바이트 중 하나를 변경하기 (16비트 정수 배열)
>>> import array
>>> numbers = array.array('h', [-2, -1, 0, 1, 2])
# 짧은 정수(타입코드 'h') 다섯 개가 있는 배열에서 memoryview 객체를 만든다.
>>> memv = memoryview(numbers)
>>> len(memv)
5
# memv도 배열 안에 있는 5개의 항목이 동일하게 본다.
>>> memv[0]
-2
# memv 요소를 unsigned char(타입코드 'B')로 형변환한 memv_oct를 생성한다.
>>> memv_oct = memv.cast('B')
# 값을 조사하기 위해 memv_oct 안의 요소를 리스트로 만든다.
>>> memv_oct.tolist()
[254, 255, 255, 255, 0, 0, 1, 0, 2, 0]
# 5번 인덱스 항목에 4를 할당한다.
>>> memv_oct[5] = 4
# 2 바이트 unsigned int의 최상위 바이트에서 4는 1024에 해당한다.
>>> numbers
array('h', [-2, -1, 1024, 1, 2])
```
배열 안에서 고급 수치 처리 기법을 적용하려면 NumPy, SciPy 라이브러리를 사용해야 하므로, 먼저 이 라이브러리에 대해 알아야 합니다.

### 2.9.3 NumPy와 SciPy
NumPy는 숫자뿐만 아니라 사용자 정의 레코드도 저장할 수 있는 다차원 동형 배열 및 행렬을 구현하고 요소 단위에서 효율적으로 연산할 수 있게 해줍니다.  

SciPy는 NumPy를 기반으로 작성된 라이브러리로서, 선형대수학, 수치해석, 통계학에 쓰이는 과학 계산 알고리즘을 제공합니다. SciPy는 Netlib 리포지토리가 제공하는 C 및 포트란 코드 기반을 활용함으로써 빠르고 신뢰성이 높습니다. 따라서 SciPy는 C와 포트란에서 최적화되고 업계에서 입증된 수치 계산 함수를 대화형 고급 파이썬 API를 통해 과학자들에게 제공합니다.  

```python
# numpy.ndarray에서 행과 열을 이용한 기본 연산
>>> import numpy
# 0에서 11까지의 정수를 담은 numpy.ndarray를 생성하고 확인한다.
>>> a = numpy.arange(12)
>>> a
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
>>> type(a)
<class 'numpy.ndarray'>
# 배열의 차원을 살펴본다. 이 배열은 12갸의 요소를 가진 1차원 배열이다.
>>> a.shape
(12,)
# 배열에 차원을 추가해서 형태를 변경한 후 결과를 확인한다.
>>> a.shape = 3, 4
>>> a
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
# 2번 행을 가져온다.
>>> a[2]
array([ 8,  9, 10, 11])
# (2, 1)에 있는 요소를 가져온다.
>>> a[2, 1]
9
# 1번 열을 가져온다.
>>> a[:, 1]
array([1, 5, 9])
# 행렬을 전치(행과 열을 맞바꿈)시켜 새로운 배열을 만든다.
>>> a.transpose()
array([[ 0,  4,  8],
       [ 1,  5,  9],
       [ 2,  6, 10],
       [ 3,  7, 11]])
```

NumPy는 numpy.ndarray의 모든 요소를 저장, 로딩, 처리하는 고급 연산도 지원합니다.

```python
import numpy
# 텍스트 파일에서 천만 개의 실수를 읽어온다.
floats = numpy.loadtxt('floats-10M-lines.txt')
# 시퀀스 슬라이싱 표기법을 이용해서 마지막 숫자 3개를 확인한다.
print(floats[-3:])
# floats 배열에 들어 잇는 모든 요소에서 0.5를 곱하고 마지막 3개를 다시 확인한다.
floats *= .5
print(floats[-3:])
# 고밀도 성능 측정 타이머를 임포트한다.
from time import perf_counter as pc
# 모든 요소를 3으로 나눈다. 실수형 천만 개를 처리하는 데 40밀리초가 채 걸리지 않는다.
t0 = pc(); floats /= 3; print(pc() - t0)
# 배열을 .npy 이진 파일에 저장한다.
numpy.save('floats-10M', floats)
# 메모리 매핑된 파일에서 데이터를 가져와서 다른 배열에 저장한다. 전체 배열이 메모리에 완전히 들어가지 않더라도 배열을 효율적으로 슬라이싱 처리할 수 있게 해준다.
floats2 = numpy.load('floats-10M.npy', 'r+')
floats2 *= 6
# 모든 요소에 6을 곱한 후 마지막 요소 3개를 확인한다.
print(floats[-3:])
```
NumPy와 SciPy는 Pandas와 Blaze 데티어 분석 라이브러리 기반입니다. 이 라이브러리들은 비수치형 데이터를 담은 효율적인 배열형 뿐만 아니라 .csv, .xls, SQL 덤프, HDF5 등 다양한 포맷과 호환되는 임포드/익스포트 함수도 제공합니다.
