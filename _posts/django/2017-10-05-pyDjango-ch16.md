---
layout: post
section-type: post
title: pyDjango - chap16. 장고 핵심 기능 - Template
category: django
tags: [ 'django' ]
---
템플릿 문법은 그리 어려운 편이 아닙니다. 오히려 개발자가 작성한 템플릿 파일을 처리하는 내부 과정이 복잡한 편입니다. 장고 내부에서는 템플릿 엔진이 이런 템플릿의 복잡한 과정을 처리하고 있습니다.  

개발자가 스스로 정의하는 커스텀 템플릿 태그를 작성하고자 한다면 이런 템플릿의 내부 처리 과정을 이해할 필요가 있습니다.  

그리고 템플릿 파일을 코딩하는 경우에, 정적 파일을 다루는 경우가 많이 발생합니다. 정적 파일을 처리하는 staticfiles 애플리케이션에 대해서도 추가적으로 다룹니다.

## 16.1 템플릿 설정 항목
장고의 코어 템플릿 엔진을 DTL(Django Template Lauguage)이라고 합니다. 그리고 장고는 DTL 이외에도 Jinja 템플릿 엔징을 기본적으로 지원하고 있으며, 다른 템플릿 엔진도 설치하면 사용이 가능합니다.  

템플릿은 어떤 템플릿 엔진을 사용할 것인지 지정하는 것부터 시작합니다. 이느 설정 파일에서 이뤄지는데, 템플릿 엔진과 그 엔진에 적용할 옵션들을 지정합니다. 다음은 프로젝트 생성시 startproject 명령에 의해 작성된 settings.py 중에서 템플릿 설정 부분을 보여줍니다.

```python
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
```

**BACKEND** 항목은 사용할 템플릿 엔진을 지정합니다. 장고에서는 다음 2가지 템플릿 엔진을 기본적으로 지원하며, 필요하다면 장고의 템플릿 API를 이용해서 만든 서드 파티 엔진을 지정하는 것도 가능합니다.

- django.template.backends.django.DjangoTemplates : 장고의 자체 템플릿 엔진
- django.template.backends.jinja2.Jinja2 : 파이썬 언어의 대표적인 템플릿 엔진입니다. 시스템에 Jinja2 라이브러리만 설치되어 있으면, 장고가 제공하는 설정이나 API 등을 사용할 수 있습니다.

**DIRS** 항목은 프로젝트 템플릿 파일이 위치한 디렉터리를 지정합니다. 다음에 나오는 APP_DIRS 항목과 관련된 애플리케이션 템플릿 디렉터리보다 우선해 파일을 찾습니다. 디폴트는 빈 리스트입니다.

본문 예제에서는 다음처럼 프로젝트 디렉터리를 지정해 사용했습니다.

```python
'DIRS': [os.path.join(BASE_DIR, 'templates')],
```

**APP_DIRS** 항목은 템플릿 파일을 찾을 때, 애플리케이션 내의 템플릿 디렉터리에서도 찾을지 여부를 지정합니다. 디폴트는 False이지만 startproject 명령에 의해 settings.py 파일이 만들어 질때 True로 설정됩니다.  

**OPTIONS** 항목은 템플릿 엔진에 따라 해당하는 옵션 항목들을 설정합니다. 장고 템플릿 엔진을 사용하는 경우는 다음과 같은 옵션 항목이 있습니다.

- 'context_processors' : 웹 요청에 들어 있는 파라미터들(request)을 인자로 받아서 컨텍스트 데이터로 사용될 dict을 만들어주는 호출 가능한 객체(callable)를 지정합니다. 보통은 함수로 정의되는데, 이 함수들이 반환하는 dict는 최종 컨텍스트 데이터를 만들때  추가됩니다. 디폴트는 빈 리스트입니다.
- 'debug' : 템플릿 디버그 모드를 설정합니다. True로 설정하면, 템플릿 렌더링 과정에서 에러가 발생하면 템플릿 파일 내에서 에러가 발생한 줄을 다른 색으로 표시해줍니다. 디폴트는 다른 설정 항목인 DEBUG 항목의 값을 따릅니다.
- 'loaders' : 템플릿 로더 클래스를 지정합니다. 로더는 템플릿 파일을 찾아서 메모리로 로딩하는 역할을 수행합니다.
- 'string_if_invalid' : 템플릿 변수가 잘못된 경우, 대신 사용할 문자열을 지정합니다. 디폴트는 공백 문자열입니다.
- 'file_charset' : 템플릿 파일을 읽어 디코딩할 때 사용하는 문자셋을 지정합니다. 디폴트는 다른 설정 항목인 FILE_CHARSET 항목의 값을 따릅니다.

## 16.2 템플릿 내부 처리 과정
장고 내부에서 동작하는 템플릿 처리 과정은 크게 3가지로 나눌 수 있습니다.
1. 템플릿 설정에 따라 Engine 객체를 생성합니다.
2. 템플릿 파일 로딩 및 Template 객체를 생성합니다.
3. 렌더링을 실시해, 최종 HTML 텍스트 파일을 생성합니다.

각 순서에 따라 세부 사항을 살펴봅니다.

### 1. 사용할 템플릿 엔진 및 관련 옵션들을 결정해 Engine 객체를 생성합니다.
Engine 객체를 생성할 때 사용하는 인자듫이 바로 TEMPLATES 설정 항목에 지정된 값들입니다. 이중에서 loaders 옵션 항목은 다음 2번에서 사용되고, context_processors 옵션 항목은 다음 3번에서 사용됩니다.  
이 단계에서 Engine 객체뿐 아니라 Engine 객체에 소속된 Loader 객체도 같이 생성됩니다. 그 다음에 Loader 객체가 동작해 다음 단계에서 설명하는 템플릿 파일 검색 작업이 수행됩니다.

### 2. Engine 객체에 지정된 템플릿 로더(loader)는 하나 또는 여러 개로 나눠진 템플릿 파일들을 찾고 그 내용, 즉 템플릿 코드들을 하나로 모아서 Template 객체를 생성합니다.  
설정 옵션 항목에 loaders가 지정되지 않은 경우, 디폴트 로더로 다음 2개의 클래스를 사용합니다. 그 밖에 캐시 로더 또는 개발자가 만든 커스텀 로더 등을 사용하는 것도 가능하지만, 특별한 경우가 아니라면 디폴트 로더 2개를 변경 없이 사용하는 것이 보통입니다.

- django.template.loaders.filesystem.Loader : 템플릿 파일을 찾기 위해, 설정 항목 TEMPLATES의 DIRS 항목에 지정된 디렉터리를 검색합니다. DIRS 항목이 비어있으면, 로더는 검색을 수행하지 않습니다.
- django.template.loaders.app_directories.Loader : 템플릿 파이을 찾기 위해, 각 애플리케이션 디렉터리 하위에 있는 templates/ 디렉터리를 검색합니다. 애플리케이션은 INSTALL_APPS 설정 항목에 등록된 앱들이 대상입니다. 이 로더는 TEMPLATES 설정 항목의 APPS_DIR 항목이 True인 경우에만 동작합니다.

한 가지 유의할 점은, 템플릿 파일을 찾는 순서입니다. loaders 디폴트 설정에 filesystem.Loader가 app_directories.Loader보다 먼저 나오므로, DIRS 항목에 지정된 디렉터리를 가장 먼저 찾게 됩니다. 그 후에 INSTALL_APPS 항목에 지정된 앱의 순서에 따라 각 앱의 templates/ 디렉터리를 검색합니다.  
{% raw %}
이 단계에서 Loader 객체는 템플릿 파일들을 찾은 후에 Template 객체를 생성합니다. 이때 찾은 템플릿 파일들의 템플릿 코드들을 하나로 모아서, Template 객체 생성자에 전달해줍니다. 템플릿 파일을 찾은 결과는 보통 하나의 파일이지만, {% extends %} 또는 {% include %} 태그가 있는 경우는 여러 개의 파일을 찾게 됩니다. 이 단계에서 생성된 Template 객체는 다음 단계에서 사용됩니다.

### 3. Template 객체의 render() 메소드를 호출해 컨텍스트 데이터와 요청(request) 데이터들을 템플릿 코드에 대입하고 렌더링 결과로 최종 텍스트 파일을 만듭니다.  
렌터링을 위해서는 템플릿 코드와 컨텍스트 데이터가 필요합니다. 템플릿 코드는 앞 단계에서 만들어지고, 컨텍스트 데이터는 뷰 함수에서 만들어져 템플릿 시스템으로 전달됩니다. 한 가지 더 있는데 웹 요청 객체인 HttpRequest 객체에 들어 있는 데이터도 컨텍스트 데이터로 사용됩니다.  

뷰에서 전달된 데이터만으로 최종 컨텍스트 데이터를 만들 때는 Context 객체를 사용하고, HttpRequest 데이터를 포함해 최종 컨텍스트 데이터를 만들 때는 RequestContext 객체를 사용합니다.  

HttpRequest 객체에는 다양한 데이터가 포함되어 있습니다. 이 중에서 어떤 데이터를 컨텍스트 데이터로 사용할지를 결정하는 것이, 템플릿 엔진 설정 항목의 context_processors 옵션 항목입니다. 처음 startproject 명령으로 프로젝트 생성 시에는 다음과 같은 4가지 컨텍스트 프로세서가 지정됩니다.

- django.template.context_processors.debug : 현재 실행 환경의 DEBUG 모드를 지칭하는 debug 변수 및 웹 요청 처리 과정에 사용된 SQL 쿼리 정보를 담은 sql_queries 변수, 2가지가 최종 컨텍스트 데이터에 추가됩니다.
- django.template.context_processors.request : 현 요청의 HttpRequest를 지칭하는 request 변수가 최종 컨텍스트 데이터에 추가됩니다.
- django.contrib.auth.context_processors.auth : 로그인 사용자를 지칭하는 user 변수 및 그 사용자의 권한을 지칭하는 perms 변수가 최종 컨텍스트 데이터에 추가됩니다.
- django.contrib.messages.context_processors.messages : 메시지 리스트를 지칭하는 messages 변수와 메시지 레벨을 지칭하는 DEFAULT_MESSAGE_LEVELS 변수가 최종 컨텍스트 데이터에 추가됩니다.

RequestContext 객체가 생성될 때는, 위 4개 컨텍스트 프로세서 이외에도 CSRF(Cross Site Request Forgery) 보안 공격을 방지하기 위한 다음 프로세서가 자동으로 추가됩니다.

- django.template.context_processors.csrf : {% csrf_token %} 템플릿 태그 처리에 필요한 토큰이 최종 컨텍스트 데이터에 추가됩니다.

템플릿 코드에 컨텍스트 데이터를 대입해 처리하는 렌더링 과정을 다음 섹션에서 다룹니다.
{% endraw %}
## 16.3 템플릿 렌더링 실습
