---
layout: post
section-type: post
title: pyDjango - chap15. 장고 핵심 기능 - View
category: django
tags: [ 'django' ]
---
뷰는 웹 요청을 받아서 최종 응답 데이터를 웹 클라이언트로 반환하는 함수(정확히는 호출 가능한 객체, callable)입니다. 웹 요청을 분석하고 데이터베이스 처리 등 필요한 로직을 수행하고, 템플릿을 통해 화면에 표시할 데이터를 만들어서, 최종 데이터를 웹 클라이언트에 응답해줍니다.  

장고에서는 뷰를 함수로도 작성할 수 있고, 클래스로도 작성할 수 있습니다. 간단한 로직인 경우 함수형 뷰로 신속하게 개발하는 것도 하나의 방법이지만, 로직이 복잡해지고 프로젝트가 커질수록 클래스형 뷰의 장점이 효과를 발휘합니다. 또한 장고는 잘 준비된 클래스형 제네릭 뷰를 제공하고 있습니다.  

이번 챕터에서는 클래스형 뷰의 핵심 원리들을 설명합니다. 상속의 중요 기능인 오버라이딩, 클래스형 뷰의 내부 처리 과정을 이해할 수 있는 Method Flowchart, 다중 상속에 필요한 MRO 등을 설명합니다. 추가로 뷰 작성시 자주 사용하는 페이징 처리와 단축 함수를 다룹니다.

## 15.1 제네릭 뷰 선택
클래스형 뷰를 작성하기 위해서는 클래스형 제네릭 뷰를 상속받아서 필요한 속성과 메소드를 오버라이딩하는 작업이 필요합니다. 이를 위해서는 사용하려는 로직에 가장 알맞는 제네릭 뷰가 무엇인지 선택할 수 있어야 합니다.
제네릭 뷰를 선택한 다음에는 그 제네릭 뷰에서 어떤 속성과 메소드를 오버라이딩할지 판단해야 합니다.

## 15.1.1 제네릭 뷰 요약
장고는 웹 프로그래밍 개발시 공통적으로 사용하는 로직을 미리 개발해 놓고 기본 클래스로 제공하고 있습니다. 개발자는 자신의 로직에 맞는 뷰를 잘 선택해서 사용하면 됩니다. 그래서 적절한 제네릭 뷰를 선택할 수 있도록, 제네릭 뷰의 종류와 각 제네릭 뷰의 역할을 이해하는 것이 중요합니다.  

제네릭 뷰 분류 | 제네릭 뷰 이름 | 뷰의 기능 또는 역할
---|---|---
Base View | View <br> TemplateView <br> RedirectView | 가장 기본이 되는 최상위 제네릭 뷰입니다. 다른 모든 제네릭 뷰들은 View의 하위 클래스입니다. <br> 템플릿이 주어지면 해당 템플릿을 렌더링해줍니다. <br> URL이 주어지면 해당 URL로 리다리렉트 시켜줍니다.
Generic Display View | DetailView <br> ListView | 객체 하나에 대한 생세한 정보를 보여줍니다. <br> 조건에 맞는 여러 개의 객체를 보여줍니다.
Generic Edit View | FormView <br> CreateView <br> UpdateView <br> DeleteView | 폼이 주어지면 해당 폼을 보여줍니다. <br> 객체를 생성하는 폼을 보여줍니다. <br> 기존 객체를 수정하는 폼을 보여줍니다. <br> 기존 객체를 삭제하는 폼을 보여줍니다.
Generic Date View | YearArchiveView <br> MonthArchiveView <br> WeekArchiveView <br> DayArchiveView <br> TodayArchiveView <br> DateDetailView | 년도가 주어지면 그 년도에 해당하는 객체들을 보여줍니다. <br> 연, 월이 주어지면 그에 해당하는 객체들을 보여줍니다. <br> 연도와 주차(week)가 주어지면 그에 해당하는 객체들을 보여줍니다. <br> 연, 월, 일이 주어지면 그 날짜에 해당하는 객체들을 보여줍니다. <br> 오늘 날짜에 해당하는 객체들을 보여줍니다. <br> 연, 월, 일 기본 키(또는 슬러그)가 주어지면 그에 해당하는 특정 객체 하나에 대한 상세한 정보를 보여줍니다.

### 15.1.2 View
모든 클래스현 뷰의 기본이 되는 최상위 뷰입니다. 따라서 모든 클래스형 뷰는 이 View 클래스를 상속받습니다. 이 뷰를 직접 상속받아 코딩하는 경우는 많지 않을테지만, 원하는 로직에 맞는 제네릭 뷰가 없는 경우 이 뷰를 상속받아 직접 클래스형 뷰를 작성 할 수 있습니다.  

밑의 TestView는 직접 View 클래스를 상속받아서 get() 메소드를 직접 정의하고, 'Hello World!'를 화면에 출력하는 클래스형 뷰를 구현했습니다.

```python
class TestView(View):
    def get(self, request, *arg, **kwargs):
        return HttpResponse('Hello World!')
```

### 15.1.3 TemplateView
단순하게 화면에 보여줄 템플릿 파일을 처리하는 정도의 간단한 뷰입니다. 아주 간단하게는 템플릿 파일만 지정해주면 됩니다.  

[chap4의 HomeView](https://kimdoky.github.io/django/2017/09/03/pyDjango-ch4.html){:target="\_blank"}는 TemplateView 제네릭 뷰를 상속받고 있으며, home.html 템플릿 파일을 렌더링해서 화면에 보여주는 것이 주된 역할입니다.

```python
class HomeView(TemplateView):
    template_name = 'home.html'
```

### 15.1.4 RedirectView
주어진 URL로 리다이렉트시켜주는 제네릭 뷰입니다. 그래서 URL 속성이 필수입니다. URL 대신 URL 패턴명이 주어져도 URL을 알아낼 수 있습니다. 만일 URL을 알 수 없다면, RedirectView는 HttpResponseGone (410) 에러 응답을 발생시킵니다. 간단하게 설명하면, RedirectView는 복잡한 로직 없이 리다이렉트만 원할 때 사용하는 뷰입니다.

```python
class TestRedirectView(RedirectView):
    url = '/blog/post/'
    # 다음처럼 URL 대신에 패턴명을 지정해도 됩니다.
    # pattern_name = 'blog:post_list'
```

### 15.1.5 DetailView
ListView와 더불어 가장 많이 사용되는 제네릭 뷰입니다. DetailView는 특정 객체 하나에 대한 정보를 보여주는 뷰입니다. 자주 사용되는 예는, 테이블에서 기본 키(PK)로 지정된 레코드 하나에 대한 정보를 보여주는 것입니다.  

다음 예는 [chap3의 PostDV 뷰](https://kimdoky.github.io/django/2017/08/30/pyDjango-ch3.html){:target="\_blank"}입니다. Post 테이블에서 특정 특정 레코드 하나를 읽은 후에, 그 레코드를 object 컨텍스트 변수에 담아서 템플렛에 넘겨 줍니다. 템플릿 파일에서는 `{{ object }}` 변수를 사용해, 레코드 정보들을 출력합니다.

```python
class PostDV(DetailView):
    model = Post
```

또 한 가지 중요한 점은 위 코드에서 Post 테이블만 지정했는데 어떻게 특정 레코드를 읽어올 수 있을까요? 해답은 URLconf에 있습니다. [chap3](https://kimdoky.github.io/django/2017/08/30/pyDjango-ch3.html){:target="\_blank"}를 보면 PostDV 뷰를 호출하는 코드를 찾을 수 있습니다.

```python
    # ex: /post/django-example/
    url(r'^post/(?P<slug>[-\w]+)/$', PostDV.as_view(), name='post_detail'),
```
위 URL 정의에 따르면 만일 /blog/post/django-example/ 이라는 URL이 들어오면, PostDV.as_view() 를 호출 시 인자로 사전 데이터 `{'slug': 'django-example'}`을 넘겨줍니다. 이 slug 인자로 Post 테이블을 검색해 slug 컬럼이 django-example인 레코드를 찾게 됩니다. 즉 DetailView 제네릭 뷰를 사용 시, 테이블은 뷰 클래스에서 지정하고 레코드 검색용 키는 URLconf에서 지정하는 것입니다. 레코드 검색용 키는 보통 기본 키(PK)를 사용하는데, 이 예처럼 slug를 사용하기도 합니다.

### 15.1.6 ListView
DetailView처럼 자주 사용하는 제네릭 뷰입니다. ListView는 여러 객체의 리스트를 보여주는 뷰입니다. 자주 사용하는 예는 테이블의 모든 레코드를 리스팅해주는 것입니다.  

다음 예는 PostLV 뷰의 일부입니다. Post 테이블에서 모든 레코드를 읽은 후에, 그 레코드들을 object_list 컨텍스트 변수에 담아서 템플릿에 넘겨줍니다. 템플릿 파일에서는 `{{ object_list }}` 변수를 사용해 레코드 리스트를 출력합니다.

```python
class PostLV(ListView):
    model = Post
```

### 15.1.7 FormView
폼을 보여주기 위한 제네릭 뷰입니다. 그래서 폼을 지정해주는 form_class와 이 폼을 렌더링하는데 필요한 template_name 속성이 주요 속성들입니다. 추가적으로 폼 처리가 성공한 후에 리다이렉트 목적지 URL을 지정하는 success_url 속성도 필요합니다.  

폼을 처리하는 작업은 꽤 복잡한 편입니다. get() 메소드와 post() 메소드를 구분해 서로 처리하는 내용이 다르고, 폼을 보여준 다음, 사용자가 폼에 입력한 데이터가 유효한지 검사도 해야하고, 처리가 완료된 후에 적당한 페이지로 이동도 해야 합니다. 이런 복잡한 과정을 FormView가 알아서 처리해주고, 개발자는 form_class, template_name, success_url 등 필요한 속성이나 메소드만 오버라이딩해주면 됩니다.  

다음 예는 [chap9](https://kimdoky.github.io/django/2017/09/10/pyDjango-ch9.html){:target="\_blank"}에서 작성한 SearchFormView 뷰입니다. 폼을 렌더링해 화면에 보여주기 위해, form_class, template_name 속성을 지정합니다. 사용자가 폼에 검색용 단어를 입력한 후에 제출하면, 그 단어로 Post 테이블을 검색하는 작업은 form_valid() 메소드에 정의하고 있습니다. form_valid() 메소드는 제출된 폼이 유효성 검사를 통과하면 호출되는 메소드입니다.  

여기서 한 가지 유의할 점은 success_url 속성은 지정하지 않았다는 점입니다. 검색 처리가 완료된 후에 새로운 페이지로 이동하는 것이 아니라, 검색 결과를 같은 페이지에 보여주고자 했기 때문에 리다이렉트를 불필요합니다.

```python
class SearchFormView(FormView):
    form_class = PostSearchForm
    template_name = 'blog/post_search.html'

    def form_valid(self, form):
        schWord = '%s' % self.request.POST['search_word']
        post_list = Post.objects.filter(Q(title__icontains=schWord) | Q(description__icontains=schWord) | Q(content__icontains=schWord)).distinct()
        context = {}
        context['form'] = form
        context['search_term'] = schWord
        context['object_list'] = post_list

        return render(self.request, self.template_name, context) # No Redirection
```

### 15.1.8 CreateView
CreateView는 새로운 레코드를 생성해서 테이블에 저장해주는 뷰입니다. 새로운 레코드를 생성하기 위해서는 레코드 정보를 입력받을 수 있는 폼이 필요합니다. 그래서 CreateView는 FormView의 기능을 포함하고 있습니다.  

그 외에 모델 정의로부터 폼을 자동으로 만들어주는 기능과 데이터베이스에 레코드를 저장하는 기능이 더 추가된 것으로 이해하면 됩니다. 즉, CreateView는 항상 작업 대상이 되는 테이블이 있으므로, 그 테이블 정의로부터 폼을 만들 수 있습니다. 또한 최동적으로는 그 테이블에 새로운 레코드를 저장하는 것이 주 역할입니다.  

다음 예는 [chap12](https://kimdoky.github.io/django/2017/09/18/pyDjango-ch12.html){:target="\_blank"}에서 작성한 클래스형 뷰인 PostCreateView입니다. 작업 대상 테이블을 model 속성으로 지정하고, 폼을 만들 때 사용할 필드를 fields 속성으로 정의하고 있습니다. 또한 FormView와 마찬가지로 처리가 성공한 후이 이동할 URL을 success_url 속성으로 지정했습니다. 또한 form_valid() 메소드를 오버라이드해서, 폼의 owner 필드에 현재 로그인한 사용자를 자동으로 채워주고 있습니다. 그외 initial 속성은 CreateView의 주요 속성이 아니므로 본문 설명을 참고하세요.

```python
class PostCreateView(LoginRequiredMixin, CreateView):
    model = Post
    fields = ['title', 'slug', 'description', 'content', 'tag']
    initial = {'slug': 'auto-filling-do-not-input'}
    success_url = reverse_lazy('blog:index')

    def form_valid(self, form):
        form.instance.owner = self.request.user
        return super(PostCreateView, self).form_valid(form)
```

### 15.1.9 UpdateView
UpdateView는 테이블에 이미 있는 레코드를 수정해주는 제네릭 뷰입니다. CreateView의 기능과 매우 유사하고, 레코드를 신규로 생성하는 것이 아니라 기존 레코드를 수정한다는 점만 다릅니다.  

CreateView와 마찬가지로 UpdateView는 FormView의 기능을 포함하고 있고, 작업 대상 테이블로부터 폼을 만들어주며, 최종적으로는 수정된 레코드를 테이블에 저장합니다.  

다음 예는 [chap12](https://kimdoky.github.io/django/2017/09/18/pyDjango-ch12.html){:target="\_blank"}에서 작성한 클래스형 뷰인 PostUpdateView입니다. 작업 대상 테이블을 model 속성으로 지정하고, 폼을 만들 때 사용할 필드를 fields 속성으로 정의하고 있습니다. 또한 FormView와 마찬가지로 처리가 성공한 후에 이동할 URL을 success_url 속성으로 지정했습니다. 기존 레코드를 수정한 것이고 기존 레코드를 이미 owner 필드가 채워져 있으므로, PostCreateView 에서는 form_valid() 메소드를 오버라이딩하는 코드가 여기서는 불필요합니다.

```python
class PostUpdateView(LoginRequiredMixin, UpdateView):
    model = Post
    fields = ['title', 'slug', 'description', 'content', 'tag']
    success_url = reverse_lazy('blog:index')
```

UpdateView는 DetailView와 동일하게 수정할 레코드를 URLconf에서 지정해야 한다는 점을 유의해야 합니다. PostUpdateView 뷰를 호출하는 URL 패턴은 다음과 같이 정의되어 있습니다.

```python
    # ex: /99/update/
    url(r'^(?P<pk>[0-9]+)/update/$', PostUpdateView.as_view(), name="update"),
```
위 URL 정의에 따르면 만일 /blog/99/update/ 라는 URL이 들어오면, PostUpdateView.as_view() 를 호출 시 인자로 사전 데이터 {'pk':99}를 넘겨줍니다. 이 pk 인자는 테이블의 기본 키를 의미하며, PostUpdateView 뷰는 Post 테이블에서 기본 키가 99인 레코드를 찾아 처리를 합니다.

### 15.1.10 DeleteView
DeleteView는 기존 객체를 삭제하기 위한 제네릭 뷰입니다. 삭제 처리는 내부에서 이뤄지고 코드에 나타나는 것은 삭제 확인 화면입니다. UpdateView와 처리 과정을 비슷하지만 폼 모습이 다르다는 모습만 유의하면 됩니다.  

CreateView, UpdateView는 모두 데이터를 입력받는 폼이 필요하고, 이런 폼을 모델 정의를 바탕으로 만듭니다. 반면 DeleteView는 삭제 확인용 폼만 필요하므로 입력 항목은 불필요하고 모델 정의를 참조하지도 않습니다.  

다음 예는 [chap12](https://kimdoky.github.io/django/2017/09/18/pyDjango-ch12.html){:target="\_blank"}에서 작성한 클래스형 뷰인 PostDeleteView입니다. 작업 대상 테이블을 model 속성으로 지정하고 처리가 성공한 후에 이동할 URL을 success_url속성으로 지정하는 것은, CreateView, UpdateView와 동일합니다. 다른 점은 폼을 만들때 모델을 참조하지 않으므로 fields 속성을 불필요합니다.

```python
class PostDeleteView(LoginRequiredMixin, DeleteView):
    model = Post
    success_url = reverse_lazy('blog:index')
```

UpdateView와 동일하게, DeleteView도 수정할 레코드를 URLconf에서 지정합니다.

```python
    # ex: /99/delete/
    url(r'^(?P<pk>[0-9]+)/delete/$', PostDeleteView.as_view(), name="delete"),
```

만일 /blog/99/delete/ 라는 URL이 들어오면, 사전형 데이터 {'pk':99}를 PostDeleteView.as_view() 메소드에 넘겨주고, PostDeleteView 뷰는 Post 테이블에서 기본 키가 99인 레코드를 찾아 삭제 처리를 합니다.

### 15.1.11 ArchiveIndexView
ArchiveIndexView 제네릭 뷰는 여러 개의 객체를 대상으로 날짜를 기준으로 리스팅해주는 뷰입니다. 날짜 기반 제네릭 뷰의 최상위 뷰로써, 대상이 되는 모든 객체를 날짜 기준 내림차순으로 보여줍니다. 날짜와 관련된 필드들 중에서 어느 필드를 기준으로 정렬할지를 결정하는 date_field 속성이 가장 중요합니다.  

다음 예는 [chap3](https://kimdoky.github.io/django/2017/08/30/pyDjango-ch3.html){:target="\_blank"}에서 작성한 클래스형 뷰인 PostAV입니다. 작업 대상 테이블을 model 속성으로 지정하고, 정렬 기준 필드를 modify_date  컬럼으로 지정했습니다. 결과는 Post 테이블에 있는 모든 레코드를 modify_date 컬럼을 기준으로 내림차순, 즉 최신 날짜의 레코드를 먼저 보여줍니다.

```python
class PostAV(ArchiveIndexView):
    model = Post
    date_field = 'modify_date'
```

참고로 템플릿에 넘겨주는 컨텍스트 변수 중에서 object_list는 객체들의 리스르틑 담고 있고 date_list 는 대상 객체들의 연도를 담고 있습니다.

### 15.1.12 YearArchiveView
YearArchiveView 제네릭 뷰는 연도가 주어지면, 여러 개의 객체를 대상으로 가능한 월(month)을 알려주는 제네릭 뷰입니다. 디폴트 동작은 객체들을 출력해주는 것이 아니라, 객체의 날짜 필드를 조사해 월을 추출한다는 점입니다. 만일 주어진 연도에 해당하는 객체들을 알고 싶으면 make_object_list 속서을 True로 지정해야 합니다. model 속성이나 date_field 속성을 지정하는 것은 ArchiveIndexView 뷰와 동일합니다.  

다음 예는 [chap3](https://kimdoky.github.io/django/2017/08/30/pyDjango-ch3.html){:target="\_blank"}에서 작성한 클래스형 뷰인 PostYAV입니다. 작업 대상 테이블을 model 속성으로 지정하고, 정렬 기준 필드를 modify_date 컬럼으로 지정했습니다. make_object_list 속성이 True이므로, 결과는 Post 테이블에서 주어진 연도에 해당하는 레코드들을 내림차순으로 화면에 출력합니다.

```python
class PostYAV(YearArchiveView):
    model = Post
    date_field = 'modify_date'
    make_object_list = True
```
YearArchiveView 제네릭 뷰도 인자를 URLconf에서 추출합니다. 즉 YearArchiveView 뷰는 연도 인자가 필요한데, 연도 인자를 URLconf에서 지정합니다. 다음은 PostYAV 뷰를 호출하는 URL 정의입니다.

```python
    # ex: /2017/
    url(r'^(?P<year>\d{4})/$', PostYAV.as_view(), name='post_year_archive'),
```
만일 /blog/2017/ 라는 URL이 들어오면, 사전형 데이터 {'year':2017}를 PostYAV.as_view() 메소드에 넘겨주고, PostYAV 뷰는 Post 테이블의 modify_date 컬럼의 연도가 2017년인 레코드를 찾아 줍니다.  

참고로 템플릿에 넘겨주는 컨텍스트 변수 중에서, object_list는 인자로 주어진 연도에 해당하나는 객체들의 리스트를 담고 있는 date_list는 그 객체들의 월을 담고 있습니다. 물론 make_object_list 속성이 False이면 object_list는 None이 됩니다.

### 15.1.13 MonthArchiveView
MonthArchiveView 제네릭 뷰는 주어진 연/월에 해당하는 객체를 보여주는 제네릭 뷰입니다. 연/월 인자는 URLconf에서 지정합니다. model 속성이나 date_field 속성을 지정하는 것은 ArchiveIndexView 뷰와 동일하고, make_object_list 속성은 없습니다.  

다음 예는 [chap3](https://kimdoky.github.io/django/2017/08/30/pyDjango-ch3.html){:target="\_blank"}에서 작성한 클래스형 뷰인 PostMAV입니다. 작업 대상 테이블을 model 속성으로 지정하고, 정렬 기준 필드를 modify_date 컬럼으로 지정했습니다. 결과는 Post 테이블에서 주어진 연/월에 해당하는 레코드들을 내림차순으로 화면에 출력합니다.

```python
class PostMAV(MonthArchiveView):
    model = Post
    date_field = 'modify_date'
```

MonthArchiveView 제네릭 뷰는 연과 월 2개의 인자가 필요한데, 이들을 URLconf에서 추출합니다. 만일 /blog/2017/nov/ 라는 URL이 들어오면, 사전형 데이터 {'year':'2017', 'month':'nov'}를 PostMAV.as_view() 메소드에 넘겨주고, PostMAV 뷰는 Post 테이블의 modify_date 컬럼의 연도 및 월이 2017년 11월인 레코드를 찾아 줍니다.

```python
    # ex: /2017/nov/
    url(r'^(?P<year>\d{4})/(?P<month>[a-z]{3})/$', PostMAV.as_view(), name='post_month_archive'),
```

참고로 템플릿에 넘겨주는 컨텍스트 변수 중에서 object_list는 인자로 주어진 연/월에 해당하는 객체들의 리스트를 담고 있고 date_list는 그 객체들의 일을 담고 있습니다.

### 15.1.14 WeekArchiveView
WeekArchiveView 제네릭 뷰는 연도와 주(week)가 주어지면 그에 해당하는 객체를 보여주는 제네릭 뷰입니다. 연/주 인자는 URLconf에서 지정합니다. 주 인자는 1년을 주차로 표현하므로, 1부터 53까지의 값을 가집니다. model 속성이나 date_field 속성을 지정하는 것은 ArchiveIndexView 뷰와 동일합니다.  

TestWeekArchiveView는 작업 대상을 Post 테이블을, 정렬 기준은 modify_date 컬럼으로 지정했습니다. 결과는 Post 테이블에서 주어진 연/주에 해당하는 레코드들을 내림차순으로 화면에 출력합니다.

```python
class TestWeekArchiveView(WeekArchiveView):
    model = Post
    date_field = 'modify_date'
```

WeekArchiveView 제네릭 뷰는 연도와 주차 2개의 인자가 필요한데, 이들은 URLconf에서 추출합니다. 다음 코드는 TestWeekArchiveView 뷰를 호출하는 URL 정의입니다. 만일 /blog/2017/week/23/ 이라는 URL이 들어오면, 사전형 데이터 {'year':'2017', 'week':'23'} 을 TestWeekArchiveView.as_view() 메소드에 넘겨주고, TestWeekArchiveView 뷰는 Post 테이블의 modify_date 컬럼에서 2017년 23주차인 레코드를 찾습니다.

```python
    # ex: /2017/week/23/
    url(r'^(?P<year>\d{4}/week/(?P<week>\d{1,2})/$', TestWeekArchiveView.as_view(), name='post_week_archive'),
```
참고로 템플릿에 넘겨주는 컨텍스트 변수 중에서 object_list는 인자로 주어진 연/주에 해당하는 객체들의 리스트를 담고 있고 date_list는 그 객체들의 연도를 담고 있습니다.

### 15.1.15 DayArchiveView
DayArchiveView 제네릭 뷰는 연/월/일이 주어지는 그에 해당하는 객체를 보여주는 제네릭 뷰입니다. 역시 연/월/일 인자는 URLconf에서 지정합니다. model 속성이나 date_field 속성을 지정하는 것은 ArchiveIndexView 뷰와 동일합니다.

다음 예는 [chap3](https://kimdoky.github.io/django/2017/08/30/pyDjango-ch3.html){:target="\_blank"}에서 작성한 클래스형 뷰인 PostDAV입니다. 작업 대상 테이블은 Post 테이블로, 정렬 기준은 modify_date 컬럼으로 지정했습니다. 결과는 Post 테이블에서 주어진 연/월/일에 해당하는 레코드들을 내림차순으로 화면에 출력합니다.

```python
class PostDAV(DayArchiveView):
    model = Post
    date_field = 'modify_date'
```
DayArchiveView 제네릭 뷰는 연, 월, 일 3개의 인자가 필요한데, 이들은 URLconf에서 추출합니다. 만일 /blog/2017/nov/10/ 이라는 URL이 들어오면, 사전형 데이터 {'year':'2017', 'month':'nov', 'day':'10'}을 PostDAV.as_view() 메소드에 넘겨주고, PostDAV 뷰는 Post 테이블의 modify_date 컬럼에서 연, 월, 일이 2017년 11월 10일인 레코드를 찾아 줍니다.

```python
    # ex: /2017/nov/10/
    url(r'^(?P<year>\d{4})/(?P<month>[a-z]{3})/(?P<day>\d{1,2})/$', PostDAV.as_view(), name='post_day_archive'),
```
참고로 템플릿에 넘겨주는 컨텍스트 변수 중에서 object_list는 인자로 주어진 연/월/일에 해당하는 객체들의 리스트를 담고 있고 date_list는 그 객체들의 연도를 담고 있습니다.

### 15.1.16 TodayArchiveView
TodayArchiveView 제네릭 뷰는 오늘 날짜에 해당하는 객체를 보여주는 제네릭 뷰입니다. 오늘 날짜를 사용하므로 연/월/일 인자가 불필요하다는 점을 제외하고, DayArchiveView와 동일한 제네릭 뷰입니다.  

다음 예는 [chap3](https://kimdoky.github.io/django/2017/08/30/pyDjango-ch3.html){:target="\_blank"}에서 작성한 클래스형 뷰인 PostTAV입니다. 작업 대상 테이블은 Post 테이블로, 정렬 기준은 modify_date 컬럼으로 지정했습니다. 결과는 Post 테이블에서 오늘 날짜에 해당하는 레코드들을 내림차순으로 화면에 출력합니다.

```python
class PostTAV(TodayArchiveView):
    model = Post
    date_field = 'modify_date'
```

TodayArchiveView 제네릭 뷰는 연, 월, 일 등의 인자가 필요하지 않으므로, URL 정의가 간단합니다. 만일 /blog/today/ 라는 URL이 들어오면, 뷰 내부에서 datetime.date.today() 함수로 오늘 날짜를 알아내서 처리합니다.

```python
    # ex: /today/
    url(r'^today/$', PostTAV.as_view(), name='post_today_archive'),
```
참고로 템플릿에 넘겨주는 컨텍스트 변수 중에서, object_list는 오늘 날짜에 해당하는 객체들의 리스트를 담고 있고 date_list는 그 객체들의 연도를 담고 있습니다.

### 15.1.17 DateDetailView
DateDetailView 제네릭 뷰는 날짜 기준으로 특정 객체를 찾아서, 그 객체의 상세 정보를 보여주는 뷰입니다. 특정 객체의 상세 정보를 보여준다는 점에서 DetailView와 동일하지만, 객체를 찾는데 사용하는 인자로 연/월/일 정보를 추가적으로 사용하는 점이 다릅니다. 문론 기본 키 또는 slug 인자도 사용하므로 열/월/일/pk/ 등 4개의 인자가 필요하고, 이들은 URLconf에서 추출합니다. model 속성이나 date_field 속성을 지정하는 것은 ArchiveIndexView 뷰와 동일합니다.  

예제 TestDateDetailView는 작업 대상은 Post 테이블을, 작업 기준은 modify_date 컬럼으로 지정했습니다. 처리 과정은 Post 테이블의 modify_date 컬럼에서 주어진 연/월/일에 해당하는 레코드를 찾고 그중에서 pk 또는 slug 인자로 특정 객체 하나를 찾습니다.

```python
class TestDateDetailView(DateDetailView):
    model = Post
    date_field = 'modify_date'
```
DateDetailView 제네릭 뷰는 연, 월, 일 및 기본 키 또는 슬러그 등 4개의 인자가 필요한데, 이들을 URLconf에서 추출합니다. /blog/2017/nov/10/99/ 라는 URL이 들어오면, 사전형 데이터 {'year':'2017', 'month':'nov', 'day':'10', 'pk':99}를 TestDateDetailView.as_view() 메소드에 넘겨줍니다. TestDateDetailView 뷰는 Post 테이블의 modify_date 컬럼에서 연, 월, 일이 2017년 11월 10일이고 기본 키가 99인 레코드 하나를 찾아 줍니다.

```python
    # ex: /2017/nov/10/99/
    url(r'^(?P<year>[0-9]{4})/(?P<month>[-\w]+)/(?P<day>[0-9]+)/(?P<pk>[0-9]+)/$', TestDateDetailView.as_view(), name='post_archive_detail'),
```
참고로 날짜 기반의 다른 제네릭 뷰들은 복수의 객체들을 출력하는데 비해, DateDetailView 뷰는 특정 객체 하나만을 다룹니다. 따라서 템플릿에 넘겨주는 컨텍스트 변수는 object_list가 아니라 object 변수를 사용하고 date_list 변수는 사용하지 않습니다. object 변수에는 연/월/일/pk 인자로 찾은 객체 하나가 들어 있습니다.

> #### 제네릭 뷰의 작업 대상 객체 지정  
제네릭 뷰를 설명하면서, 작업 대상은 주로 Post 테이블을 지정했지만, 작업 대상이 반드시 테이블이어야 하는 것은 아닙니다. 테이블의 레코드가 아니더라도, 일반 객체들이 들어 있는 QuerySet 객체이면 제네릭 뷰의 작업 대상이 됩니다. 따라서 대부분의 제네릭 뷰들은 작업 대상 객체들을 지정하기 위해, **model** 속성 또는 **queryset** 속성 또는 **get_queryset()** 메소드를 제공합니다.  
참고로 View, TemplateView, RedirectView, FormView 등은 작업 대상을 지정할 필요가 없는 제네릭 뷰이므로, model이나 queryset 속성을 사용하지 않습니다.

## 15.2 제네릭 뷰 오버라이딩
적절한 제네릭 뷰를 선택했다면, 해당 제네릭 뷰에서 제공하는 속성과 메소드를 검새해서 무엇을 오버라이딩할지 결정해야 합니다. 각 제네릭 뷰에서 제공하는 속성과 메소드가 많아서 자주 사용하는 속성과 메소드만 다룹니다. 자세한 설명은 [장고 문서](https://docs.djangoproject.com/en/1.11/topics/class-based-views/){:target="\_blank"}를 참고하세요.

### 15.2.1 속성 오버라이딩
제네릭 뷰에서 제공하는 속성들을 살펴보고 그대로 사용할 것인지 변경해서 사용할 것인지를 결정해야 합니다. 개발자가 속성을 변경해서 사용하는 경우를 속성 오버라이딩이라고 합니다.

#### model
기본 뷰(View, TemplateView, RedirectView) 3개를 제외하고는 모든 제네릭 뷰에서 사용하는 속성입니다. 뷰가 출력할 데이터가 들어 있는 모델을 지정합니다. model 대신 queryset 속성으로 지정할 수도 있습니다. 다움 두 가지 표현은 동일한 의미입니다.  

- model = Bookmark
- queryset = Bookmark.object.all()

#### queryset
기본 뷰(View, TemplateView, RedirectView) 3개를 제외하고는 모든 제네릭 뷰에서 사용하는 속성입니다. 출력 대상이 되는 QuerySet 객체를 지정합니다.  

queryset 속성을 지정하면 model 속성은 무시됩니다.

#### template_name
TemplateView를 포함해 모든 제네릭 뷰에서 사용하는 속성입니다. 템플릿 파일명을 문자열로 지정합니다.

#### context_object_name
기본 뷰(View, TemplateView, RedirectView) 3개를 제외하고는 모든 제네릭 뷰에서 사용하는 속성입니다. 템플릿 파일에서 사용할 컨텍스트 변수명을 지정합니다.

#### paginate_by
ListView와 날짜 기반 뷰에서 사용합니다. 페이징 기능이 활성화된 경우에, 페이지당 몇 개 항목을 출력할 것인지 정수로 지정합니다.

#### date_field
날짜 기반 뷰에서 기준이 되는 필드를 지정합니다. 이 필드를 기준으로 년/월/일을 검사합니다. 이 필드 타입은 DateField 또는 DateTimeField이어야 합니다.

#### make_object_list
YearArchiveView 사용 시 해당 년에 맞는 객체들의 리스트를 생성할지 여부를 지정합니다. True이면 객체들의 리스트를 만들고 그 리스트를 템플릿에서 사용할 수 있습니다. False이면 queryset 속성에 None이 할당됩니다.

#### form_class
FormView, CreateView, UpdateView에서 사용합니다. 폼을 만드는데 사용할 클래스를 지정합니다.

#### initial
FormView, CreateView, UpdateView에서 사용합니다. 폼에서 사용할 초기 데이터를 dict로 지정합니다.

#### fields
CreateView, UpdateView에서 사용합니다. 폼에 사용할 필드를 지정합니다. ModelForm 클래스의 Meta.fields 속성과 동일한 의미입니다.

#### success_url
FormView, CreateView, UpdateView, DeleteView 에서 사용합니다. 폼에 대한 처리가 성공한 이후에 리다이렉트될 URL을 지정합니다.

### 15.2.2 메소드 오버라이딩
제네릭 뷰에서 제공하는 메소들을 살펴보고 어떤 메소드를 오버라이딩할지를 결정하는게 중요합니다.

#### get_queryset()
기본 뷰(View, TemplateView, RedirectView) 3개를 제외하고는, 모든 제네릭 뷰에서 사용하는 메소드입니다.  
출력 객체를 검색하기 위한 대상 QuerySet 객체 또는 출력 대상인 객체 리스트를 반환합니다. 디폴트는 queryset 속성값을 반환합니다. queryset 속성이 지정되지 않은 경우는 모델 매니저 클래스의 all() 메소드를 호출해 QuerySet 객체를 생성해 이를 반환합니다.

#### get_context_data(\**kwargs)
TemplateView를 포함해 모든 제네릭 뷰에서 사용하는 메소드입니다. 템플릿에서 사용할 컨텍스트 데이터를 반환합니다.

#### form_valid(form)
FormView, CreateView, UpdateView 에서 사용합니다. get_success_url() 메소드가 반환하는 URL로 리다이렉트를 수행합니다.

### 15.2.3 본문의 예제
[chap3](https://kimdoky.github.io/django/2017/08/30/pyDjango-ch3.html){:target="\_blank"}에서 PostLV뷰로 설명합니다. PostLV 뷰는 Post 객체들의 리스트를 보여주기 위한 뷰이므로, ListView 제네릭 뷰를 상속받고 있습니다.

우선 오버라이딩 테스트를 위해서, 테스트용 URL 및 PostLV 뷰와 동일한 TestPostLV 뷰를 만듭니다.

- blog/urls.py
```python
    # ex: /test/
    url(r'^test/$', TestPostLV.ad_view(), name='post_test'), # 추가
```

- blog/views.py
```python
#-- ListView
class PostLV(ListView):
    model = Post
    template_name = 'blog/post_all.html'
    context_object_name = 'posts'
    paginate_by = 2

# 상단 내용 동일
class TestPostLV(ListView):
    model = Post
    template_name = 'blog/post_all.html'
    context_object_name = 'posts'
    paginate_by = 2
# 하단 내용 동일
```

현재 model, template_name, context_object_name 속성이 오버라이딩되어 있습니다. 보통의 경우 오버라이딩하는 속성들입니다. 또한 페이징 기능을 활성화하기 위해 paginate_by 속성을 오버라이딩했습니다.

#### queryset 속성
로직을 약간 변경해서, 포스트 리스트를 모두 보여주는게 아니라 5개만 보여주고 싶다면 queryset 속성에 지정해주면 됩니다. 즉 queryset 속성은 출력 대상을 지정해주는 속성이기 때문입니다.

```python
class TestPostLV(ListView):
    #model = Post     # 주석 처리
    queryset = Post.objects.all()[:5]    # 추가
    template_name = 'blog/post_all.html'
    context_object_name = 'posts'
    paginate_by = 2
```
queryset 속성을 지정하면 model 속성은 불필요합니다.

#### get_queryset() 메소드
포스트 글에 특정 단어가 들어 있는 객체들만 보여주는 로직을 변경하고자 합니다. 특정 단어는 URL에 지정하는 걸로 변경합니다. 이를 위해서 urls.py 파일도 수정이 필요합니다.

- blog/urls.py
```python
# ex: /test/word/
    url(r'^test/(?P<word>[\w]+)/$', TestPostLV.as_view(), name='post_test'), # 수정
```

-  blog/views.py
```python
class TestPostLV(ListView):
    # model = Post
    queryset = Post.objects.all()[:5]
    template_name = 'blog/post_all.html'
    context_object_name = 'posts'
    paginate_by = 2

    # 메소드 추가
    def get_queryset(self):
        return Post.objects.filter(Q(content__icontains=self.kwargs['word'])).distinct()
```
이 예제에서도 본문의 [Search] 메뉴를 구현할 때 사용했던 Q 객체를 사용해 검색을 하고 있습니다. 이번 예제에서는 검색 단어를 URL에서 지정함으로써, 동적으로 출력 대상을 변경하고 있습니다. 이렇게 동적으로 출력 대상을 변경하는 기능은 queryset 속성 오버라이딩으로는 불가하고, get_queryset() 메소드를 사용해야 합니다. 즉 get_queryset() 메소드 오버라이딩 방식이 좀 더 강력한 기능입니다.  

출련 대상을 변경하고자 할 때 queryset 속성 오버라이딩과 get_queryset() 메소드 오버라이딩 둘 다 가능하다는 점과 그 차이점을 이해하는 게 중요합니다. 또한 model 속성, queryset 속성, get_queryset() 메소드 3가지는 역할이 동일하므로, 이 중에서 한 가지만 지정하면 됩니다.

#### template_name 속성
템플릿 처리와 관련된 속성을 오버라이딩하는 예제를 봅니다. 우선 기존의 post_all.html 템플릿을 복사해서 post_test.html 파일을 만들고 이 파일을 템플릿 파일로 지정합니다.

- blog/views.py
```python
class TestPostLV(ListView):
    # model = Post
    # queryset = Post.objects.all()[:5]
    # template_name = 'blog/post_all.html'
    template_name = 'blog/post_test.html' # 추가
    context_object_name = 'posts'
    paginate_by = 2

    def get_queryset(self):
        return Post.objects.filter(Q(content__icontains=self.kwargs['word'])).distinct()
```
template_name 속성으로 새로운 템플릿 파일을 지정했습니다.  
새로운 템플릿 파일도 테스트를 위해서 제목 부분문 약간 변경합니다.

- blog/templates/blog/post_test.html
{% raw %}
```html
<div id="content">

<h1>Blog List - test </h1>   # 수정

{% for post in posts %}
```
{% endraw %}

#### get_context_data() 메소드
뷰에서 템플릿 파일에 넘겨주는 컨텍스트 데이터를 추가하거나 변경할 수 있습니다. 제네릭 뷰들은 디폴트로 사용하는 컨텍스트 변수들이 있습니다. ListView 뷰에서 사용하는 object_list 및 DetailView 뷰에서 사용하는 object 변수가 그 예입니다. 이런 디폴트 컨텍스트 변수 이외에 추가로 지정하고 싶은 컨텍스트 변수가 있으면, get_context_data() 메소드를 오버라이딩합니다.  

만일 URL에 지정된 검색 단어를 페이지에 출력하고자 한다면, 다음 코드처럼 검색 단어를 컨텍스트 객체에 담아서 템플릿 파일에 넘겨주면 됩니다. get_context_data() 메소드는 컨텍스트 데이터를 새로 구성해주는 메소드입니다.

- blog/views.py
``` python
class TestPostLV(ListView):
    # model = Post
    # queryset = Post.objects.all()[:5]
    # template_name = 'blog/post_all.html'
    template_name = 'blog/post_test.html'
    context_object_name = 'posts'
    paginate_by = 2

    def get_queryset(self):
        return Post.objects.filter(Q(content__icontains=self.kwargs['word'])).distinct()

    # 메소드 추가
    def get_context_data(self, **kwargs):
        context = super(TestPostLV, self).get_context_data(**kwargs)
        context['SearchWord'] = self.kwargs['word']
        return context
```
템플릿 파일에서 사용할 컨텍스트 변수는 SearchWord로 지정해서, 이 변수에 검색 단어를 대입 했습니다. 기존 디폴트 컨텍스트 데이터는 변경 없이 사용하기 위해서 super() 함수로 상위 클래스의 메소드를 호출한다는 점도 유의해야 합니다.  

뷰에서 넘어온 데이터를 출력하기 위해, post_test.html 파일의 제목 라인을 다음 같이 수정합니다. `{{ SearchWord }}` 컨텍스트 변수를 사용하고 있습니다.
{% raw %}
```html
<h1>Blog List - contains the word '{{ SearchWord }}' </h1>
```
{% endraw %}

## 15.3 Method Flowchart
상속과 오버라이딩을 기본 방향으로 작성된 제네릭 뷰는 하위 클래스에서 오버라이딩이 쉽고 여러가지의 애플리케이션에 다양하게 사용될 수 있도록 설계되었습니다. 그런 측면에서 특히 제네릭 뷰의 메소드들은 단위 기능으로 잘게 나누어 메소드의 응집도를 높이고, 템플릿 메소드 디자인 패턴을 적용해 개발자가 제네릭 뷰의 처리 흐름을 쉽게 예상할 수 있도록 했습니다.  

장고에서는 이런 제네릭 뷰의 처리 흐름을 Method Flowchart라고 표기하고 있는데, 대표적인 제네릭 뷰인 DetailView와 ListView 클래스의 Method Flowchart를 살펴봅니다.  

> #### 템플릿 메소드(Template Method) 디자인 패턴
자바 언어에서 많이 사용되고 있는 디자인 패턴은 소프트웨어 설계 시 공통적으로 반복해서 발생하는 문제와 그에 대한 해법을 정리해 둔 것입니다. Gang of Four(GoF)라고 불리는 네 사람에 의해 정리된 23개의 디자인 패턴이 가장 유명합니다.  
그중 템플릿 메소드 패턴은 상위 클래스에서 처리 흐름의 뼈대를 결정하고 하위 클래스에서 그 구체적인 내용을 결정하는 디자인 패턴입니다. 따라서 상위 클래스의 프로그램만 보면 주요 메소드들의 호출 순서 및 처리 흐름을 짐작할 수 있는 특징이 있습니다.

### 15.3.1 ListView
ListView 처리 흐름은 다음 표에 따라 진행되므로, 소스를 보지 않더라도 처리 로직을 짐작할 수 있습니다. 따라서 ListView 제네릭 뷰를 상속받아 하위 클래스형 뷰를 개발하고자 하는 경우에는 개발하고자하는 로직을 이 Method Flowchart 흐름에 맞추
어 설계하고, 그 과정에서 어느 메소드르 ㄹ변경해야 할지를, 즉 어느 메소드를 오버라이딩해야 할지를 결정하고 코딩하면 됩니다.

- Method Flowchart - ListView

순번 | 메소드명 | 메소드 설명
---|---|---
1 | dispatch(request, \*args, \**kwargs) | 클라이언트 요청의 HTTP 메소드를 검사해, 뷰 클래스에 정의된 적절한 처리 메소드를 호출합니다. GET 요청이면 get() 메소드, POST 요청이면 post() 메소드 등 HTTP 메소드 단어의 소문자에 해당하는 메소드를 호출합니다.
2 | http_method_not_allowed(request, \*args, \**kwargs) | dispatch() 메소드에 의해 호출되는 get(), post() 등의 메인 처리 메소드를 찾지 못하는 경우, http_method_not_allowed() 메소드를 호출합니다.
3 | get_template_names() | 템플릿 파일명을 담은 리스트를 반환합니다. template_name 속성이 지정된 경우는 template_name을 리스트에 담아 반환합니다.
4 | get_queryset() | 뷰에서 출력할 항목들의 리스트를 반환합니다. 리스트는 QuerySet 객체와 같은 순환 가능한(iterable) 객체여야 합니다.
5 | get_context_object_name(object_list) | 출력 대상이 되는 리스트에 대한 컨텍스트에 대한 컨텍스트 변수명을 리턴합니다. context_object_name 속성이 지정 안 된 경우는 모델명소문자_list 로 해서 컨텍스트 변수명을 사용합니다. 모델명이 Bookmark인 경우는 컨텍스트 변수명은 bookmark_list가 됩니다.
6 | get_context_data(\**kwargs) | 탬플릿에서 사용할 컨텍스트 데이터를 리턴합니다.
7 | get() | 메인 처리 메소드입니다.
8 | render_to_response(context, \**response_kwargs) | self.response_class 객체를 리턴합니다.

### 15.3.2 DetailView
DetailView 제네릭 뷰를 상속받아 오버라이딩하는 경우도, 코딩 요령은 ListView와 동일합니다.

- Method Flowchart - DetailView

순번 | 메소드명 | 메소드 설명
---|---|---
1 | dispatch(request, \*args, \**kwargs) | 클라이언트 요청의 HTTP 메소드를 검사해, 뷰 클래스에 정의된 적절한 처리 메소드를 호출합니다. GET 요청이면 get() 메소드, POST 요청이면 post() 메소드 등 HTTP 메소드 단어의 소문자에 해당하는 메소드를 호출합니다.
2 | http_method_not_allowed(request, \*args, \**kwargs) |  dispatch() 메소드에 의해 호출되는 get(), post() 등의 메인 처리 메소드를 찾지 못하는 경우, http_method_not_allowed() 메소드를 호출합니다.
3 | get_template_names() | 템플릿 파일명을 담은 리스트를 반환합니다. template_name 속성이 지정된 경우는 template_name을 리스트에 담아 반환합니다.
4 | get_slug_field() | slug 필드명을 반환합니다. 디폴트는 slug_field 속성값을 반환합니다.
5 | get_queryset() | 출력 객체를 검색하기 위한 대상 QuerySet 객체를 반환합니다. 디폴트는 queryset 속성값을 리턴합니다. queryset 속성이 지정되지 않은 경우는 모델 매니저 클래스의 all() 메소드를 출력해 QuerySet 객체를 생성해 이를 반환합니다.
6 | get_object(queryset=None) | 뷰가 출력할 한 개 객체를 리턴합니다. queryset 속성이 지정되었다면 queryset에서 객체를 검색할 것이고, 아니면 get_queryset()을 호출해 검색 대상 객체 리스트를 얻습니다. 검색시에는 pk로 먼저 검색을 시도하고 pk가 안 주어진 경우는 slug로 검색을 수행합니다.
7 | get_context_object_name(object) | 컨텍스트 변수명을 리턴합니다.context_object_name 속성이 지정이 안된 경우는 모델명을 소문자로 해서 컨텍스트 변수명으로 사용합니다. 모델명이 Bookmark인 경우 컨텍스트 변수명은 bookmark가 됩니다.
8 | get_context_data(\**kwargs) | 템플릿에서 사용할 컨텍스트 데이터를 리턴합니다.
9 | get() | 메인 처리 메소드입니다.
10 | render_to_response(context, \**response_kwargs) | self.response_class 객체를 리턴합니다.

ListView와 비교해보면, get_slug_field()와 get_object() 두 개의 메소드가 추가되었고, get_queryset()과 get_context_object_name(object) 는 메소드명은 동일하지만 처리하는 기능이 약간 다르기 때문에 유의해야 합니다.

## 15.4 MRO
파이썬은 다중 상속이 가능한 언어이므로 장고의 제네릭 뷰에서도 다중 상속을 사용하고 있습니다. 다중 상속에서는 동일한 이름을 갖는 메소드가 둘 이상의 부모 클래스에 존재한다면 어느 메소드를 사용해야 할지 결정하는 알고리즘이 필요합니다. 이런 문제를 해결하기 위해서 파이썬에서는 클래스마다 메소드를 찾는 순서를 정한 MRO(Method Resolution Order) 속성을 제공합니다.  

장고의 제네릭 뷰를 사용하는 경우에 MRO 문제는 많지 않습니다. 제네릭 뷰 설계시 각 클래스 간에 메소드 이름이 중복되지 않도록 설계되었기 때문입니다. 하지만 개발자가 직접 작성한 클래스를 상속받는 경우 MRO에 따른 메소드 순서를 잘 따져봐야합니다. 또한 클래스의 상속 계층도를 파악하기 위해 MRO 속성을 보는 경우도 있습니다.  

클래스형 뷰의 내부 동작이나 소스 코드를 읽고자 한다면 MRO에 대한 이해가 필요합니다. 여기서는 ListView 제네릭 뷰의 예제로 간단히 MRO을 살펴봅니다.

![]({{site.url}}/img/post/python/django/book_15.png)

ListView 클래스의 MRO는 자신에서부터 시작해 하위 클래스에서 상위 클래스 순서로 정해집니다. 그리고 class(A,B) 처럼 다중 상속인 경우는 정의된 순서에 따라 A 클래스 다음에 B 클래스 순서로 MRO가 정해집니다. 또한 너비 우선 검색(breadth-first search)보다는 깊이 우선 검색(depth-first search)에 가깝습니다. 사실 MRO의 순서는 상당히 복잡한 과정을 거쳐서 결정되므로 계층도 그림만으로는 정확히 알 수 없습니다. 이런 점을 감안해 파이썬에서는 모든 클래스마다 MRO 순서를 보여주는 __mro__ 속성을 제공합니다.  

ListView 의 MRO 속성은 다음 명령으로 볼 수 있습니다.

```
~/Git/Book_Study/pyDjango/2nd(master) » python manage.py shell                dokyungkim@MacBook-Pro
Python 3.5.2 (default, Apr 30 2017, 16:26:35)
[GCC 4.2.1 Compatible Apple LLVM 8.1.0 (clang-802.0.42)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
>>> from django.views.generic.list import ListView
>>> ListView.__mro__
(<class 'django.views.generic.list.ListView'>, <class 'django.views.generic.list.MultipleObjectTemplateResponseMixin'>, <class 'django.views.generic.base.TemplateResponseMixin'>, <class 'django.views.generic.list.BaseListView'>, <class 'django.views.generic.list.MultipleObjectMixin'>, <class 'django.views.generic.base.ContextMixin'>, <class 'django.views.generic.base.View'>, <class 'object'>)
>>> for i in ListView.__mro__:
...     print(i)
...
<class 'django.views.generic.list.ListView'>
<class 'django.views.generic.list.MultipleObjectTemplateResponseMixin'>
<class 'django.views.generic.base.TemplateResponseMixin'>
<class 'django.views.generic.list.BaseListView'>
<class 'django.views.generic.list.MultipleObjectMixin'>
<class 'django.views.generic.base.ContextMixin'>
<class 'django.views.generic.base.View'>
<class 'object'>
```

ListView 클래스의 상위 클래스들을 MRO 순서에 따라 아래표에 간단히 설명합니다.

상위 클래스명 | 설명
---|---
MultipleObjectTemplateResponseMixin | 여러 개의 객체를 렌더링하는 믹스인 클래스입니다. 즉 객체 리스트를 템플릿 엔진에 넘겨줘서 렌더링합니다.
TemplateResponseMixin | 컨텍스트 데이터가 주어지면, 이 데이터를 렌더링해서 HTTP 응답으로 사용될 TemplateResponse 객체를 생성하는 믹스인 클래스입니다.
BaseListView | 객체 리스트를 출력하는 용도의 Generic Display Views 뷰들에 대한 베이스 뷰입니다.
MultipleObjectMixin | 객체 리스트를 출력하는 믹스인 클래스입니다.
ContextMixin | 디폴트 컨텍스트 데이터를 제공하는 믹스인 클래스입니다.
View | 장고의 모든 클래스형 뷰에 대한 베이스 뷰입니다.
object | 모든 파이썬 클래스에 대한 베이스 클래스입니다.

> #### 믹스인(Mixin) 클래스  
보통의 클래스와는 달리, 믹스인 클래스는 자신의 인스턴스를 만드는 용도보다는 다른 클래스에게 부가 기능을 제공하기 위한 용도로 사용되는 클래스를 의미합니다. 장고에서는 파이썬의 다중 상속 기능을 활용해, 꼭 필요한ㄴ 단위 기능들을 믹스인 클래스로 만들고, 제네릭 뷰에서 이런 믹스인 클래스들을 상속받은 방식으로 제네릭 뷰들을 설계했습니다.  
예를 들어, 모든 제네릭 뷰에서 템플릿 처리는 필수 기능인데, 템플릿 처리도 객체 하나일 때와 여러 개의 객체 일 때 처리하는 과정이 다르므로, 이를 별도의 믹스인 클래스로 만드는 방식입니다. 이렇게 설명하면  ListView와 DetailView에서 템플릿 처리를 위해 자신에게 필요한 믹스인 클래스만 상속받게 해서, 코드의 중복은 줄이고 재사용 효과는 커집니다.

#### [클래스형 뷰 참고 사이트](https://ccbv.co.uk){:target="\_blank"}

## 15.5 제네릭 뷰의 페이징 처리
화면에 보여줄 데이터가 많은 경우 한 페이지 분량에 맞게 적절한 크기로 나눠서, 페이지별로 보여주는 기능이 필요합니다. 이런 기능을 페이징 또는 페이지네이션이라고 합니다. 제네릭 뷰를 대상으로 페이징 기능을 설명하지만, 클래스형 뷰 뿐만 아니라 함수형 뷰에서도 사용할 수 있는 기능입니다.

### 15.5.1 페이징 기능 활성화
ListView처럼 객체의 리스트를 처리하는 제네릭 뷰는 paginate_by 속성을 가집니다. 이런 제네릭 뷰에 paginate_by 속성이 지정되면, 장고의 페이징 기능이 활성화되고 객체 리스트는 페이지별로 구분되어 보여집니다. paginate_by 속성은 페이지당 객체의 개수를 의미합니다.  

> #### MultipleObjectMixin  
paginate_by 속성은 MultipleObjectMixin에 정의되어 있습니다. 따라서 MultipleObjectMixin 클래스 또는 이 클래스를 상속받는 클래스들은 paginate_by 속성을 지정함으로써 페이징 기능을 활성화해 이 기능을 사용할 수 있습니다. ListView 클래스도 MultipleObjectMixin 클래스를 상속받고 있습니다.

페이징 기능이 활성화되면 객체 리스트는 몇 개의 페이지로 나누어지고, 페이지 번호를 지정함으로써 해당 페이지를 화면에 표시할 수 있게 됩니다. 몇 번째 페이지를 화면에 보여줄지는 웹 요청 URL에서부터 지정되고 이를 뷰에서 처리하는데, URL에 페이지를 지정하는 방법은 2가지가 있습니다.  

첫 번째는 URL 경로에 페이지 번호를 지정하고, URLconf에서 이를 추출해 뷰에 넘겨주는 방법입니다.

```python
url(r'^objects/page(?P<page>[0-9]+)/$', PaginatedView.as_view()),
```
만일 URL이 /objects/page3/ 이라면 클래스형 뷰 PaginatedView에 페이지 번호 3을 page 파라미터로 넘겨줍니다.  

두 번째 방법은 URL의 쿼리 문자열에 페이지 번호를 저장하는 방법입니다.

```
/objects/?page=3
```

이 경우느 쿼리 문자열의 page 파라미터에 페이지 번호를 지정하고, 뷰가 직접 request.GET.get('page')와 같은 구문으로 페이지 번호를 추출합니다.  

이러한 두 경우 모두 파라미터 이름은 page임을 유의해야 합니다. page라는 파라미터 이름을 변경할 수도 있는데, 이를 변경한 경우에는 뷰에 page_kwarg 속성으로 알려줘야 합니다.  

이처럼 URL에 페이지 번호가 지정되면, 뷰는 페이징 처리를 하고 나서 그 다음 화면에 보여주는데 필요한 컨텍스트 변수를 템플릿에 넘겨줍니다. 템플릿 파일에서 페이징 기능을 위해 사용되는 컨텍스트 변수는 다음과 같습니다.  

- **object_list** : 화면에 보여줄 객체의 리스트. context_object_name 속성으로 지정된 컨텍스트 변수도 object_list와 동일한 값을 갖습니다.
- **is_paginated** : 출력 결과가 페이징 처리되는지 여부를 알려주는 boolean 변수. 만일 페이지 크기가 지정되지 않았거나 대상 객체 리스트가 페이지로 구분되지 않는 경우는 이 값이 False가 됩니다.
- **paginator** : django.core.paginator.Paginator 클래스의 객체. 페이징 처리가 안 되는 경우에 이 값은 None으로 세팅됩니다.
- **page_obj** : django.core.paginator.Page 클래스의 객체. 페이징 처리가 안 되는 경우에 이 값은 None으로 세팅됩니다.

이처럼 페이징 기능을 사용하기 위해서는 제네릭 뷰에서 paginate_by 속성을 지정하고, 원하는 페이지를 URL에 지정하고, 템플릿 파일에서 컨텍스트 변수만 적절히 사용하면 됩니다. Paginator와 Page 클래스는 장소 설치 디렉터리의 django/core/paginator.py 파일에 정의되어 있습니다. 소스가 어렵지 않기때문에 한번 읽어보면 좋습니다.

### 15.5.2 Paginator 클래스
페이징 기능의 메인 클래스이며, 주요 역할은 객체의 리스트와 페이지당 항목 수를 필수 인자로 받아서 각 페이지 객체를 생성해주는 것입니다.

```python
class Paginator(object_list, per_page, orphans=0, allow_empty_first_page=True)
```

#### 인자(Argument)
앞에 2개는 필수 인자이고, 뒤에 2개는 선택 인자입니다.

- **object_list** : 페이징 대상이 되는 객체 리스트. 객체 리스트는 파이썬의 리스트 또는 튜플 타입이면 가능하고 장고의 QuerySet 객체도 가능합니다. 중요한 점은 count() 또는 __len__() 메소드를 갖고 있는 객체이어야 합니다.
- **per_page** : 페이지당 최대 항목 수
- **orphans** : 마지막 페이지에 넣을 수 있는 항목의 최소 개수. 디폴트는 0, 즉 마지막 페이지의 항목 개수는 orphans보다 커야 합니다. 이 인자는 마지막 페이지의 항목 개수가 너무 적은 경우, 그 전 페이지에 포함되도록 하기 위해 사용합니다. 예를 들어 총 23개 항목이 잇고 per_page=10, orphans=3 이라면, 첫 번째 페이지는 10개 항목을 두 번째 페이지는 13개 항목을 갖게 됩니다.
- **allow_empty_first_page** : 첫 페이지가 비어 있어도 되는지를 결정하는 boolean 타입 인자. 항목 개수가 0인 경우, 이 인자가 True이면 정상 처리를 하지만 이 인자가 False이면 EmptyPage 에러가 발생합니다.

#### 메소드(Method)
다음에 설명하는 Page 객체를, Paginator를 통해서 생성할 수 있도록 다음 메소드를 제공합니다.

- **Paginator.page(number)** : Page 객체를 반환합니다. number 인자는 1부터 시작합니다. 인자로 주어진 페이지가 존재하지 않으면 InvalidPage 예외가 발생합니다.

#### 속성(Attribute)

- **Paginator.count** : 항목의 총 개수
- **Paginator.num_pages** : 페이지의 총 개수
- **Paginator.page_range** : 1부터 시작하는 페이지 범위(예: [1,2,3,4])

### 15.5.3 Page 클래스
Paginator 객체에 의해 생성된 단위 페이지를 나타내는 객체로, Page 객체를 생성하는 방법은 생성자 메소드 호출보다는 Paginator.page() 메소드를 호출하는 방법을 더 많이 사용합니다.
```python
class Page(object_list, number, paginator)
```

#### 인자(Argument)

- **object_list** : Paginator 클래스의 object_list 인자와 동일합니다.
- **number** : 몇 번째 페이지인지를 지정하는 페이지 인덱스
- **paginator** : 페이지를 생성해주는 Paginator 객체

#### 메소드(Method)

- **Page.has_next()** : 다음 페이지가 있으면, True를 반환합니다.
- **Page.has_previous()** : 이전 페이지가 있느면, True를 반환합니다.
- **Page.has_other_pages()** : 다음 또는 이전 페이지가 있으면, True를 반환합니다.
- **Page.next_page_number** : 다음 페이지 번호를 반환합니다. 없으면 InvalidPage 예외가 발생합니다.
- **Page.previous_page_number** : 이전 페이지 번호를 반환합니다. 없으면 InvalidPage 예외가 발생합니다.
- **Page.start_index()** : 해당 페이지의 첫 번째 항목의 인덱스를 반환합니다. 인덱스는 1부터 카운트합니다. 예를 들어, 총 5개 항목이 있고 페이지당 2 항목씩 포함된다면, 두 번째 페이지의 start_index()는 3이 됩니다.
- **Page.end_index()** : 해당 페이지의 마지막 항목의 인덱스를 반환합니다. 인덱스는 1부터 카운트합니다. 예를 들어, 총 5개의 항목이 있고 페이지당 2 항목씩 포함된다면, 두 번째 페이지의 end_index는 4가 됩니다.

#### 속성(Attribute)

- **Page.object_list** : 현재 페이지의 객체 리스트
- **Page.number** : 현재 페이지의 번호(1부터 카운트합니다.)
- **Page.paginator** : 현재 페이지를 생성한 Paginator 객체

### 15.5.4 페이징 기능 실습
Paginator과 Page 클래스가 어떻게 페이징 기능을 제공하는지 실습해봅니다.

```
$ python manage.py shell
Python 3.5.2 (default, Apr 30 2017, 16:26:35)
[GCC 4.2.1 Compatible Apple LLVM 8.1.0 (clang-802.0.42)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)

# 먼저 처리 클래스인 Paginator를 임포트합니다.
>>> from django.core.paginator import Paginator

# 페이징 대상인 objects 객체는 4개의 항목을 갖고 있습니다.
>>> objects = ['john', 'paul', 'george', 'ringo']

# objects 객체를 대상으로 한 페이지에 2 항목을 갖는 Paginator 객체를 생성합니다.
>>> p = Paginator(objects, 2)

# Paginator 객체의 속성을 확인합니다.
>>> p.count
4
>>> p.num_pages
2
>>> p.page_range # 페이지 번호는 1부터 셉니다.
range(1, 3)

# 페이지별 처리를 위해 Page 객체를 생성합니다.
>>> page1 = p.page(1)
>>> page1
<Page 1 of 2>
>>> page1.object_list
['john', 'paul']

# Page 객체 page2를 생성합니다.
>>> page2 = p.page(2)
>>> page2.object_list
['george', 'ringo']
>>> page2.has_next()
False
>>> page2.has_previous()
True
>>> page2.has_other_pages()
True

# 페이지에 들어 있는 항목의 인덱스는 1부터 셉니다.
>>> page2.previous_page_number()
1
>>> page2.start_index()
3
>>> page2.end_index()
4

# 요청한 페이지가 유효하지 않으면 익셉션이 발생합니다.
# EmptyPage 및 PageNotAnInteger 익센셥은 InvalidPage 익셉션의 자식 클래스들입니다.
>>> p.page(0)
Traceback (most recent call last):
(중략)
django.core.paginator.EmptyPage: That page number is less than 1

>>> p.page(3)
Traceback (most recent call last):
(중략)
django.core.paginator.EmptyPage: That page contains no results

>>> p.page('a')
Traceback (most recent call last):
(중략)
django.core.paginator.PageNotAnInteger: That page number is not an integer

>>> page1.previous_page_number()
Traceback (most recent call last):
(중략)
django.core.paginator.EmptyPage: That page number is less than 1

>>> page2.next_page_number()
Traceback (most recent call last):
(중략)
django.core.paginator.EmptyPage: That page contains no results
```

## 15.6 단축 함수
### 15.6.1 render_to_response() 단축 함수
#### template_name (필수 인자)
#### context
#### context_instance
#### context_type
#### status
#### dirs
#### using

### render() 단축 함수
#### request (필수 인자)
#### current_app

### 15.6.3 redirect() 단축 함수
### 15.6.4 get_object_or_404() 단축 함수
### 15.6.5 get_list_or_404() 단축 함수
