---
layout: post
section-type: post
title: Two Scoops of django 3.x - Chap30. Signals. Use Cases and Avoidance Techniques
category: django
tags: [ 'django' ]
---

> [Two Scoops of Django 3.x](https://www.feldroy.com/books/two-scoops-of-django-3-x)
 
---

시그널 외에 대체 방법이 없을 때만 시그널을 사용해야 합니다.

시그널이 난무하게 되면 실타래처럼 되어버려서 각각의 시그널이 어떤 역할을 수행하는지 알기 어려워집니다.

셀러리가 제공하는 비동기 메시지 큐와 시그널을 혼동하기도 하는데, 시그널은 동기화되고 블로킹을 일으키는 무거운 프로세스를 호출하며, 확장과 성능 면에서도 그 어떤 장점도 없습니다. 오히려 코드의 복잡성만 올라가게 됩니다.

## 30.1 When to Use and Avoid Signals

- 시그널을 쓰면 안되는 경우
    - 시그널이 하나의 특별한 모델에 연관되어 있으며 모델 메서드 중 하나로 이전 가능할 때 `.save()`로 호출 가능한 경우
    - 커스텀 모델 매니저 메서드를 시그널 대신 이용할 수 있을 때
    - 특정 뷰에 연관된 시그널이 해당 뷰 안으로 이동될 수 있을 때
- 시그널을 이용해도 될 경우
    - 시그널의 리시버가 하나 이상의 모델을 변경할 때
    - 여러 개의 앱에서 발생한 한 종류의 시그널을 공통으로 이용되는 리시버로 받아 동일한 방법으로 처리할 때
    - 모델이 저장된 이후에 캐시를 지우고 싶을 때
    - 콜백이 필요하나 시그널을 제외하고는 이를 이용할 수 없는 특별한 경우
        - 서드파티 앱의 모델에서 `save()`나 `init()`에 기반을 둔 트리거를 이용하고 싶으나 해당 서드 파티의 코드를 수정할 수도, 확장할 수도 없는 경우
        - 이런 경우 트리거를 구성함으로써 콜백을 구현할 수있음

## 30.2 Signal Avoidance Techniques

시그널을 이용하지 않기 위한 기법

### 30.2.1 Using Custom Model Manager Methods Instead of Signals

시그널 대신 커스텀 모델 매니저 메서드 이용하기

커스텀 모델 매니저 메서드를 생성하고 이를 뷰에서 이용할 수 있습니다. 또한 관리자가 생성한 이벤트에 대해서는 리뷰 프로세스를 거치지 않도록 할 수 있습니다.

```python
# views.py
# 커스텀 매니저 구현
from django.db import models

class EventManager(models.Manager):
    def create_event(self, title, start, end, creator): 
        event = self.model(title=title,
                           start=start,
                           end=end,
                           creator=creator)
    event.save() 
    event.notify_admins() 
    return event

# models.py
# 구현한 커스텀매니저를 모델에 붙이기
from textwrap import dedent
from django.conf import settings
from django.core.mail import mail_admins 
from django.db import models
from model_utils.models import TimeStampedModel 
from .managers import EventManager

class Event(TimeStampedModel):
    class Status(models.IntegerChoices): 
        STATUS_UNREVIEWED = 0, "Unreviewed" 
        STATUS_REVIEWED = 1, "Reviewed"

    title = models.CharField(max_length=100)
    start = models.DateTimeField()
    end = models.DateTimeField()
    status = models.IntegerField(choices=Status.choices,
                                 default=Status.STATUS_UNREVIEWED) 
    creator = models.ForeignKey(settings.AUTH_USER_MODEL,
                                on_delete=models.CASCADE)

    objects = EventManager()

    def notify_admins(self):
        # 제목과 본문 메시지 생성
        subject = "{user} submitted a new event!".format(
        user=self.creator.get_full_name())
        message = dedentf"""TITLE: {self.title}
                    START: {self.start} 
                    END: {self.end}""")
        # Admin에 발송
        mail_admins(subject=subject, 
                    message=message,
                    fail_silently=False)

# cli
# 이벤트 생성시 create() 대신 create_event() 호출
>>> from django.contrib.auth import get_user_model
>>> from django.utils import timezone
>>> from events.models import Event
>>> user = get_user_model().objects.get(username="audreyr")
>>> now = timezone.now()
>>> event = Event.objects.create_event(
...     title="International Ice Cream Tasting Competition",
...     start=now,
...     end=now,
...     user=user
...     )
```

### 30.2.2 Validate Your Model Elsewhere

시그널을 통하지 않은 모델 검사

- `pre_save` 시그널을 이용하고 있었다면
    - 해당 필드에 대한 커스텀 유효성 검사기로 대체
- `ModelForm`을 통해 검사하고 있었다면
    - `clean()` 메서드를 오버라이딩하는 방법으로 대체

### 30.2.3 Override Your Model's Save or Delete Method Instead

모델의 save나 delete 메서드를 오버라이딩하기

- 특정 모델에 대한 `pre_save` / `post_save` 시그널을 이용하고 있었다면
    - 모델의 `save()` 메서드로 이전할 수 있다.
- `pre_delete` / `post_delete` 시그널의 경우
    - `delete()`를 오버라이딩할 수 있다.

### 30.2.4 Use a Helper Function Instead of Signals

시그널 대신 헬퍼 함수 이용하기

- 시그널 대신 헬퍼 함수를 이용하면 유용한 상황
    - 리팩터링
        - 시그널로 인해 너무 난해해지지 않기 원한다면
    - 아키텍처
        - 모델이 너무 무거워져서 코드를 위한 또다른 공간이 필요하여 시그널을 이용하기도 한다.
        - 하지만 거대 모델 방식이 유용하다 해도 500라인 또는 2000라인의 코드를 파싱하고 처리하는것은 피하고 싶다면

헬퍼 함수는 코드를 좀 더 깔끔하고 재사용 가능한 형태가 되도록 만드는데 도움이 됩니다.

- 시그널로부터 헬퍼 함수로 이전하는 과정과 테스트
    1. 기존 시그널 호출에 대한 테스트 케이스를 작성한다.
    2. 기존 시그널 호출에 대해 비즈니스 로직이 별도의 함수에 구현되어 있다면 이 비즈니스 로직에 대해서도 테스트 케이스를 작성한다.
    3. 시그널의 비즈니스 로직을 그대로 구현한 헬퍼 함수를 작성한다. 두 번째 단계로부터 작성된 테스트 코드의 assertion과 그대로 매치되는 테스트 케이스를 작성한다.
    4. 테스트를 실행한다.
    5. 시그널로부터 헬퍼 함수를 호출한다.
    6. 테스트를 다시 한 번 실행한다.
    7. 시그널을 제거하고 헬퍼 함수를 적절한 곳으로부터 다시 호출한다.
    8. 테스트를 한 번 더 실행한다.
    9. 코드를 정리하고 문제가 없을 때까지 절차를 반복한다.

## 30.3 Summary

시그널은 매우 강력한 도구이지만, 오용되기 쉽기 때문에 언제 어떻게 사용해야 하는지 연구하는 절차가 필요합니다.
