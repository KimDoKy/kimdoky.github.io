I"f<blockquote>
  <p><a href="https://docs.djangoproject.com/en/2.2/ref/models/querysets/#django.db.models.query.QuerySet.values">Django QuerySet Api reference</a></p>
</blockquote>

<hr />

<p>한 번쯤은 쿼리셋 부분의 공식 문서를 정독해야겠다는 생각을 이제서야 실천한다..</p>

<hr />

<h1 id="queryset이-평가되는-경우">QuerySet이 평가되는 경우</h1>

<p>Django에서 QuerySet이 평가될 때까지 실제로 데이터베이스 활동이 발생하지 않기 때문에, 데이터베이스에 충돌하지 않고 필터링, 슬라이스 등을 할 수 있다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">iteration</code>. QuerySet은 반복 가능하며, 처음 반복할 때 데이터베이스 쿼리를 실행한다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">all</span><span class="p">():</span>
  <span class="n">pritn</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">headline</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">slicing</code>. QuerySet은 파이썬의 배열 슬라이싱 구문을 사용하여 자를 수 있다. Django는 슬라이스 구문의 ‘step’ 매개 변수를 사용하면 데이터베이스 쿼리를 실행하고 목록을 반환한다. 평가된 QuerySet을 슬라이싱하면 목록도 반환된다.</li>
</ul>

<p>평가되지 않은 QuerySet을 자르면 또 다른 평가되지 않은 QuerySet을 반환하더라고, SQL으로 잘 변환도 안되고, 명확한 의미를 가지지 않기 떄문에 추가로 수정하는 것은 허용하지 않는다.</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">pickling/caching</code>. <a href="https://docs.djangoproject.com/en/2.2/ref/models/querysets/#pickling-querysets">pickling QuerySets</a> 참조.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">repr()</code>. QuerySet은 <code class="language-plaintext highlighter-rouge">repr()</code>를 콜할때 평가된다. 이건 파이썬 인터프리터를 위한 것이로, API를 인터프리터로 사용할 때 즉시 결과를 볼 수 있다.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">len()</code>. QuerySet은 <code class="language-plaintext highlighter-rouge">len()</code>을 콜할때 평가된다. 결과 목록의 길이를 반환한다.<br />
레코드 갯수만 가져오는 것이라면 <code class="language-plaintext highlighter-rouge">SELECT COUNT(*)</code>이 훨씬 효율적이다.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">list()</code>. <code class="language-plaintext highlighter-rouge">list()</code>를 사용하여 QuerySet을 강제로 평가할 수 있다.</p>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">entry_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">all</span><span class="p">())</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">bool()</code>. <code class="language-plaintext highlighter-rouge">bool()</code>을 사용하여 QuerySet을 테스트하면 쿼리가 실행된다. 결과가 하나 이상이면 True, 그렇지 않으면 False를 반환한다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">headline</span><span class="o">=</span><span class="s">'Test'</span><span class="p">):</span>
  <span class="k">print</span><span class="p">(</span><span class="s">"There is at least one Entry with the headline Test"</span><span class="p">)</span>
</code></pre></div></div>

<h1 id="pickling-querysets">Pickling QuerySets</h1>

<ul>
  <li>Pickle은 파이썬 객체 구조를 직렬화/역직렬화 할 때 사용한다. <a href="https://pythontips.com/2013/08/02/what-is-pickle-in-python/">참조: What is Pickle in python?</a></li>
</ul>

<p>QuerySet을 선택하면 pickle라기 전에 모든 결과를 메모리에 로드한다. Pickling은 보통 캐싱 전에 사용되며, 캐싱된 QuerySet을 다시 로드하면 결과가 이미 존재하여 사용할 수 있도록 준비하길 원한다.(데이터베이스에서 읽는 것은 캐싱의 목적에 어긋나소 다소 시간이 소요된다.) 즉 QuerySet을 풀 때는 현재의 데이터베이스의 데이터가 아니라 QuerySet을 Pickling 한 순간의 결과이다.</p>

<p>나중에 데이터베이스에서 QuerySet을 재생성할때 필요한 정보만 선택하려면 QuerySet의 쿼리 속성을 선택하면된다. 그후에 다음과 같은 일부 코드를 사용하여 QuerySet(결과가 로드되지 않은)을 재생성할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">pickle</span>
<span class="n">query</span> <span class="o">=</span> <span class="n">pickle</span><span class="p">.</span><span class="n">loads</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c1"># pickling된 문자열
</span><span class="n">qs</span> <span class="o">=</span> <span class="n">MyModel</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">all</span><span class="p">()</span>
<span class="n">qs</span><span class="p">.</span><span class="n">query</span> <span class="o">=</span> <span class="n">query</span>     <span class="c1"># 복구된 원래 쿼리
</span></code></pre></div></div>

<blockquote>
  <p>pickle은 django의 버전이 다를때 호환성을 보장하지 않는다.</p>
</blockquote>

<h1 id="queryset-api">QuerySet API</h1>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">QuerySet</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">using</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">hits</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</code></pre></div></div>

<p>보통 QuerySet을 사용할때 <code class="language-plaintext highlighter-rouge">filter()</code>를 여려개 연결하여 새로운 QuerySet을 생성한다.</p>

<p>QuerySet 클래스에는 두 가지 특성이 있다.</p>

<ul>
  <li>
    <p><strong>ordered</strong>: QuerySet이 정렬되어 있다면 True를 반환. QuerySet에 <code class="language-plaintext highlighter-rouge">order_by()</code>가 되었는지를 판단한다.</p>
  </li>
  <li>
    <p><strong>db</strong>: 현재 QuerySet이 사용하는 DB의 정보를 반환한다.</p>
  </li>
</ul>

<h1 id="새-queryset을-반환하는-함수들">새 QuerySet을 반환하는 함수들</h1>

<h3 id="filter"><code class="language-plaintext highlighter-rouge">filter()</code></h3>

<p>지정된 매개 변수와 일치하는 객체를 포함한 QuerySet을 반환한다.</p>

<h3 id="exclude"><code class="language-plaintext highlighter-rouge">exclude()</code></h3>

<p>지정된 매개 변수와 일치하지 않는 객체를 포함한 QuerySet을 반환한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># pub_date가 2005-1-3 이후이고 headline이 'Hello'인 모든 항목을 제외
</span><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">exclude</span><span class="p">(</span><span class="n">pub_date__gt</span><span class="o">=</span><span class="n">datetime</span><span class="p">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">headline</span><span class="o">=</span><span class="s">'Hello'</span><span class="p">)</span>

<span class="c1"># SQL
</span><span class="n">SELECT</span> <span class="o">*</span>
<span class="n">WHERE</span> <span class="n">NOT</span> <span class="p">(</span><span class="n">pub_date</span> <span class="o">&gt;</span> <span class="s">'2005-1-3'</span> <span class="n">AND</span> <span class="n">headlint</span> <span class="o">=</span> <span class="s">'Hello'</span><span class="p">)</span>

<span class="c1"># pub_date가 2005-1-3이후이거나 headline이 'Hello'인 모든 항목을 제외
</span><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">exclude</span><span class="p">(</span><span class="n">pub_date__gt</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)).</span><span class="n">exclude</span><span class="p">(</span><span class="n">headline</span><span class="o">=</span><span class="s">'Hello'</span><span class="p">)</span>

<span class="c1"># SQL
</span><span class="n">SELECT</span> <span class="o">*</span>
<span class="n">WHERE</span> <span class="n">NOT</span> <span class="n">pub_date</span> <span class="o">&gt;</span> <span class="s">'2005-1-3'</span>
<span class="n">AND</span> <span class="n">NOT</span> <span class="n">headline</span> <span class="o">=</span> <span class="s">'Hello'</span>
</code></pre></div></div>

<h3 id="annotate"><code class="language-plaintext highlighter-rouge">annotate()</code></h3>

<p><code class="language-plaintext highlighter-rouge">annotate()</code>의 각 인수는 QuerySet의 각 객체에 추가 될 주석이다. 각 주석은 단순한 값, 모델의 필드에 대한 참조, QuerySet의 각 객체와 관련된 집계(averages, sums 등)이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">Count</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q</span> <span class="o">=</span>  <span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">Count</span><span class="p">(</span><span class="s">'entry'</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">name</span>    <span class="c1"># 첫 블로그의 이름
</span><span class="s">'Blogasaurus'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">entry__count</span>  <span class="c1"># 첫 블로그의 항목 수
</span><span class="mi">42</span>

<span class="c1"># 키워드 인수를 사용하여 집계 함수를 지정함으로 주석의 이름을 제어할 수 있다.
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">number_or_entries</span><span class="o">=</span><span class="n">Count</span><span class="p">(</span><span class="s">'entry'</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">number_or_entries</span>
<span class="mi">42</span>
</code></pre></div></div>

<h3 id="order_by"><code class="language-plaintext highlighter-rouge">order_by()</code></h3>

<p>정렬 기준을 재정의한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2005</span><span class="p">).</span><span class="n">order_by</span><span class="p">(</span><span class="s">'-pub_date'</span><span class="p">,</span> <span class="s">'headline'</span><span class="p">)</span>
</code></pre></div></div>
<p>무작위로 정렬하려면 ‘?’를 지정하면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">'?'</span><span class="p">)</span>
<span class="c1"># 사용 중인 DB 백엔드에 따라 비싸고 느릴수 있다.
</span></code></pre></div></div>

<p>다른 모델의 필드를 기준으로 정렬하려면, 이중 언더바(<code class="language-plaintext highlighter-rouge">__</code>)를 사용한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">'blog__name'</span><span class="p">,</span> <span class="s">'headline'</span><span class="p">)</span>
</code></pre></div></div>

<p>다른 모델과의 관계인 필드를 기준으로 주문하려 하면, Django는 관련 모델의 기본 순을 정렬하거나, Meta.ordering이 지정되지 않으면 모델의 기본 키를 기준으로 한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 순서가 지정되지 않은 경우
</span><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">'blog'</span><span class="p">)</span>


<span class="c1"># 위 코드는 아래와 같아
</span><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">'blog__id'</span><span class="p">)</span>

<span class="c1"># name 순으로 정렬할 경우
</span><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">'blog__name'</span><span class="p">)</span>

<span class="c1"># asc()나 desc()를 사용해 순서를 지정할 수 있다.
</span><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">Coalesce</span><span class="p">(</span><span class="s">'summary'</span><span class="p">,</span> <span class="s">'headline'</span><span class="p">).</span><span class="n">desc</span><span class="p">())</span>

<span class="c1"># asc(), desc()는 null 값이 정렬되는 방법을 제어하는 인수(nulls_first, nulls_last)를 가지고 있다.
</span></code></pre></div></div>

<p>다중값 필드를 지정하여 정렬할 수 있다(MTM, ForeignKey의 역관계)</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Event</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
  <span class="n">parent</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="n">ForeignKey</span><span class="p">(</span>
      <span class="s">'self'</span><span class="p">,</span>
      <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="p">.</span><span class="n">CASCADE</span><span class="p">,</span>
      <span class="n">related_name</span><span class="o">=</span><span class="s">'children'</span>
  <span class="p">)</span>
  <span class="n">date</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="n">DateField</span><span class="p">()</span>

<span class="n">Event</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">'children__date'</span><span class="p">)</span>
</code></pre></div></div>
<p>각 이벤트에 잠재적으로 여러 주문 데이터가 있을 경우 새 QuerySet이 여러번 반환된다. 그렇기 때문에 다중값 필드를 사용하여 결과를 정렬할 때는 주의해야 한다.</p>

<p><code class="language-plaintext highlighter-rouge">Lower</code>으로 대소문자를 구분하여 정렬할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">Lower</span><span class="p">(</span><span class="s">'headline'</span><span class="p">).</span><span class="n">desc</span><span class="p">())</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">QuerySet.ordered</code>를 사용하면 QeurySet이 어떤 방식이든 정렬된 경우에는 True를 반환한다.</p>

<p><code class="language-plaintext highlighter-rouge">order_by()</code>가 여러 번 선언되어 있다면, 맨마지막꺼만 유효하다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># headline은 무시되고, pub_date 기준으로 정렬된다.
</span><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">'headline'</span><span class="p">).</span><span class="n">order_by</span><span class="p">(</span><span class="s">'pub_date'</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <p>정렬에 추가한 각 필드는 DB 비용이 발생한다. 외래키도 암시적으로 포함된다.</p>
</blockquote>

<h3 id="reverse"><code class="language-plaintext highlighter-rouge">reverse()</code></h3>

<p>역순으로 반환한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 마지막 5개 항목
</span><span class="n">my_queryset</span><span class="p">.</span><span class="n">reverse</span><span class="p">()[:</span><span class="mi">5</span><span class="p">]</span>
</code></pre></div></div>

<p>파이썬의 <code class="language-plaintext highlighter-rouge">seq[-5:]</code>와 같은 기능이지만, SQL에서는 효율적으로 할 수 없기 때문에(끝에서 슬라이싱하는) Django는 엑세스 모드를 지원하지 않는다.</p>

<p><code class="language-plaintext highlighter-rouge">reverse()</code>는 QuerySet이 순서가 정의되어 있을 때만 효과가 있다(기본 순서를 정의하는 모델에 대해 쿼리할때, 또는 <code class="language-plaintext highlighter-rouge">order_by()</code>를 사용할때). 정의된 순서가 없는 경우 효과가 없다.</p>

<h3 id="distinct"><code class="language-plaintext highlighter-rouge">distinct()</code></h3>

<p><code class="language-plaintext highlighter-rouge">SELECT DISTINCT</code>를 사용하는 QuerySet을 반환한다. 쿼리 결과에 중복행을 제거한다.</p>

<p>QuerySet은 기본적으로 중복 행을 제거하지 않지만, 쿼리가 여러 테이블에 걸쳐 있는 경우 중복된 결과를 얻을 수 있다. 그런 경우 <code class="language-plaintext highlighter-rouge">distinct()</code>를 사용한다.</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">order_by()</code>에서 사용된 필드는 SQL <code class="language-plaintext highlighter-rouge">SELECT</code>열에 포함되어 있기 때문에, <code class="language-plaintext highlighter-rouge">distinct()</code>과 함께 사용될 경우 예상치 못한 결과를 초래할 수 있다.<br />
관련 모델의 필드별로 정렬하면 해당 필드는 SELECT 열에 추가되지 않아서 중복 행이 구별된 것처럼 보일 수 있다. 추가 행은 반환된 결과에는 나타나지 않기 때문에, 뚜렷하지 않은 결과가 반환되는 것처럼 보인다.<br />
선택한 열을 제한하기 위해서 <code class="language-plaintext highlighter-rouge">values()</code>를 사용할 경우, <code class="language-plaintext highlighter-rouge">order_by()</code>안에 사용된 열이나 기본 모델 순서에서 사용되는 열이 여전히 연관되어 있어, 결과의 고유성에 영향을 미친다.<br />
<code class="language-plaintext highlighter-rouge">distinct()</code>을 사용하려면 <strong>관련 모델에 의한 정렬</strong> 에 주의해야 한다. <code class="language-plaintext highlighter-rouge">distinct()</code>와 <code class="language-plaintext highlighter-rouge">values()</code>를 한께 사용할 때는 <code class="language-plaintext highlighter-rouge">values()</code> 호출에 없는 필드도 주의해야 한다.</p>
</blockquote>

<p>PostgreSQL을 사용할때는 DISTINCT를 적용할 필드를 지정하기 위해 위치 인수(<code class="language-plaintext highlighter-rouge">*fields</code>)를 전달할 수 있다.<br />
일반적으로 <code class="language-plaintext highlighter-rouge">distinct()</code>를 사용하면 DB는 각 행의 각 필드를 비교하지만, 지정된 필드가 있다면, DB는 지정된 필드만 비교한다.</p>

<p>필드를 지정할 때 QuerySet에 <code class="language-plaintext highlighter-rouge">order_by()</code>를 사용해야 하며, <code class="language-plaintext highlighter-rouge">order_by()</code>의 필드는 같은 순서로 필드를 시작해야 한다.</p>

<p>예를 들어 <code class="language-plaintext highlighter-rouge">SELECT DISTINCT ON(a)</code>은 a열의 각 값에 대한 첫번째 행을 제공한다. 순서를 지정하지 않으면 임의의 행이 제공된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Author</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">distinct</span><span class="p">()</span>
<span class="p">[...]</span>

<span class="c1"># 여기부터는 PostgreSQL에서만 동작한다.
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">'pub_date'</span><span class="p">).</span><span class="n">distinct</span><span class="p">(</span><span class="s">'pub_date'</span><span class="p">)</span>
<span class="p">[...]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">'blog'</span><span class="p">).</span><span class="n">distinct</span><span class="p">(</span><span class="s">'blog'</span><span class="p">)</span>
<span class="p">[...]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">'author'</span><span class="p">,</span> <span class="s">'pub_date'</span><span class="p">).</span><span class="n">distinct</span><span class="p">(</span><span class="s">'author'</span><span class="p">,</span> <span class="s">'pub_date'</span><span class="p">)</span>
<span class="p">[...]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">'blog__name'</span><span class="p">,</span> <span class="s">'mod_date'</span><span class="p">).</span><span class="n">distinct</span><span class="p">(</span><span class="s">'blog__name'</span><span class="p">,</span> <span class="s">'mod_date'</span><span class="p">)</span>
<span class="p">[...]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">'author'</span><span class="p">,</span> <span class="s">'pub_date'</span><span class="p">).</span><span class="n">distinct</span><span class="p">(</span><span class="s">'author'</span><span class="p">)</span>
<span class="p">[...]</span>
</code></pre></div></div>

<blockquote>
  <p>DISTINCT ON 식이 ORDER BY 구문의 시작 부분과 일치하는지 확인하려면 <code class="language-plaintext highlighter-rouge">__id</code>나 참조 필드를 기준으로 명시적으로 정렬해야 한다.</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Blog 모델이 name 기준으로 정렬할 경우
</span><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">'blog'</span><span class="p">).</span><span class="n">distinct</span><span class="p">(</span><span class="s">'blog'</span><span class="p">)</span>
</code></pre></div></div>

<p>쿼리가 <code class="language-plaintext highlighter-rouge">blog__name</code>으로 정렬되어 DISTINCT ON 식과 일치하지 않기 때문에 작동하지 않을 것이다.</p>

<p><code class="language-plaintext highlighter-rouge">관계_id</code>(blog_id)나 참조된 필드(blog_pk)를 명시하여 두 식이 일치하는지 확인해야 한다.</p>

<h3 id="values"><code class="language-plaintext highlighter-rouge">values()</code></h3>

<p>dict를 반환하는 QuerySet을 반환한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">name__startswith</span><span class="o">=</span><span class="s">'Beatles'</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">Blog</span><span class="p">:</span> <span class="n">Beatles</span> <span class="n">Blog</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">name__startswith</span><span class="o">=</span><span class="s">'Beatles'</span><span class="p">).</span><span class="n">values</span><span class="p">()</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[{</span><span class="s">'id'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'name'</span><span class="p">:</span> <span class="s">'Beatles Blog'</span><span class="p">,</span> <span class="s">'tagline'</span><span class="p">:</span> <span class="s">'All the latest Beatles news.'</span><span class="p">}]</span><span class="o">&gt;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">values()</code>는 선택적 위치 인수를 사용하며, SELECT가 제한되어야 하는 필드 이름을 지정할 수 있다. 필드를 지정하면 지정한 필드에 대한 필드의 키/값만 들어간다. 필드를 지정하지 않으면 DB 테이블의 모든 필드에 대한 키/값이 들어간다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">values</span><span class="p">()</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[{</span><span class="s">'id'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'name'</span><span class="p">:</span> <span class="s">'Beatles Blog'</span><span class="p">,</span> <span class="s">'tagline'</span><span class="p">:</span> <span class="s">'All the latest Beatles news.'</span><span class="p">}]</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">values</span><span class="p">(</span><span class="s">'id'</span><span class="p">,</span> <span class="s">'name'</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[{</span><span class="s">'id'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'name'</span><span class="p">:</span> <span class="s">'Beatles Blog'</span><span class="p">}]</span><span class="o">&gt;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">values()</code> 인자로 표현식을 넣을 수 있으며, 아래 코드는 키를 주석으로 교체한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">django.db.models.functions</span> <span class="kn">import</span> <span class="n">Lower</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">values</span><span class="p">(</span><span class="n">lower_name</span><span class="o">=</span><span class="n">Lower</span><span class="p">(</span><span class="s">'name'</span><span class="p">))</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[{</span><span class="s">'lower_name'</span><span class="p">:</span> <span class="s">'beatles blog'</span><span class="p">}]</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>built_in과 custom lookup을 사용할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">CharField</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">django.db.models.functions</span> <span class="kn">import</span> <span class="n">Lower</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">CharField</span><span class="p">.</span><span class="n">register_lookup</span><span class="p">(</span><span class="n">Lower</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">values</span><span class="p">(</span><span class="s">'name__lower'</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[{</span><span class="s">'name__lower'</span><span class="p">:</span> <span class="s">'beatles blog'</span><span class="p">}]</span><span class="o">&gt;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">values()</code>의 aggregate는 동일한 <code class="language-plaintext highlighter-rouge">values()</code>내의 다른 인수보다 먼저 적용된다. 다른 값으로 그룹화해야 하는 경우, <code class="language-plaintext highlighter-rouge">values()</code>의 인자에 추가해야 한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">Count</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">values</span><span class="p">(</span><span class="s">'entry__authors'</span><span class="p">,</span> <span class="n">entries</span><span class="o">=</span><span class="n">Count</span><span class="p">(</span><span class="s">'entry'</span><span class="p">))</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[{</span><span class="s">'entry__authors'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'entries'</span><span class="p">:</span> <span class="mi">20</span><span class="p">},</span> <span class="p">{</span><span class="s">'entry__authors'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'entries'</span><span class="p">:</span> <span class="mi">13</span><span class="p">}]</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">values</span><span class="p">(</span><span class="s">'entry__authors'</span><span class="p">).</span><span class="n">annotate</span><span class="p">(</span><span class="n">entries</span><span class="o">=</span><span class="n">Count</span><span class="p">(</span><span class="s">'entry'</span><span class="p">))</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[{</span><span class="s">'entry__authors'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'entries'</span><span class="p">:</span> <span class="mi">33</span><span class="p">}]</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>‘Foo’라는 필드가 ForeignKey인 경우, ‘foo_id’라는 사전 키를 반환하는데, 실제 모델 속성의 이름이다.<br />
<code class="language-plaintext highlighter-rouge">value()</code>를 호출하고 필드 이름을 입력할때 ‘foo’나 ‘foo_id’를 입력하면 동일한 항목을 반환한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">values</span><span class="p">()</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[{</span><span class="s">'blog_id'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'headline'</span><span class="p">:</span> <span class="s">'First Entry'</span><span class="p">,</span> <span class="p">...},</span> <span class="p">...]</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">values</span><span class="p">(</span><span class="s">'blog'</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[{</span><span class="s">'blog'</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="p">...]</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">values</span><span class="p">(</span><span class="s">'blog_id'</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[{</span><span class="s">'blog_id'</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="p">...]</span><span class="o">&gt;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">values()</code>와 <code class="language-plaintext highlighter-rouge">distinct()</code>를 값이 사용하면 순서가 결과에 영향을 미친다.</li>
  <li><code class="language-plaintext highlighter-rouge">extra()</code>를 호출한 후 <code class="language-plaintext highlighter-rouge">values()</code>를 사용하면, <code class="language-plaintext highlighter-rouge">extra()</code>의 선택 인수에 의해 정의된 필드를 <code class="language-plaintext highlighter-rouge">values()</code> 호출에 명시적으로 포함해야 한다.</li>
  <li><code class="language-plaintext highlighter-rouge">values()</code> 호출 후에 <code class="language-plaintext highlighter-rouge">extra()</code>를 사용하면 선택도니 추가 필드는 무시된다.</li>
  <li><code class="language-plaintext highlighter-rouge">values()</code> 뒤에 <code class="language-plaintext highlighter-rouge">only()</code>, <code class="language-plaintext highlighter-rouge">defer()</code>를 호툴하는 것은 무의미하므로 **NotImplementedError를 발생시칸다.</li>
  <li>변환과 집계를 겹합하려면 두 개의 <code class="language-plaintext highlighter-rouge">annotate()</code> 호출을 하거나, <code class="language-plaintext highlighter-rouge">values()</code>에 키워드 인수로 사용해야 한다. 변환이 관련 필드에 등록된 경우 첫 번째 <code class="language-plaintext highlighter-rouge">annotate()</code>는 생략할 수 있다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">CharField</span><span class="p">,</span> <span class="n">Count</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">django.db.models.functions</span> <span class="kn">import</span> <span class="n">Lower</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">CharField</span><span class="p">.</span><span class="n">register_lookup</span><span class="p">(</span><span class="n">Lower</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">values</span><span class="p">(</span><span class="s">'entry__authors__name__lower'</span><span class="p">).</span><span class="n">annotate</span><span class="p">(</span><span class="n">entries</span><span class="o">=</span><span class="n">Count</span><span class="p">(</span><span class="s">'entry'</span><span class="p">))</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[{</span><span class="s">'entry__authors__name__lower'</span><span class="p">:</span> <span class="s">'test author'</span><span class="p">,</span> <span class="s">'entries'</span><span class="p">:</span> <span class="mi">33</span><span class="p">}]</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">values</span><span class="p">(</span>
<span class="p">...</span>     <span class="n">entry__authors__name__lower</span><span class="o">=</span><span class="n">Lower</span><span class="p">(</span><span class="s">'entry__authors__name'</span><span class="p">)</span>
<span class="p">...</span> <span class="p">).</span><span class="n">annotate</span><span class="p">(</span><span class="n">entries</span><span class="o">=</span><span class="n">Count</span><span class="p">(</span><span class="s">'entry'</span><span class="p">))</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[{</span><span class="s">'entry__authors__name__lower'</span><span class="p">:</span> <span class="s">'test author'</span><span class="p">,</span> <span class="s">'entries'</span><span class="p">:</span> <span class="mi">33</span><span class="p">}]</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">annotate</span><span class="p">(</span>
<span class="p">...</span>     <span class="n">entry__authors__name__lower</span><span class="o">=</span><span class="n">Lower</span><span class="p">(</span><span class="s">'entry__authors__name'</span><span class="p">)</span>
<span class="p">...</span> <span class="p">).</span><span class="n">values</span><span class="p">(</span><span class="s">'entry__authors__name__lower'</span><span class="p">).</span><span class="n">annotate</span><span class="p">(</span><span class="n">entries</span><span class="o">=</span><span class="n">Count</span><span class="p">(</span><span class="s">'entry'</span><span class="p">))</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[{</span><span class="s">'entry__authors__name__lower'</span><span class="p">:</span> <span class="s">'test author'</span><span class="p">,</span> <span class="s">'entries'</span><span class="p">:</span> <span class="mi">33</span><span class="p">}]</span><span class="o">&gt;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">values()</code> 호출 후에 <code class="language-plaintext highlighter-rouge">filter()</code>, <code class="language-plaintext highlighter-rouge">order_by()</code> 등을 호출할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 둘은 동일하다.
</span><span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">values</span><span class="p">().</span><span class="n">order_by</span><span class="p">(</span><span class="s">'id'</span><span class="p">)</span>
<span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">'id'</span><span class="p">).</span><span class="n">values</span><span class="p">()</span>
</code></pre></div></div>

<p><strong>OneToOneField</strong>, <strong>ForeignKey</strong>, <strong>ManyToManyField</strong> 속성을 통해 역관계가 있는 관련 모델을 참조할 수도 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">values</span><span class="p">(</span><span class="s">'name'</span><span class="p">,</span> <span class="s">'entry__headline'</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[{</span><span class="s">'name'</span><span class="p">:</span> <span class="s">'My blog'</span><span class="p">,</span> <span class="s">'entry__headline'</span><span class="p">:</span> <span class="s">'An entry'</span><span class="p">},</span>
     <span class="p">{</span><span class="s">'name'</span><span class="p">:</span> <span class="s">'My blog'</span><span class="p">,</span> <span class="s">'entry__headline'</span><span class="p">:</span> <span class="s">'Another entry'</span><span class="p">},</span> <span class="p">...]</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>MTM 등 역관계가 있는 하나의 필드에 여러 데이터가 포함될 수 있기 때문에 <code class="language-plaintext highlighter-rouge">values()</code>를 사용하면 너무 큰 결과를 반환할 수도 있다.</p>

<h3 id="values_list"><code class="language-plaintext highlighter-rouge">values_list()</code></h3>

<p>Tuple를 반환하는 QuerySet을 반환한다. 그외에는 <code class="language-plaintext highlighter-rouge">values()</code>와 동일하다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">values_list</span><span class="p">(</span><span class="s">'id'</span><span class="p">,</span> <span class="s">'headline'</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="s">'First entry'</span><span class="p">),</span> <span class="p">...]</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">django.db.models.functions</span> <span class="kn">import</span> <span class="n">Lower</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">values_list</span><span class="p">(</span><span class="s">'id'</span><span class="p">,</span> <span class="n">Lower</span><span class="p">(</span><span class="s">'headline'</span><span class="p">))</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="s">'first entry'</span><span class="p">),</span> <span class="p">...]</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>단일 필드만 지정하는 경우, <code class="language-plaintext highlighter-rouge">flat</code> 매개 변수로 전달 할 수도 있다. True리면 반환된 결과가 튜플이 아닌 단일 값임을 의미한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">values_list</span><span class="p">(</span><span class="s">'id'</span><span class="p">).</span><span class="n">order_by</span><span class="p">(</span><span class="s">'id'</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">QuerySet</span><span class="p">[(</span><span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,),</span> <span class="p">...]</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">values_list</span><span class="p">(</span><span class="s">'id'</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="bp">True</span><span class="p">).</span><span class="n">order_by</span><span class="p">(</span><span class="s">'id'</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">...]</span><span class="o">&gt;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">named=True</code>를 전달하면, <code class="language-plaintext highlighter-rouge">namedtuple()</code> 결과를 얻을 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">values_list</span><span class="p">(</span><span class="s">'id'</span><span class="p">,</span> <span class="s">'headline'</span><span class="p">,</span> <span class="n">named</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[</span><span class="n">Row</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">headline</span><span class="o">=</span><span class="s">'First entry'</span><span class="p">),</span> <span class="p">...]</span><span class="o">&gt;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">values_list()</code>에 인자를 넣지 않으면 선언 된 순서대로 모델의 모든 필드가 반환된다.</p>

<p>특정 필드의 값을 얻으려면 <code class="language-plaintext highlighter-rouge">get()</code>을 호출해야 한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">values_list</span><span class="p">(</span><span class="s">'headline'</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="bp">True</span><span class="p">).</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="s">'First entry'</span>
</code></pre></div></div>

<p>더블언더바로 MTM도 참조할 수 있다. 필드에 값이 없는 경우 None을 반환한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Author</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">values_list</span><span class="p">(</span><span class="s">'name'</span><span class="p">,</span> <span class="s">'entry__headline'</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[(</span><span class="s">'Noam Chomsky'</span><span class="p">,</span> <span class="s">'Impressions of Gaza'</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'George Orwell'</span><span class="p">,</span> <span class="s">'Why Socialists Do Not Believe in Fun'</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'George Orwell'</span><span class="p">,</span> <span class="s">'In Defence of English Cooking'</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'Don Quixote'</span><span class="p">,</span> <span class="bp">None</span><span class="p">)]</span><span class="o">&gt;</span>
</code></pre></div></div>

<h3 id="dates"><code class="language-plaintext highlighter-rouge">dates()</code></h3>

<p>날짜를 나타내는 필드를 <code class="language-plaintext highlighter-rouge">datetime.date</code> 객체 리스트로 평가되는 QuerySet을 반환한다. 각 필드는 <code class="language-plaintext highlighter-rouge">datetime.date</code> 객체 유형이어야 한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dates(field, kind, order='ASC')
</code></pre></div></div>

<ul>
  <li>field: 모델의 DateField 필드 이름을 지정한다.</li>
  <li>kind: ‘year’, ‘month’, ‘week’, ‘day’ 중 하나를 선택한다.</li>
  <li>order: 기본값은 ‘ASC’이다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">dates</span><span class="p">(</span><span class="s">'pub_date'</span><span class="p">,</span> <span class="s">'year'</span><span class="p">)</span>
<span class="p">[</span><span class="n">datetime</span><span class="p">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">dates</span><span class="p">(</span><span class="s">'pub_date'</span><span class="p">,</span> <span class="s">'month'</span><span class="p">)</span>
<span class="p">[</span><span class="n">datetime</span><span class="p">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">datetime</span><span class="p">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">dates</span><span class="p">(</span><span class="s">'pub_date'</span><span class="p">,</span> <span class="s">'week'</span><span class="p">)</span>
<span class="p">[</span><span class="n">datetime</span><span class="p">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">14</span><span class="p">),</span> <span class="n">datetime</span><span class="p">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">14</span><span class="p">)]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">dates</span><span class="p">(</span><span class="s">'pub_date'</span><span class="p">,</span> <span class="s">'day'</span><span class="p">)</span>
<span class="p">[</span><span class="n">datetime</span><span class="p">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">datetime</span><span class="p">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">20</span><span class="p">)]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">dates</span><span class="p">(</span><span class="s">'pub_date'</span><span class="p">,</span> <span class="s">'day'</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">'DESC'</span><span class="p">)</span>
<span class="p">[</span><span class="n">datetime</span><span class="p">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">datetime</span><span class="p">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="p">)]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s">'Lennon'</span><span class="p">).</span><span class="n">dates</span><span class="p">(</span><span class="s">'pub_date'</span><span class="p">,</span> <span class="s">'day'</span><span class="p">)</span>
<span class="p">[</span><span class="n">datetime</span><span class="p">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">20</span><span class="p">)]</span>
</code></pre></div></div>

<h3 id="datetimes"><code class="language-plaintext highlighter-rouge">datetimes()</code></h3>

<p>날짜를 나타내는 필드를 <code class="language-plaintext highlighter-rouge">datetime.datetime</code> 객체 리스트로 평가되는 QuerySet을 반환한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">datetimes</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">'ASC'</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>field_name: 모델의 DateTimeField의 이름을 지정해야 한다.</li>
  <li>kind: ‘year’, ‘month’, ‘week’, ‘day’, ‘hour’, ‘minute’, ‘second’ 중에 선택하여 지정한다.</li>
  <li>order: <code class="language-plaintext highlighter-rouge">dates()</code>와 동일하다.</li>
  <li>tzinfo: 시간대를 정의한다. 매개변수는 datetime.tzinfo 객체이어야 한다. 그렇지 않으면 Django의 시간대를 사용하고, <code class="language-plaintext highlighter-rouge">USE_TZ</code>가 False이면 효과가 없다.</li>
</ul>

<h3 id="none"><code class="language-plaintext highlighter-rouge">none()</code></h3>

<p>객체를 반환하지 않는 QuerySet을 반환하고, 엑서스할 때 쿼리가 실행되지 않는다.<br />
<code class="language-plaintext highlighter-rouge">qs.none()</code>은 EmptyQuerySet의 인스턴스이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">none</span><span class="p">()</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[]</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">django.db.models.query</span> <span class="kn">import</span> <span class="n">EmptyQuerySet</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">none</span><span class="p">(),</span> <span class="n">EmptyQuerySet</span><span class="p">)</span>
<span class="bp">True</span>
</code></pre></div></div>

<h3 id="all"><code class="language-plaintext highlighter-rouge">all()</code></h3>

<p>현재 QuerySet의 사본을 리턴한다. QuerySet이 평가된 후 평가 이전에 평가한 QuerySet에 <code class="language-plaintext highlighter-rouge">all()</code>을 호출하면 업데이트된 결과를 얻게 된다.</p>

<h3 id="union"><code class="language-plaintext highlighter-rouge">union()</code></h3>

<p>SQL의 UNION 연산자를 사용하여 둘 이상의 QuerySet 결과를 결합한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">qs1</span><span class="p">.</span><span class="n">union</span><span class="p">(</span><span class="n">qs2</span><span class="p">,</span> <span class="n">qs3</span><span class="p">)</span>
</code></pre></div></div>

<p>UNION 연산자는 기본적으로 고유한 값만 선택하지만, 중복값을 혀용하려면 <code class="language-plaintext highlighter-rouge">all=True</code> 인수를 사용하면 된다.</p>

<p><code class="language-plaintext highlighter-rouge">union()</code>, <code class="language-plaintext highlighter-rouge">intersection()</code>, <code class="language-plaintext highlighter-rouge">difference()</code>는 인자가 다른 모델의 QuerySet인 경우 첫 번째 QuerySet 타입의 모델 인스턴스를 반환한다. SELECT 리스트가 모든 QuerySet과 동일하기만 하면 다른 모델을 전달 할 수도 있다. 이런 경우 QuerySeet에 적용된 QuerySet 메소드의 첫 번째 QuerySet에서 컬럼 이름을 사용해야 한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">qs1</span> <span class="o">=</span> <span class="n">Author</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">values_list</span><span class="p">(</span><span class="s">'name'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qs2</span> <span class="o">=</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">values_list</span><span class="p">(</span><span class="s">'headline'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qs1</span><span class="p">.</span><span class="n">union</span><span class="p">(</span><span class="n">qs2</span><span class="p">).</span><span class="n">order_by</span><span class="p">(</span><span class="s">'name'</span><span class="p">)</span>
</code></pre></div></div>

<p>또한 LIMIT, OFFSET, COUNT(* ), ORDER_BY, 지정한 열(slicing, <code class="language-plaintext highlighter-rouge">count()</code>, <code class="language-plaintext highlighter-rouge">order_by()</code>, <code class="language-plaintext highlighter-rouge">values()/values_list()</code>만 결과 QuerySet에 지정할 수 있다.</p>

<p>DB는 결합된 쿼리에서 허용되는 작업을 제한한다. 예를 들면 대부분의 DB는 결합된 쿼리에서 LIMIT나 OFFSET을 허용하지 않는다.</p>

<h3 id="intersection"><code class="language-plaintext highlighter-rouge">intersection()</code></h3>

<p>SQL의 INTERSECT 연산자를 사용하여 둘 이상의 QuerySet의 공유 요소를 리턴한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">qs1</span><span class="p">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">qs2</span><span class="p">,</span> <span class="n">qs3</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="difference"><code class="language-plaintext highlighter-rouge">difference()</code></h3>

<p>SQL의 EXCEPT 연산자를 사용하여 QuerySet(qs1)에는 있고 qs2, qs3에는 없는 요소만 유지한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">qs1</span><span class="p">.</span><span class="n">difference</span><span class="p">(</span><span class="n">qs2</span><span class="p">,</span> <span class="n">qs3</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="select_related"><code class="language-plaintext highlighter-rouge">select_related()</code></h3>

<p>쿼리를 실행할때 추가적인 관련 객체 데이터를 선택하여 외래키 관계를 팔로우할 QuerySet을 반환한다. 이건 더 복잡한 쿼리를 가져오도록 부추기지만 외래키 관계를 사용할 경우 DB 쿼리가 필요하지 않음을 의미한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 일반적인 조회와 select_related() 조회의 차이점
</span>
<span class="c1">#일반적인 조회
# 아래 2줄은 각각 DB에 접근한다.
</span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">blog</span>

<span class="c1"># select_related를 사용한 조회
# select_related으로 blog 필드에 접근하여 캐싱되기 때문에 e.blog는 DB를 거치지 않아도 된다.
</span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">select_related</span><span class="p">(</span><span class="s">'blog'</span><span class="p">).</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">blog</span>

<span class="c1"># 객체의 QuerySet과 select_related() 함께 사용
</span><span class="kn">from</span> <span class="nn">django.utils</span> <span class="kn">import</span> <span class="n">timezone</span>

<span class="c1"># 공개 예정인 항목이 있는 모든 블로그 찾기
</span><span class="n">blogs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">pub_date__gt</span><span class="o">=</span><span class="n">timezone</span><span class="p">.</span><span class="n">now</span><span class="p">()).</span><span class="n">select_related</span><span class="p">(</span><span class="s">'blog'</span><span class="p">):</span>
    <span class="c1"># select_related()가 없으면 각각에 대한 데이터베이스 쿼리를 만 항목에 대한 관련 블로그를 가져오기 위해 각 루프 반복에 대한 DB 쿼리가 된다.
</span>    <span class="n">blogs</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">blog</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">filter()</code>나 <code class="language-plaintext highlighter-rouge">select_related()</code>의 연결 순서는 상관없다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">pub_date__gt</span><span class="o">=</span><span class="n">timezone</span><span class="p">.</span><span class="n">now</span><span class="p">()).</span><span class="n">select_related</span><span class="p">(</span><span class="s">'blog'</span><span class="p">)</span>
<span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">select_related</span><span class="p">(</span><span class="s">'blog'</span><span class="p">).</span><span class="nb">filter</span><span class="p">(</span><span class="n">pub_date__gt</span><span class="o">=</span><span class="n">timezone</span><span class="p">.</span><span class="n">now</span><span class="p">())</span>
</code></pre></div></div>

<p>외래키를 쿼리하는 것과 비슷한 방식으로 외래키를 따를 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># models
</span><span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">models</span>

<span class="k">class</span> <span class="nc">City</span><span class="p">(</span><span class="n">models</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c1"># ...
</span>    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Person</span><span class="p">(</span><span class="n">models</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c1"># ...
</span>    <span class="n">hometown</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="n">ForeignKey</span><span class="p">(</span>
        <span class="n">City</span><span class="p">,</span>
        <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="p">.</span><span class="n">SET_NULL</span><span class="p">,</span>
        <span class="n">blank</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
        <span class="n">null</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
    <span class="p">)</span>

<span class="k">class</span> <span class="nc">Book</span><span class="p">(</span><span class="n">models</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c1"># ...
</span>    <span class="n">author</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="n">Person</span><span class="p">,</span> <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="p">.</span><span class="n">CASCADE</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Book.objects.select_related('author__hometown').get(id=4)</code>를 호출하면 관련 Person과 관련 City가 캐시된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># author와 hometown 테이블에 조인하여 DB를 히트한다.
</span><span class="n">b</span> <span class="o">=</span> <span class="n">Book</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">select_related</span><span class="p">(</span><span class="s">'author__hometown'</span><span class="p">).</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">author</span>         <span class="c1"># Doesn't hit the database.
</span><span class="n">c</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">hometown</span>       <span class="c1"># Doesn't hit the database.
</span>
<span class="c1"># Without select_related()...
</span><span class="n">b</span> <span class="o">=</span> <span class="n">Book</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># Hits the database.
</span><span class="n">p</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">author</span>         <span class="c1"># Hits the database.
</span><span class="n">c</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">hometown</span>       <span class="c1"># Hits the database.
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">select_related()</code>에 ForeignKey나 OneToOneField 관계를 참조할 수 있다.<br />
또한 select_related을 전달된 필드 리스트에서 OneToOneField의 역방향도 참조할 수 있다. 즉 OneToOneField를 필드가 정의된 객체로 다시 이동할 수 있다.</p>

<p>필드 이름을 지정하는 대신 관련 객체의 필드에 related_name을 사용하면 된다.</p>

<p>관련 객체가 많은 <code class="language-plaintext highlighter-rouge">select_content()</code>를 호출하고 싶거나, 모든 관계를 모르는 상황이 있을 수 있다. 이런 경우 <code class="language-plaintext highlighter-rouge">select_content()</code>를 인수 없이 호출한다. 이러면 null 아닌 모든 외래키를 따르게 된다. 대부분의 이런 경우는 기본 쿼리를 더 복잡하게 만들고 필요한 데이터보다 많은 데이터를 반환하기 때문에 권장되지 않는다.</p>

<p>QuerySet에서 select_related의 이전 호출에 의해 추가된 관련 필드 리스트를 지워야 하는 경우 매개 변수로 None을 전달한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">without_relations</span> <span class="o">=</span> <span class="n">queryset</span><span class="p">.</span><span class="n">select_related</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># select_related를 체이닝하여 콜하는 경우
# 둘은 같다.
</span><span class="n">select_related</span><span class="p">(</span><span class="s">'foo'</span><span class="p">,</span> <span class="s">'bar'</span><span class="p">)</span> <span class="o">==</span> <span class="n">select_related</span><span class="p">(</span><span class="s">'foo'</span><span class="p">).</span><span class="n">select_related</span><span class="p">(</span><span class="s">'bar'</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="prefetch_related"><code class="language-plaintext highlighter-rouge">prefetch_related()</code></h3>

<p>지정된 각 조회에 대해 단일 배치에서 관견 객체를 자동으로 검새하는 QuerySet을 반환한다. 이건 <code class="language-plaintext highlighter-rouge">select_related</code>와 비슷하다. 둘 다 관련 객체에 액세스하여 발생하는 DB 쿼리의 유출을 막기 위해 설계되었지만, 전략은 완전 다르다.</p>

<p><code class="language-plaintext highlighter-rouge">select_related</code>는 SQL join을 생성하고 SELECT 문에 관련 객체의 필드를 포함시켜 작동한다. 그렇기 때문에 <code class="language-plaintext highlighter-rouge">select_related</code>는 동일한 DB 쿼리에서 관련 객체를 가져온다. 그러나 많은 관계가 조인하여 발생하는 큰 결과셋을 피하기 위해 <code class="language-plaintext highlighter-rouge">select_related</code>는 외래키와 one-to-one 관계로 제한한다.</p>

<p><code class="language-plaintext highlighter-rouge">prefetch_related</code>는 각 관계에 대해 별도로 조회하고 파이썬에서 joining을 수행한다. 이를 통해 <code class="language-plaintext highlighter-rouge">select_related</code>에서는 할 수 없는 many-to-many, many-to-one 객체도 사용이 가능하다. 또한 <code class="language-plaintext highlighter-rouge">GenericRelation</code>, <code class="language-plaintext highlighter-rouge">GenericForeignKey</code>도 지원하지만, 동일한 결과 집합으로 제한된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 예를 위한 모델
</span><span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">models</span>

<span class="k">class</span> <span class="nc">Topping</span><span class="p">(</span><span class="n">models</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Pizza</span><span class="p">(</span><span class="n">models</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">toppings</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="n">ManyToManyField</span><span class="p">(</span><span class="n">Topping</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">"%s (%s)"</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
            <span class="s">", "</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">topping</span><span class="p">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">topping</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">toppings</span><span class="p">.</span><span class="nb">all</span><span class="p">()),</span>
        <span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># run
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">Pizza</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">all</span><span class="p">()</span>
<span class="p">[</span><span class="s">"Hawaiian (ham, pineapple)"</span><span class="p">,</span> <span class="s">"Seafood (prawns, smoked salmon)"</span><span class="p">...</span>
</code></pre></div></div>

<p>위 코드의 문제는 <code class="language-plaintext highlighter-rouge">Pizza.__str__()</code>이 <code class="language-plaintext highlighter-rouge">self.toppings.all()</code>을 요청할때마다 DB를 쿼리해야하기 떄문에 <code class="language-plaintext highlighter-rouge">Pizza.objects.all()</code>은 Toppings 테이블에서 쿼리를 실행한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># prefetch_related를 사용하면 두 개의 쿼리로 줄일 수 있다.
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">Pizza</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">all</span><span class="p">().</span><span class="n">prefetch_related</span><span class="p">(</span><span class="s">'toppings'</span><span class="p">)</span>
</code></pre></div></div>

<p>이건 각 Pizza마다 <code class="language-plaintext highlighter-rouge">self.toppings.all()</code>을 의미한다. 이 <code class="language-plaintext highlighter-rouge">self.toppings.all()</code>은 호출할 때마다 DB로 이동하지 않고 단일 조회로 채워진 미리 설정된 QuerySet 캐시에서 해당 항목을 찾는다.</p>

<p>즉, 모든 관련 toppings은 단일 쿼리로 가져와 관련 결과들로 미리 채워진 캐시가 있는 QuerySet을 만드는데 사용되고, 이 QuerySet은 <code class="language-plaintext highlighter-rouge">self.toppings.all()</code> 호출에 사용된다.</p>

<p><code class="language-plaintext highlighter-rouge">prefetch_related()</code>의 추가 쿼리는 QuerySet의 평가가 시작되고 기본 쿼리가 실행된 후에 실행된다.</p>

<p>반복 가능한 모델 인스턴스의 경우 <code class="language-plaintext highlighter-rouge">prefetch_related_objects()</code>를 사용하여 해당 인스턴스에서 관련 속성을 미리 준비할 수 있다.</p>

<p>그 후에 기본 QuerySet의 결과 캐시와 지정된 모든 관련 객체를 메모리에 완전히 불러온다. 일반적으로는 DB에서 쿼리가 실행 된 후에도 필요한 모든 객체를 메모리에 로드하지 않는다.</p>

<blockquote>
  <p>QuerySet에서 다른 DB 쿼리를 암시하는 후속 체인 메소드는 이전의 캐시된 결과를 무시하고 새로운 DB 쿼리를 사용하여 데이터를 검색한다.</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">pizzas</span> <span class="o">=</span> <span class="n">Pizza</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">prefetch_related</span><span class="p">(</span><span class="s">'toppings'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">pizza</span><span class="p">.</span><span class="n">toppings</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">spicy</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span> <span class="k">for</span> <span class="n">pizza</span> <span class="ow">in</span> <span class="n">pizzas</span><span class="p">]</span>
</code></pre></div></div>

<p>위 코드는 <code class="language-plaintext highlighter-rouge">pizza.toppings.all()</code>가 프리패치 되었지만 아무런 도움이 되지 않는다. <code class="language-plaintext highlighter-rouge">prefetch_related('toppings')</code>는 <code class="language-plaintext highlighter-rouge">pizza.toppings.all()</code>을 암시하지만 <code class="language-plaintext highlighter-rouge">pizza.toppings.filter()</code>와는 다른 쿼리다. 그래서 위 코드에서는 사용하지 않는 DB 쿼리를 수행하기 때문에 프리패치가 도움이 되지 않을 뿐더러, 성능까지 저하된다.</p>

<p>또한, 관련 관리자에서 DB 변경 메소드(<code class="language-plaintext highlighter-rouge">add()</code>, <code class="language-plaintext highlighter-rouge">remove()</code>, <code class="language-plaintext highlighter-rouge">clear()</code>, <code class="language-plaintext highlighter-rouge">set()</code>을 호출하면 프리패치된 캐시가 지워진다.</p>

<p>일반 조인 구문을 사용하여 관련 필드의 관련 필드를 수행할 수도 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 위 모델 코드에 추가 모델
</span><span class="k">class</span> <span class="nc">Restaurant</span><span class="p">(</span><span class="n">models</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">pizzas</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="n">ManyToManyField</span><span class="p">(</span><span class="n">Pizza</span><span class="p">,</span> <span class="n">related_name</span><span class="o">=</span><span class="s">'restaurants'</span><span class="p">)</span>
    <span class="n">best_pizza</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="n">Pizza</span><span class="p">,</span> <span class="n">related_name</span><span class="o">=</span><span class="s">'championed_by'</span><span class="p">,</span> <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="p">.</span><span class="n">CASCADE</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Restaurant</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">prefetch_related</span><span class="p">(</span><span class="s">'pizzas__toppings'</span><span class="p">)</span>
</code></pre></div></div>

<p>Restaurant에 속한 모든 Pizza와 해당 Pizza에 속하는 모든 Topping이 프리패치되는데, 이는 총 3개의 DB 쿼리가 발생한다.(Restaurant, Pizza, Topping)</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Restaurant</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">prefetch_related</span><span class="p">(</span><span class="s">'best_pizza__toppings'</span><span class="p">)</span>
</code></pre></div></div>

<p>이건 각 Restaurant마다 최고의 Pizze와 최고의 Pizza를 위한 모든 Topping을 가져온다. 이 역시 3개의 DB 쿼리가 발생한다.</p>

<p>물론, <code class="language-plaintext highlighter-rouge">select_related</code>를 사용하여 쿼리를 둘로 줄일 수도 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Restaurant</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">select_related</span><span class="p">(</span><span class="s">'best_pizza'</span><span class="p">).</span><span class="n">prefetch_related</span><span class="p">(</span><span class="s">'best_pizza__toppings'</span><span class="p">)</span>
</code></pre></div></div>

<p>프리패치는 기본쿼리 후에 실행되므로 <code class="language-plaintext highlighter-rouge">best_pizza</code> 객체가 이미 패치되었음을 감지하고 다시 패치하지 않는다.</p>

<p><code class="language-plaintext highlighter-rouge">prefetch_related</code> 호출을 연결하면 프리패치된 조회가 누적된다. 이 동작을 지우려면 None을 매개변수로 전달해야 한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">non_prefetched</span> <span class="o">=</span> <span class="n">qs</span><span class="p">.</span><span class="n">prefetch_related</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">prefetch_related</code>를 사용시 유의할 점은 쿼리로 생성된 객체가 의도와 상관없이 관계가 있는 다른 객체간에 공유 될 수 있다는 것이다. 이건 일반적으로 외래키 관계에서 발생하는데, 이 동작이 문제가 되지 않는다면 메모리와 CPU 시간을 모두 절약한다.</p>

<p><code class="language-plaintext highlighter-rouge">GenericForeignKey</code>는 여러 테이블의 데이터를 참조할 수 있기 때문에 모든 항목에 대해 하나의 쿼리가 아니라 참조된 테이블 당 하나의 쿼리가 필요하다. 관계된 행을 가져오지 못한 경우 ContentType 테이블에 추가 쿼리가 있을 수 있다.</p>

<p>대부분 <code class="language-plaintext highlighter-rouge">prefetch_related</code>는 SQL IN 연산자를 사용한다. 이건 큰 QuerySet의 경우 DB에 따라 쿼리 구분 분석이나 실행시 큰 IN 이 생성되어 성능 이슈가 발생할 수 있음을 의미한다.</p>

<p><code class="language-plaintext highlighter-rouge">iterator()</code>를 사용하면 <code class="language-plaintext highlighter-rouge">prefetch_related()</code>는 무시된다.</p>

<p><code class="language-plaintext highlighter-rouge">Prefetch</code>를 사용하면 프리패치 객체를 추가로 제어할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">Prefetch</span>
<span class="c1"># 가장 단순한 Prefetch 사용으로, 기본 문자열 검색과 동일하다.
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">Restaurant</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">prefetch_related</span><span class="p">(</span><span class="n">Prefetch</span><span class="p">(</span><span class="s">'pizzas__toppings'</span><span class="p">))</span>

<span class="c1"># 선택적 queryset 인자를 사용하여 cunstom queryset를 만들 수 있다.
# 이걸로 queryset의 기본 순서를 변경 할 수 있다.
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">Restaurant</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">prefetch_related</span><span class="p">(</span>
<span class="p">...</span>     <span class="n">Prefetch</span><span class="p">(</span><span class="s">'pizzas__toppings'</span><span class="p">,</span> <span class="n">queryset</span><span class="o">=</span><span class="n">Toppings</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">'name'</span><span class="p">)))</span>

<span class="c1"># select_related()를 호출하여 쿼리를 더 줄일 수 있다.
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">Pizza</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">prefetch_related</span><span class="p">(</span>
<span class="p">...</span>     <span class="n">Prefetch</span><span class="p">(</span><span class="s">'restaurants'</span><span class="p">,</span> <span class="n">queryset</span><span class="o">=</span><span class="n">Restaurant</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">select_related</span><span class="p">(</span><span class="s">'best_pizza'</span><span class="p">)))</span>

<span class="c1"># to_attr 인자를 사용하여 프리패치된 결과를 사용자 정의 속성에 지정할 수 있다.
# 결과는 리스트에 저장된다.
</span>
<span class="c1"># 이를 통해 다른 QuerySet으로 동일한 관계를 여러번 프리패치 할 수 있다.
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">vegetarian_pizzas</span> <span class="o">=</span> <span class="n">Pizza</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">vegetarian</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Restaurant</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">prefetch_related</span><span class="p">(</span>
<span class="p">...</span>     <span class="n">Prefetch</span><span class="p">(</span><span class="s">'pizzas'</span><span class="p">,</span> <span class="n">to_attr</span><span class="o">=</span><span class="s">'menu'</span><span class="p">),</span>
<span class="p">...</span>     <span class="n">Prefetch</span><span class="p">(</span><span class="s">'pizzas'</span><span class="p">,</span> <span class="n">queryset</span><span class="o">=</span><span class="n">vegetarian_pizzas</span><span class="p">,</span> <span class="n">to_attr</span><span class="o">=</span><span class="s">'vegetarian_menu'</span><span class="p">))</span>

<span class="c1"># 사용자 정의된 to_attr으로 작성된 조회는 다른 조회에서 같이 계속 순회가 가능하다.
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">vegetarian_pizzas</span> <span class="o">=</span> <span class="n">Pizza</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">vegetarian</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Restaurant</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">prefetch_related</span><span class="p">(</span>
<span class="p">...</span>     <span class="n">Prefetch</span><span class="p">(</span><span class="s">'pizzas'</span><span class="p">,</span> <span class="n">queryset</span><span class="o">=</span><span class="n">vegetarian_pizzas</span><span class="p">,</span> <span class="n">to_attr</span><span class="o">=</span><span class="s">'vegetarian_menu'</span><span class="p">),</span>
<span class="p">...</span>     <span class="s">'vegetarian_menu__toppings'</span><span class="p">)</span>

<span class="c1"># 프리 패치 결과를 필터링 할때는 to_attr을 사용하는 것이 좋다.
</span><span class="o">&gt;&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c1"># Recommended:
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">restaurants</span> <span class="o">=</span> <span class="n">Restaurant</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">prefetch_related</span><span class="p">(</span>
<span class="p">...</span>     <span class="n">Prefetch</span><span class="p">(</span><span class="s">'pizzas'</span><span class="p">,</span> <span class="n">queryset</span><span class="o">=</span><span class="n">queryset</span><span class="p">,</span> <span class="n">to_attr</span><span class="o">=</span><span class="s">'vegetarian_pizzas'</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">vegetarian_pizzas</span> <span class="o">=</span> <span class="n">restaurants</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">vegetarian_pizzas</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c1"># Not recommended:
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">restaurants</span> <span class="o">=</span> <span class="n">Restaurant</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">prefetch_related</span><span class="p">(</span>
<span class="p">...</span>     <span class="n">Prefetch</span><span class="p">(</span><span class="s">'pizzas'</span><span class="p">,</span> <span class="n">queryset</span><span class="o">=</span><span class="n">queryset</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">vegetarian_pizzas</span> <span class="o">=</span> <span class="n">restaurants</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pizzas</span><span class="p">.</span><span class="nb">all</span><span class="p">()</span>
</code></pre></div></div>

<p>사용자 지정 프리패치는 ForeignKey나 OneToOneField와 같은 단일 관계에서도 동작한다. 이런 관계는 일반적으로 <code class="language-plaintext highlighter-rouge">select_related()</code>를 사용하지만, 사용자 정의 QuerySet을 사용하여 프리패치 하는 것이 더 유용한 경우도 많다.</p>

<ul>
  <li>관련 모델에서 추가 프리패치를 수행하는 QuerySet을 사용하려는 경우</li>
  <li>관련 객체의 일부만 프리패치하려는 경우</li>
  <li><code class="language-plaintext highlighter-rouge">deferred fields</code>처럼 성능 최적화된 기술을 사용하려는 경우</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">queryset</span> <span class="o">=</span> <span class="n">Pizza</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">only</span><span class="p">(</span><span class="s">'name'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">restaurants</span> <span class="o">=</span> <span class="n">Restaurant</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">prefetch_related</span><span class="p">(</span>
<span class="p">...</span>     <span class="n">Prefetch</span><span class="p">(</span><span class="s">'best_pizza'</span><span class="p">,</span> <span class="n">queryset</span><span class="o">=</span><span class="n">queryset</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="extra"><code class="language-plaintext highlighter-rouge">extra()</code></h3>

<p>Django는 복잡한 WHERE 구문을 위해 <code class="language-plaintext highlighter-rouge">extra()</code>을 제공한다.(QuerySet에 의해 생성된 SQL에 특정 절을 삽입하기 위한 훅)</p>

<p><code class="language-plaintext highlighter-rouge">extra()</code>는 더이상 업데이트 되지 안는다. 다른 쿼리셋 메소드를 사용해서 쿼리를 표현할 수 없는 경우에만 사용해야 한다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">select</code>
 여분의 필드를 삽입할 수 있다. SELECT 절에 dict를 맵핑해야 한다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Entry에 추가속석 is_recent 이 있음
# 이 속성은 pub_date가 2006년 1월 1일보다 큰지 여부를 나타냄
</span><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">extra</span><span class="p">(</span><span class="n">select</span><span class="o">=</span><span class="p">{</span><span class="s">'is_recent'</span><span class="p">:</span> <span class="s">"pub_date &gt; '2006-01-01'"</span><span class="p">})</span>

<span class="c1"># SQL
</span><span class="n">SELECT</span> <span class="n">blog_entry</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> <span class="p">(</span><span class="n">pub_date</span> <span class="o">&gt;</span> <span class="s">'2006-01-01'</span><span class="p">)</span> <span class="n">AS</span> <span class="n">is_recent</span>
<span class="n">FROM</span> <span class="n">blog_entry</span><span class="p">;</span>

<span class="c1"># Blog 객체에 entry_count속석 관련 Entry 객체의 정수 갯수를 호출
</span><span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">extra</span><span class="p">(</span>
    <span class="n">select</span><span class="o">=</span><span class="p">{</span>
        <span class="s">'entry_count'</span><span class="p">:</span> <span class="s">'SELECT COUNT(*) FROM blog_entry WHERE blog_entry.blog_id = blog_blog.id'</span>
    <span class="p">},</span>
<span class="p">)</span>

<span class="c1"># SQL
</span><span class="n">SELECT</span> <span class="n">blog_blog</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> <span class="p">(</span><span class="n">SELECT</span> <span class="n">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="n">FROM</span> <span class="n">blog_entry</span> <span class="n">WHERE</span> <span class="n">blog_entry</span><span class="p">.</span><span class="n">blog_id</span> <span class="o">=</span> <span class="n">blog_blog</span><span class="p">.</span><span class="nb">id</span><span class="p">)</span> <span class="n">AS</span> <span class="n">entry_count</span>
<span class="n">FROM</span> <span class="n">blog_blog</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">where / tables</code>
 <code class="language-plaintext highlighter-rouge">where</code>을 사용하여 명시적으로 SQL WHERE절을 정의한다.<br />
 <code class="language-plaintext highlighter-rouge">tables</code>를 사용하여 SQL FROM절에 테이블을 수동으로 추가할 수 있다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1"># where의 각 요소는 AND로 해석된다.
</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">extra</span><span class="p">(</span><span class="n">where</span><span class="o">=</span><span class="p">[</span><span class="s">"foo='a' OR bar = 'a'"</span><span class="p">,</span> <span class="s">"baz = 'a'"</span><span class="p">])</span>

<span class="c1"># SQL
</span><span class="n">SELECT</span> <span class="o">*</span> <span class="n">FROM</span> <span class="n">blog_entry</span> <span class="n">WHERE</span> <span class="p">(</span><span class="n">foo</span><span class="o">=</span><span class="s">'a'</span> <span class="n">OR</span> <span class="n">bar</span><span class="o">=</span><span class="s">'a'</span><span class="p">)</span> <span class="n">AND</span> <span class="p">(</span><span class="n">baz</span><span class="o">=</span><span class="s">'a'</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">order_by</code></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">extra()</code>으로 생성된 새로운 필드나 테이블을 정렬할 수 있다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">q</span> <span class="o">=</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">extra</span><span class="p">(</span><span class="n">select</span><span class="o">=</span><span class="p">{</span><span class="s">'is_recent'</span><span class="p">:</span> <span class="s">"pub_date &gt; '2006-01-01'"</span><span class="p">})</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">extra</span><span class="p">(</span><span class="n">order_by</span> <span class="o">=</span> <span class="p">[</span><span class="s">'-is_recent'</span><span class="p">])</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">params</code>
 where의 매개 변수를 ‘%s’으로 표현하는데, 매개 변수를 params에 넣어야 한다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">extra</span><span class="p">(</span><span class="n">where</span><span class="o">=</span><span class="p">[</span><span class="s">'headline=%s'</span><span class="p">],</span> <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="s">'Lennon'</span><span class="p">])</span>
</code></pre></div></div>

<h3 id="defer"><code class="language-plaintext highlighter-rouge">defer()</code></h3>

<p>QuerySet으로 DB에 접근할때 지연시킬 필드명을 지정한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">defer</span><span class="p">(</span><span class="s">"headline"</span><span class="p">,</span> <span class="s">"body"</span><span class="p">)</span>

<span class="c1"># 여러번 호출할 수도 있다.
</span><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">defer</span><span class="p">(</span><span class="s">"body"</span><span class="p">).</span><span class="nb">filter</span><span class="p">(</span><span class="n">rating</span><span class="o">=</span><span class="mi">5</span><span class="p">).</span><span class="n">defer</span><span class="p">(</span><span class="s">"headline"</span><span class="p">)</span>

<span class="c1"># 관련 모델의 필드는 이중 언더바로 지정하여 적용할 수 있다.
</span><span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">select_related</span><span class="p">().</span><span class="n">defer</span><span class="p">(</span><span class="s">"entry__headline"</span><span class="p">,</span> <span class="s">"entry__body"</span><span class="p">)</span>

<span class="c1"># defer()를 초기화하려면 None을 인자로 전달하면 된다.
</span><span class="n">my_queryset</span><span class="p">.</span><span class="n">defer</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
</code></pre></div></div>

<p>기본 키와 같은 모델의 일부 필드는 지연시킬 수 없다.</p>

<h3 id="only"><code class="language-plaintext highlighter-rouge">only()</code></h3>

<p><code class="language-plaintext highlighter-rouge">defer()</code>와 정반대로 동작한다. 지연되어서는 안되는 필드를 지정한다.<br />
거의 모든 필드를 연기해야하는 경우 <code class="language-plaintext highlighter-rouge">only()</code>을 사용하면 코드는 더 간단해진다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Person은 name, age, biography 3개의 필드를 가지고 있다고 가정한다.
# 두 코드는 동일한 동작을 한다.
</span><span class="n">Person</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">defer</span><span class="p">(</span><span class="s">"age"</span><span class="p">,</span> <span class="s">"biography"</span><span class="p">)</span>
<span class="n">Person</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">only</span><span class="p">(</span><span class="s">"name"</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">only()</code>을 중첩할 경우 마지막만 적용된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># This will defer all fields except the headline.
</span><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">only</span><span class="p">(</span><span class="s">"body"</span><span class="p">,</span> <span class="s">"rating"</span><span class="p">).</span><span class="n">only</span><span class="p">(</span><span class="s">"headline"</span><span class="p">)</span>
</code></pre></div></div>

<p>그렇기 때문에 <code class="language-plaintext highlighter-rouge">defer()</code>와 <code class="language-plaintext highlighter-rouge">only()</code>를 결합하여 사용할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># headline를 제외한 모든 것이 지연된다.
</span><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">only</span><span class="p">(</span><span class="s">"headline"</span><span class="p">,</span> <span class="s">"body"</span><span class="p">).</span><span class="n">defer</span><span class="p">(</span><span class="s">"body"</span><span class="p">)</span>


<span class="c1"># headline, body를 호출한다.
</span><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">defer</span><span class="p">(</span><span class="s">"body"</span><span class="p">).</span><span class="n">only</span><span class="p">(</span><span class="s">"headline"</span><span class="p">,</span> <span class="s">"body"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="using"><code class="language-plaintext highlighter-rouge">using()</code></h3>

<p>둘 이상의 DB를 사용하는 경우 QuerySet이 평가할 DB를 지저한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># queries the database with the 'default' alias.
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">all</span><span class="p">()</span>

<span class="c1"># queries the database with the 'backup' alias
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">using</span><span class="p">(</span><span class="s">'backup'</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="select_for_update"><code class="language-plaintext highlighter-rouge">select_for_update()</code></h3>

<p>트랜잭션이 끝날때까지 행을 잠그는 ‘SELECT … FOR UPDATE’ SQL문을 생성하는 QuerySet을 반환한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">transaction</span>

<span class="n">entries</span> <span class="o">=</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">select_for_update</span><span class="p">().</span><span class="nb">filter</span><span class="p">(</span><span class="n">author</span><span class="o">=</span><span class="n">request</span><span class="p">.</span><span class="n">user</span><span class="p">)</span>
<span class="k">with</span> <span class="n">transaction</span><span class="p">.</span><span class="n">atomic</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">:</span>
        <span class="p">...</span>
</code></pre></div></div>

<p>일반적으로 다른 트랜잭션이 선택된 행 중 하나에 잠금을 획득한 경우, 잠금이 해제 될때까지 쿼리가 차단되는데, 차단하지 않으려면 <code class="language-plaintext highlighter-rouge">select_for_update(nowait=True)</code>를 하면 된다.<br />
<code class="language-plaintext highlighter-rouge">select_for_update(skip_locked=True)</code>를 하면 잠긴 행을 무시할 수 있다.</p>

<p>부모 모델을 잠그려면 <code class="language-plaintext highlighter-rouge">of</code>에 상위 링크 필드(<parent_model_name>_ptr)를 지정해야한다.</parent_model_name></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Restaurant</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">select_for_update</span><span class="p">(</span><span class="n">of</span><span class="o">=</span><span class="p">(</span><span class="s">'self'</span><span class="p">,</span> <span class="s">'place_ptr'</span><span class="p">))</span>
</code></pre></div></div>

<p>해당 필드가 null인 경우 사용이 불가하고 <code class="language-plaintext highlighter-rouge">NotSupportedError</code>가 발생한다. 이러한 제한을 피하기 위해 제외할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Person</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">select_related</span><span class="p">(</span><span class="s">'hometown'</span><span class="p">).</span><span class="n">select_for_update</span><span class="p">().</span><span class="n">exclude</span><span class="p">(</span><span class="n">hometown</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">Person</span><span class="p">:</span> <span class="p">...)</span><span class="o">&gt;</span><span class="p">,</span> <span class="p">...]</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>postgresql, oracle, mysql에서 <code class="language-plaintext highlighter-rouge">select_for_update()</code>를 지원하지만, MySql은 of 인수를 지원하지 않고, nowait, skip_locked는 MySQL 8.0.1 이상에서만 지원한다.</p>

<h3 id="raw"><code class="language-plaintext highlighter-rouge">raw()</code></h3>

<p>원시 SQL 쿼리를 실행하고, <code class="language-plaintext highlighter-rouge">django.db.models.query.RawQuerySet</code> 인스턴스를 반환한다.</p>

<h1 id="새-queryset을-반환하는-연산자들">새 QuerySet을 반환하는 연산자들</h1>

<h3 id="and"><code class="language-plaintext highlighter-rouge">AND(&amp;)</code></h3>

<p>SQL AND 연산자를 사용하여 결합한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 모두 동일하다.
</span><span class="n">Model</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">Model</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Model</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">Q</span>
<span class="n">Model</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">Q</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>

<span class="c1"># SQL
</span><span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">x</span><span class="o">=</span><span class="mi">1</span> <span class="n">AND</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span>
</code></pre></div></div>

<h3 id="or"><code class="language-plaintext highlighter-rouge">OR(|)</code></h3>

<p>SQL OR 연산자를 사용하여 결합한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 모두 동일하다.
</span><span class="n">Model</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">Model</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">Q</span>
<span class="n">Model</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">Q</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>

<span class="c1"># SQL
</span><span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">x</span><span class="o">=</span><span class="mi">1</span> <span class="n">OR</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span>
</code></pre></div></div>

<h1 id="queryset을-반환하지-않는-함수들">QuerySet을 반환하지 않는 함수들</h1>

<p>이 메소드들은 캐시를 사용하지 않고, 호출 될 떄마다 DB를 쿼리한다.</p>

<h3 id="get"><code class="language-plaintext highlighter-rouge">get()</code></h3>

<p>단일 객체를 반환한다.</p>

<p>QuerySet이 하나의 행을 반환 될 것으로 예상되면 인수 없이 사용하면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">entry</span> <span class="o">=</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(...).</span><span class="n">exclude</span><span class="p">(...).</span><span class="n">get</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="create"><code class="language-plaintext highlighter-rouge">create()</code></h3>

<p>객체의 생성 및 저장을 한번에 진행한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 1,2는 동일하다.
## 1
</span><span class="n">p</span> <span class="o">=</span> <span class="n">Person</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">first_name</span><span class="o">=</span><span class="s">"Bruce"</span><span class="p">,</span> <span class="n">last_name</span><span class="o">=</span><span class="s">"Springsteen"</span><span class="p">)</span>

<span class="c1">## 2
</span><span class="n">p</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="n">first_name</span><span class="o">=</span><span class="s">"Bruce"</span><span class="p">,</span> <span class="n">last_name</span><span class="o">=</span><span class="s">"Springsteen"</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">save</span><span class="p">(</span><span class="n">force_insert</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="get_or_create"><code class="language-plaintext highlighter-rouge">get_or_create()</code></h3>

<p>단일 객체(<code class="language-plaintext highlighter-rouge">(object, created)</code>)를 반환하고, 없으면 생성한다.</p>

<p><code class="language-plaintext highlighter-rouge">get_or_create()</code>에 <code class="language-plaintext highlighter-rouge">filter()</code>를 사용할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">Q</span>

<span class="n">obj</span><span class="p">,</span> <span class="n">created</span> <span class="o">=</span> <span class="n">Person</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">first_name</span><span class="o">=</span><span class="s">'Bob'</span><span class="p">)</span> <span class="o">|</span> <span class="n">Q</span><span class="p">(</span><span class="n">first_name</span><span class="o">=</span><span class="s">'Robert'</span><span class="p">),</span>
<span class="p">).</span><span class="n">get_or_create</span><span class="p">(</span><span class="n">last_name</span><span class="o">=</span><span class="s">'Marley'</span><span class="p">,</span> <span class="n">defaults</span><span class="o">=</span><span class="p">{</span><span class="s">'first_name'</span><span class="p">:</span> <span class="s">'Bob'</span><span class="p">})</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">get_or_create()</code>에서 여러 객체가 발견되면 <code class="language-plaintext highlighter-rouge">MultipleObjectsReturned</code>를 발생시킨다.</p>

<h3 id="update_or_create"><code class="language-plaintext highlighter-rouge">update_or_create()</code></h3>

<p>단일 객체를 업데이트하고, 없다면 생성한다.</p>

<p>튜플을 반환한다. <code class="language-plaintext highlighter-rouge">(object, created)</code></p>

<h3 id="bulk_create"><code class="language-plaintext highlighter-rouge">bulk_create()</code></h3>

<p>객체 리스트를 DB에 삽입한다. (한번에 여러 객체를 저장)</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">bulk_create</span><span class="p">([</span>
<span class="p">...</span>     <span class="n">Entry</span><span class="p">(</span><span class="n">headline</span><span class="o">=</span><span class="s">'This is a test'</span><span class="p">),</span>
<span class="p">...</span>     <span class="n">Entry</span><span class="p">(</span><span class="n">headline</span><span class="o">=</span><span class="s">'This is only a test'</span><span class="p">),</span>
<span class="p">...</span> <span class="p">])</span>
</code></pre></div></div>

<p>몇가지 주의 사항이 있다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">save()</code>가 호출되지 않기 때문에 <code class="language-plaintext highlighter-rouge">pre_save</code>, <code class="language-plaintext highlighter-rouge">post_save</code> 시그널이 발생하지 않는다.</li>
  <li>다중 테이블 상속 시나리오에서는 하위 모델과 작동하지 않는다.</li>
  <li>모델의 기본 키가 AuthField인 경우 DB 백엔드가 지원하지 않는 다면(PostgreSQL) 기본 키 속성을 검색하여 설정하지 않는다.</li>
  <li>many-to-many 관계는 지원하지 않는다.</li>
</ul>

<h3 id="bulk_update"><code class="language-plaintext highlighter-rouge">bulk_update()</code></h3>

<p>하나의 쿼리로 모델 인스턴스에서 제공된 필드를 효율적으로 업데이트한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">objs</span> <span class="o">=</span> <span class="p">[</span>
<span class="p">...</span>    <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">headline</span><span class="o">=</span><span class="s">'Entry 1'</span><span class="p">),</span>
<span class="p">...</span>    <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">headline</span><span class="o">=</span><span class="s">'Entry 2'</span><span class="p">),</span>
<span class="p">...</span> <span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">objs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">headline</span> <span class="o">=</span> <span class="s">'This is entry 1'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">objs</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">headline</span> <span class="o">=</span> <span class="s">'This is entry 2'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">bulk_update</span><span class="p">(</span><span class="n">objs</span><span class="p">,</span> <span class="p">[</span><span class="s">'headline'</span><span class="p">])</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">QuerySet.update()</code>와 <code class="language-plaintext highlighter-rouge">save()</code>을 사용하여 모델 리스트를 반복 업데이트하는 것보다 효율적이지만 몇가지 주의 사항이 있다.</p>

<ul>
  <li>모델의 기본 키를 업데이트 할 수 없다.</li>
  <li>각 모델의 <code class="language-plaintext highlighter-rouge">save()</code>가 호출되지 않아서 <code class="language-plaintext highlighter-rouge">pre_save</code>, <code class="language-plaintext highlighter-rouge">post_save</code> 시그널이 발생하지 않는다.</li>
  <li>많은 수의 행을 업데이트하는 경우 SQL이 매우 클 수 있다. <code class="language-plaintext highlighter-rouge">batch_size</code>를 사용하여 이런 경우를 피할 수 있다.(<code class="language-plaintext highlighter-rouge">batch_size</code>는 단일 쿼리에 저장되는 개체 수를 제어한다.)</li>
  <li>다중 테이블 상속시 조상에 정의된 필드를 업데이트하면, 각 조상마다 추가 쿼리가 발생한다.</li>
  <li>objs에 중복이 포함된 경우 첫 항목만 업데이트 된다.</li>
</ul>

<h3 id="count"><code class="language-plaintext highlighter-rouge">count()</code></h3>

<p>QuerySet과 일치하는 DB 객체의 수를 나타내는 정수를 반환한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Returns the total number of entries in the database.
</span><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">count</span><span class="p">()</span>

<span class="c1"># Returns the number of entries whose headline contains 'Lennon'
</span><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s">'Lennon'</span><span class="p">).</span><span class="n">count</span><span class="p">()</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">count()</code>는 <code class="language-plaintext highlighter-rouge">SELECT COUNT(*)</code>를 수행하므로, 모든 레코드를 파이썬 객체에 로드하고 <code class="language-plaintext highlighter-rouge">len()</code>를 호출하는 것보다는 <code class="language-plaintext highlighter-rouge">count()</code>를 사용해야한다.(객체를 메모리에 로드하지 않을때는 <code class="language-plaintext highlighter-rouge">len()</code>이 더 빠르다.)</p>

<h3 id="in_bulk"><code class="language-plaintext highlighter-rouge">in_bulk()</code></h3>

<p><code class="language-plaintext highlighter-rouge">in_bulk(id_list=None, field_name='pk')</code></p>

<p><code class="language-plaintext highlighter-rouge">{id, object}</code>형식으로 반환한다. <code class="language-plaintext highlighter-rouge">id_list</code>를 지정하지 않으면 QuerySet의 모든 객체를 반환한다. <code class="language-plaintext highlighter-rouge">field_name</code>은 고유 필드이어야 하고, 기본키로 설정해야 한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">in_bulk</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">Blog</span><span class="p">:</span> <span class="n">Beatles</span> <span class="n">Blog</span><span class="o">&gt;</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">in_bulk</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">Blog</span><span class="p">:</span> <span class="n">Beatles</span> <span class="n">Blog</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">Blog</span><span class="p">:</span> <span class="n">Cheddar</span> <span class="n">Talk</span><span class="o">&gt;</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">in_bulk</span><span class="p">([])</span>
<span class="p">{}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">in_bulk</span><span class="p">()</span>
<span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">Blog</span><span class="p">:</span> <span class="n">Beatles</span> <span class="n">Blog</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">Blog</span><span class="p">:</span> <span class="n">Cheddar</span> <span class="n">Talk</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">Blog</span><span class="p">:</span> <span class="n">Django</span> <span class="n">Weblog</span><span class="o">&gt;</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">in_bulk</span><span class="p">([</span><span class="s">'beatles_blog'</span><span class="p">],</span> <span class="n">field_name</span><span class="o">=</span><span class="s">'slug'</span><span class="p">)</span>
<span class="p">{</span><span class="s">'beatles_blog'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">Blog</span><span class="p">:</span> <span class="n">Beatles</span> <span class="n">Blog</span><span class="o">&gt;</span><span class="p">}</span>
</code></pre></div></div>

<h3 id="iterator"><code class="language-plaintext highlighter-rouge">iterator()</code></h3>

<p>QuerySet을 평가하고 결과를 iterator에 반환한다.</p>

<p>QuerySet은 보통 반복적인 평가가 추가 쿼리를 생성하지 않도록 결과를 내부적으로 캐시한다. 하지만 <code class="language-plaintext highlighter-rouge">iterator()</code>는 QuerySet 수준에서 캐싱하지 않고 결과를 직접 읽는다.</p>

<p>많은 수의 객체를 반환하는 QuerySet의 경우 쿼리 성능이 향상되고 메모리는 크게 감소한다.</p>

<p>이미 평가한 QuerySet에 <code class="language-plaintext highlighter-rouge">iterator()</code>을 사용하면 쿼리를 반복하여 재평가하는 점은 주의해야 한다.</p>

<p><code class="language-plaintext highlighter-rouge">iterator()</code>를 사용하면 이전의 <code class="language-plaintext highlighter-rouge">prefetch_related()</code>는 무시된다.</p>

<ul>
  <li>server-side cursors를 사용하는 경우</li>
</ul>

<p>Oracle과 PostgreSQL는 server-side sursors를 사용하여 전체 결과 셋을 메모리에 로드하지 않고 DB에서 결과를 스트리밍한다.</p>

<p>server-side cursors의 경우, <code class="language-plaintext highlighter-rouge">chunk_size</code> 매개변수는 DB 드라이버 수준에서 캐시할 결과의 수를 지정한다. 더 많은 결과를 가져오면 메모리 소비량이 증가하지만, DB 드라이버와 DB 간의 전송 횟수가 줄어든다.</p>

<p>PostgreSQL의 경우, <code class="language-plaintext highlighter-rouge">DISABLE_SERVER_SIDE_CURSORS</code>가 False로 설정되어있어야 server-side cursors를 사용할 수 있다.</p>

<ul>
  <li>server-side cursors가 없는 경우</li>
</ul>

<p>MySQL은 스트리밍 결과를 지원하지 않기 때문에, Python DB 드라이버는 전체 결과셋을 메모리에 로드한다. 그후 <code class="language-plaintext highlighter-rouge">fetchmany()</code> 메소드를 사용하여 파이썬 row 객체로 변환된다.</p>

<p><code class="language-plaintext highlighter-rouge">chunk_size</code> 매개 변수는 DB 드라이버에서 Django가 검색하는 배치의 크기를 제어한다. 배치가 클수록 메모리 소비량이 약간 증가하지만, DB 드라이버와 통신하는 오버헤드가 감소한다.</p>

<p>텍스트와 숫자 데이터가 혼홥된 10~20 열의 행들의 데이터의 경우, 2000은 100KB 미만의 데이터를 가져올 것이며, 루프가 일찍 종료될 경우 전송되는 행의 수와 폐기되는 데이터 사이의 좋은 절충안이 될 것이다.</p>

<h3 id="latest"><code class="language-plaintext highlighter-rouge">latest()</code></h3>

<p>주어진 필드를 기준으로 최신 객체를 반환한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># pub_date 필드를 기준으로 최신 항목을 반환한다.
</span><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">latest</span><span class="p">(</span><span class="s">'pub_date'</span><span class="p">)</span>

<span class="c1"># 여러 필드를 기반으로 선택할 수도 있다.
# 두 항목의 pub_date가 동일한 경우 expire_date가 빠른 항목을 선택
</span><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">latest</span><span class="p">(</span><span class="s">'pub_date'</span><span class="p">,</span> <span class="s">'-expire_date'</span><span class="p">)</span>
</code></pre></div></div>

<p>모델의 Meta가 <code class="language-plaintext highlighter-rouge">get_latest_by</code>를 지정하는 경우, <code class="language-plaintext highlighter-rouge">get_latest_by</code>에 지정된 필드가 기본값이 되어, <code class="language-plaintext highlighter-rouge">earliest()</code>,<code class="language-plaintext highlighter-rouge">latest()</code>의 인수를 생략할 수 있다.</p>

<p><code class="language-plaintext highlighter-rouge">earliest()</code>, <code class="language-plaintext highlighter-rouge">latest()</code>는 오직 편의와 가독성을 위해서 존재한다.</p>

<p><code class="language-plaintext highlighter-rouge">earliest()</code>와 <code class="language-plaintext highlighter-rouge">latest()</code>는 null date의 인스턴스를 반환 할 수 있다.<br />
순서는 DB에 위임되기 때문에, 서로 다른 DB를 사용할 경우 null 값을 허용하는 필드의 결과는 다르게 정렬될 수 있다. 예를 들어 PostgreSQL와 MySQL은 null 값이 null이 아닌 값보다 높은 것으로 정렬하고, SQLite는 반대로 처리한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># null 값을 필터링 할 수 있다.
</span><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">pub_date__isnull</span><span class="o">=</span><span class="bp">False</span><span class="p">).</span><span class="n">latest</span><span class="p">(</span><span class="s">'pub_date'</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="earliest"><code class="language-plaintext highlighter-rouge">earliest()</code></h3>

<p>방향이 변경된 경우를 제외하고 <code class="language-plaintext highlighter-rouge">latest()</code>와 다르게 작동한다.
(다르게 작동한다는게 무슨 의미인지 이해가 안된다.)</p>

<h3 id="first"><code class="language-plaintext highlighter-rouge">first()</code></h3>

<p>QuerySet과 일치하는 첫 객체를 반환한다. 정렬을 정의하지 않으면 pk으로 자동 정렬한다. 이건 <code class="language-plaintext highlighter-rouge">order_by()</code>와 상호작용에 양향을 미칠 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span> <span class="o">=</span> <span class="n">Article</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">'title'</span><span class="p">,</span> <span class="s">'pub_date'</span><span class="p">).</span><span class="n">first</span><span class="p">()</span>

<span class="c1"># 위 코드는 아래 코드와 동일하게 작동한다.(first()의 간편함을 이용하자.)
</span><span class="k">try</span><span class="p">:</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Article</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">'title'</span><span class="p">,</span> <span class="s">'pub_date'</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">except</span> <span class="nb">IndexError</span><span class="p">:</span>
    <span class="n">p</span> <span class="o">=</span> <span class="bp">None</span>
</code></pre></div></div>

<h3 id="last"><code class="language-plaintext highlighter-rouge">last()</code></h3>

<p>QuerySet과 일치하는 마지막 객체를 리턴한다. 그외에는 <code class="language-plaintext highlighter-rouge">first()</code>와 동일하다.</p>

<h3 id="aggregate"><code class="language-plaintext highlighter-rouge">aggregate()</code></h3>

<p>QuerySet에 대해 계산된 집계를 dict으로 리턴한다. 집계로 쿼리식이기 때문에 다른 집계나 값과 결합하여 복잡한 집계를 만들 수 있다.</p>

<p>키워드 인수를 사용하여 집계된 집계는 키워드를 주석의 이름으로 사용한다. 익명 인수는 집계함수의 이름과 집계되는 모델 필드에 따라 이름이 생성된다. 복합 집계는 익명 인수를 사용할 수 없기 때문에 별칭을 지정해주어야 한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 블로그 항목을 제공한 작성자의 수를 조회
</span><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">Count</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">Count</span><span class="p">(</span><span class="s">'entry'</span><span class="p">))</span>
<span class="p">{</span><span class="s">'entry__count'</span><span class="p">:</span> <span class="mi">16</span><span class="p">}</span>

<span class="c1"># 키워드 인수를 사용하여 집계 함수를 지정(리턴되는 집계 값의 이름을 제어)
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">number_of_entries</span><span class="o">=</span><span class="n">Count</span><span class="p">(</span><span class="s">'entry'</span><span class="p">))</span>
<span class="p">{</span><span class="s">'number_of_entries'</span><span class="p">:</span> <span class="mi">16</span><span class="p">}</span>
</code></pre></div></div>

<h3 id="exists"><code class="language-plaintext highlighter-rouge">exists()</code></h3>

<p>QuerySet에 조건에 해당하는 객체가 있으면 True, 없으면 False를 리턴한다.</p>

<p>일반적으로 빠른 성능을 위해 쿼리를 수행하는 방법을 채택하지만, <code class="language-plaintext highlighter-rouge">exists()</code>는 거의 동일한 쿼리를 실행한다.</p>

<p><code class="language-plaintext highlighter-rouge">exists()</code>는 특히 큰 QeurySet의 컨텍스트의 검색에 효과적이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 고유필드(ex. pk)이 QuerySet에 존재하는지 확인
</span><span class="n">entry</span> <span class="o">=</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">123</span><span class="p">)</span>
<span class="k">if</span> <span class="n">some_queryset</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="n">entry</span><span class="p">.</span><span class="n">pk</span><span class="p">).</span><span class="n">exists</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Entry contained in queryset"</span><span class="p">)</span>

<span class="c1"># 위 코드는 아래의 코드(전체 쿼리 집합을 평가를 반복)보다 빠르다.
</span><span class="k">if</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">some_queryset</span><span class="p">:</span>
   <span class="k">print</span><span class="p">(</span><span class="s">"Entry contained in QuerySet"</span><span class="p">)</span>

<span class="c1"># QuerySet에 아이템의 포함 여부를 확인한다.
</span><span class="k">if</span> <span class="n">some_queryset</span><span class="p">.</span><span class="n">exists</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"There is at least one object in some_queryset"</span><span class="p">)</span>

<span class="c1"># 위 코드는 아래 코드보다 빠르다.
</span><span class="k">if</span> <span class="n">some_queryset</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"There is at least one object in some_queryset"</span><span class="p">)</span>
</code></pre></div></div>

<p>해당 조건의 아이템이 어느 부분에 있는 알고 있다면 <code class="language-plaintext highlighter-rouge">exists()</code>를 사용하는 것보다는, 결과를 검색하고 반환결과를 Boolean 처리하는 것이 더 좋다.</p>

<h3 id="udpate"><code class="language-plaintext highlighter-rouge">udpate()</code></h3>

<p>SQL UPDATE을 수행하고, 적용된 필드 수를 반환한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 2010년에 게시된 모든 블로그 항목의 댓글을 해제한다.
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2010</span><span class="p">).</span><span class="n">update</span><span class="p">(</span><span class="n">comments_on</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</code></pre></div></div>

<p>여러 필드를 업데이트 할 수도 있다. 필드 수의 제한은 없다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># comments_on, headline 필드를 업데이트한다.
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2010</span><span class="p">).</span><span class="n">update</span><span class="p">(</span><span class="n">comments_on</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">headline</span><span class="o">=</span><span class="s">'This is old'</span><span class="p">)</span>
</code></pre></div></div>

<p>관련 모델은 <code class="language-plaintext highlighter-rouge">update()</code>가 제한된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">blog__name</span><span class="o">=</span><span class="s">'foo'</span><span class="p">)</span> <span class="c1"># Won't work!
</span></code></pre></div></div>

<p>관련 필드를 필터링하면 업데이트가 가능하다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">blog__id</span><span class="o">=</span><span class="mi">1</span><span class="p">).</span><span class="n">update</span><span class="p">(</span><span class="n">comments_on</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div></div>

<p>슬라이스하거나 더이상 필터링을 할 수 없는 QuerySet은 <code class="language-plaintext highlighter-rouge">update()</code>를 사용할 수 없다.</p>

<p><code class="language-plaintext highlighter-rouge">update()</code>는 update가 적용된 필드 수를 리턴한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">slug</span><span class="o">=</span><span class="s">'nonexistent-slug'</span><span class="p">).</span><span class="n">update</span><span class="p">(</span><span class="n">comments_on</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="mi">0</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2010</span><span class="p">).</span><span class="n">update</span><span class="p">(</span><span class="n">comments_on</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="mi">132</span>
</code></pre></div></div>

<p>모델 객체에 필드의 업데이트만 수행하고 아무 작업을 하지않는다면, 해당 모델 객체를 메모리에 로드하는 것보다 <code class="language-plaintext highlighter-rouge">update()</code>를 사용하는것이 효율적이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 객체를 메모리에 로드하고 update를 한다.
</span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">e</span><span class="p">.</span><span class="n">comments_on</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">e</span><span class="p">.</span><span class="n">save</span><span class="p">()</span>

<span class="c1"># 객체를 필터링하여 update를 바로 수행한다.
</span><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">10</span><span class="p">).</span><span class="n">update</span><span class="p">(</span><span class="n">comments_on</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</code></pre></div></div>

<p>이 방법은 객체를 로드하는 시각과 <code class="language-plaintext highlighter-rouge">save()</code>를 수행하는 짧은 시간동안 발생할 수 있는 경쟁 조건 자체를 방지한다.</p>

<p><code class="language-plaintext highlighter-rouge">update()</code>는 SQL 수준에서 업데이트를 수행하기 때문에, 모델에서 <code class="language-plaintext highlighter-rouge">save()</code>를 수행하지 않아서 <code class="language-plaintext highlighter-rouge">pre_save</code>, <code class="language-plaintext highlighter-rouge">post_save</code> 시그널을 발생시키지 않는다.</p>

<h3 id="delete"><code class="language-plaintext highlighter-rouge">delete()</code></h3>

<p>SQL DELETE를 수행하고, 삭제된 객체의 수와 객체 유형당 삭제된 수로된 dict를 반환한다.</p>

<p><code class="language-plaintext highlighter-rouge">delete()</code>는 즉시 적용된다. 슬라이스가 있거나 더 이상 필터링을 할 수 없는 QuerySet은 <code class="language-plaintext highlighter-rouge">delete()</code>를 사용할 수 없다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 특정 블로그의 모든 항목을 삭제
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="n">b</span><span class="p">).</span><span class="n">delete</span><span class="p">()</span>
<span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="p">{</span><span class="s">'weblog.Entry'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">'weblog.Entry_authors'</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
</code></pre></div></div>

<p>Django의 ForeignKey는 기본적으로 SQL의 <code class="language-plaintext highlighter-rouge">ON DELETE CASCADE</code>를 에뮬레이트한다. 즉, 삭제 될 객체를 가리키는 외래키가 있는 객체도 함께(CASCADE) 삭제된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">blogs</span> <span class="o">=</span> <span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">all</span><span class="p">()</span>

<span class="c1"># This will delete all Blogs and all of their Entry objects.
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">blogs</span><span class="p">.</span><span class="n">delete</span><span class="p">()</span>
<span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="p">{</span><span class="s">'weblog.Blog'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'weblog.Entry'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">'weblog.Entry_authors'</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
</code></pre></div></div>

<p>이 동작은 <code class="language-plaintext highlighter-rouge">on_delete</code> 인수를 통해 ForeignKey로 지정할 수 있다.</p>

<p><code class="language-plaintext highlighter-rouge">delete()</code>는 대량 삭제를 수행하며, 모델에서 <code class="language-plaintext highlighter-rouge">delete()</code>를 호출하지 않는다. 하지만 <code class="language-plaintext highlighter-rouge">pre_delete</code>, <code class="language-plaintext highlighter-rouge">post_delete</code> 시그널은 <strong>발생</strong>시킨다.</p>

<p>Django는 cascade를 처리하기 위해 객체를 메모리에 가져와야 한다. cascade나 시그널이 없는 경우 Django는 객체를 메모리에 가져오지 않고 바로 삭제한다. 그래서 메모리 사용량이 크게 줄어들고, 실행된 쿼리 양도 줄어든다.</p>

<p><code class="language-plaintext highlighter-rouge">on_delete DO_NOTHING</code>으로 설정된 ForeignKey는 빠른 삭제를 진행할 수 있다.</p>

<h3 id="as_manager"><code class="language-plaintext highlighter-rouge">as_manager()</code></h3>

<p>QuerySet의 메소드의 사본과 인스턴스 매니저를 리턴한다.</p>

<p><a href="https://docs.djangoproject.com/en/2.2/topics/db/managers/#create-manager-with-queryset-methods">Creating a manager with QuerySet methods</a> 참조</p>

<h3 id="explain"><code class="language-plaintext highlighter-rouge">explain()</code></h3>

<p>QuerySet의 실행 계획의 문자열을 리턴한다. 느린 쿼리를 분석하여 성능을 향상시키는데 도움이 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># PostgreSQL를 사용하는 경우
</span><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s">'My Blog'</span><span class="p">).</span><span class="n">explain</span><span class="p">())</span>
<span class="n">Seq</span> <span class="n">Scan</span> <span class="n">on</span> <span class="n">blog</span>  <span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mf">0.00</span><span class="p">..</span><span class="mf">35.50</span> <span class="n">rows</span><span class="o">=</span><span class="mi">10</span> <span class="n">width</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
  <span class="n">Filter</span><span class="p">:</span> <span class="p">(</span><span class="n">title</span> <span class="o">=</span> <span class="s">'My Blog'</span><span class="p">::</span><span class="n">bpchar</span><span class="p">)</span>

<span class="c1"># 출력은 DB 마다 다르다.
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">explain()</code>은 구현이 복잡하기 때문에 Oracle을 제외한 모든 DB 백엔드에서 지원한다.</p>

<p>format 매개변수는 텍스트 기반 DB의 출력 형식을 변경한다. PostgreSQL는 ‘TEXT’, ‘JSON’, ‘YAML’, ‘XML’을 지원한다. MySQL은 ‘TEXT’(‘TRADITIONAL’)과 ‘JSON’을 지원한다.</p>

<p>일부 DB는 쿼리에 대한 추가 정보를 반환 할 수 있는 플래그를 허용한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># PostgreSQL을 사용하는 경우
# 플래스를 키워드 인수로 전달
</span><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s">'My Blog'</span><span class="p">).</span><span class="n">explain</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="n">Seq</span> <span class="n">Scan</span> <span class="n">on</span> <span class="n">public</span><span class="p">.</span><span class="n">blog</span>  <span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mf">0.00</span><span class="p">..</span><span class="mf">35.50</span> <span class="n">rows</span><span class="o">=</span><span class="mi">10</span> <span class="n">width</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span> <span class="p">(</span><span class="n">actual</span> <span class="n">time</span><span class="o">=</span><span class="mf">0.004</span><span class="p">..</span><span class="mf">0.004</span> <span class="n">rows</span><span class="o">=</span><span class="mi">10</span> <span class="n">loops</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">Output</span><span class="p">:</span> <span class="nb">id</span><span class="p">,</span> <span class="n">title</span>
  <span class="n">Filter</span><span class="p">:</span> <span class="p">(</span><span class="n">blog</span><span class="p">.</span><span class="n">title</span> <span class="o">=</span> <span class="s">'My Blog'</span><span class="p">::</span><span class="n">bpchar</span><span class="p">)</span>
<span class="n">Planning</span> <span class="n">time</span><span class="p">:</span> <span class="mf">0.064</span> <span class="n">ms</span>
<span class="n">Execution</span> <span class="n">time</span><span class="p">:</span> <span class="mf">0.058</span> <span class="n">ms</span>
</code></pre></div></div>

<p>일부 DB에서는 플래그로 인해 DB에 부정적인 영향을 줄 수도 있다. 예를 들어 PostgreSQL의 ANALYZE 플래그는 트리거가 있거나 SELECT 쿼리의 경우 함께 호출되면 데이터가 변경될 수도 있다.</p>

<h1 id="필드-검색">필드 검색</h1>

<p>‘SQL WHERE’ 구문을 작성한다. QuerySet 메소드(<code class="language-plaintext highlighter-rouge">get()</code>, <code class="language-plaintext highlighter-rouge">exclude()</code> ,<code class="language-plaintext highlighter-rouge">get()</code>)의 키워드 인수로 지정된다.</p>

<h3 id="exact"><code class="language-plaintext highlighter-rouge">exact</code></h3>

<p>조건과 정확히 일치해야한다.<br />
None이면 SQL NULL으로 해석된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">id__exact</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">id__exact</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>

<span class="c1"># SQL
</span><span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="nb">id</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
<span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="nb">id</span> <span class="n">IS</span> <span class="n">NULL</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="iexact"><code class="language-plaintext highlighter-rouge">iexact</code></h3>

<p>조건과 정확히 일치해야하지만 대소문자는 구분하지 않는다.<br />
None이면 SQL NULL으로 해석된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">name__iexact</span><span class="o">=</span><span class="s">'beatles blog'</span><span class="p">)</span>
<span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">name__iexact</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>

<span class="c1"># SQL
</span><span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">name</span> <span class="n">ILIKE</span> <span class="s">'beatles blog'</span><span class="p">;</span>
<span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">name</span> <span class="n">IS</span> <span class="n">NULL</span><span class="p">;</span>

<span class="c1"># 'Beatles Blog', 'beatles blog', 'BeAtLes BLoG' 등이 일치한다.
</span></code></pre></div></div>

<h3 id="contains"><code class="language-plaintext highlighter-rouge">contains</code></h3>

<p>지정한 문자열이 포함하는 객체만 검색한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s">'Lennon'</span><span class="p">)</span>

<span class="c1"># SQL
</span><span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">headline</span> <span class="n">LIKE</span> <span class="s">'%Lennon%'</span><span class="p">;</span>

<span class="c1"># 'Lennon honored today' but not 'lennon honored today'가 일치한다.
</span></code></pre></div></div>

<blockquote>
  <p>SQLite는 대소문자를 구분하는 LIKE문을 지원하지 않는다.</p>
</blockquote>

<h3 id="icontains"><code class="language-plaintext highlighter-rouge">icontains</code></h3>

<p>지정한 문자열이 포함하는 객체만 검색하지만 대소문자를 구별하지는 않는다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">headline__icontains</span><span class="o">=</span><span class="s">'Lennon'</span><span class="p">)</span>

<span class="c1"># SQL
</span><span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">headline</span> <span class="n">ILIKE</span> <span class="s">'%Lennon%'</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="in"><code class="language-plaintext highlighter-rouge">in</code></h3>

<p>주어진 iterator(list, tuple), 혹은 문자열(문자열의 각 문자)의 요소가 있는 객체를 검색한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">id__in</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">headline__in</span><span class="o">=</span><span class="s">'abc'</span><span class="p">)</span>

<span class="c1"># SQL
</span><span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="nb">id</span> <span class="n">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">headline</span> <span class="n">IN</span> <span class="p">(</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">);</span>
</code></pre></div></div>

<p>QuerySet을 지정할 수도 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">inner_qs</span> <span class="o">=</span> <span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">name__contains</span><span class="o">=</span><span class="s">'Cheddar'</span><span class="p">)</span>
<span class="n">entries</span> <span class="o">=</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">blog__in</span><span class="o">=</span><span class="n">inner_qs</span><span class="p">)</span>

<span class="c1"># SQL
</span><span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">blog</span><span class="p">.</span><span class="nb">id</span> <span class="n">IN</span> <span class="p">(</span><span class="n">SELECT</span> <span class="nb">id</span> <span class="n">FROM</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">NAME</span> <span class="n">LIKE</span> <span class="s">'%Cheddar%'</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">values()</code>나 <code class="language-plaintext highlighter-rouge">values_list()</code>에서 나온 QuerySet을 전달하는 경우 하나의 필드만 추출해야 한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">inner_qs</span> <span class="o">=</span> <span class="n">Blog</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">name__contains</span><span class="o">=</span><span class="s">'Ch'</span><span class="p">).</span><span class="n">values</span><span class="p">(</span><span class="s">'name'</span><span class="p">)</span>
<span class="n">entries</span> <span class="o">=</span> <span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">blog__name__in</span><span class="o">=</span><span class="n">inner_qs</span><span class="p">)</span>
</code></pre></div></div>

<p>두 개 이상 지정하면 예외를 발생시킨다.</p>

<h3 id="gt"><code class="language-plaintext highlighter-rouge">gt</code></h3>

<p>Greater then.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">id__gt</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

<span class="c1"># SQL
</span><span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="nb">id</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="gte"><code class="language-plaintext highlighter-rouge">gte</code></h3>

<p>Greater then or equal to.</p>

<h3 id="lt"><code class="language-plaintext highlighter-rouge">lt</code></h3>

<p>Less then.</p>

<h3 id="lte"><code class="language-plaintext highlighter-rouge">lte</code></h3>

<p>Less then or equal to.</p>

<h3 id="startswith"><code class="language-plaintext highlighter-rouge">startswith</code></h3>

<p>지정한 문자열로 시작하는 객체를 검색한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">headline__startswith</span><span class="o">=</span><span class="s">'Lennon'</span><span class="p">)</span>

<span class="c1"># SQL
</span><span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">headline</span> <span class="n">LIKE</span> <span class="s">'Lennon%'</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="istartswith"><code class="language-plaintext highlighter-rouge">istartswith</code></h3>

<p>지정한 문자열(대소분자 구분하지 않음)로 시작하는 객체를 검색한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">headline__istartswith</span><span class="o">=</span><span class="s">'Lennon'</span><span class="p">)</span>

<span class="c1"># SQL
</span><span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">headline</span> <span class="n">ILIKE</span> <span class="s">'Lennon%'</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="endswith"><code class="language-plaintext highlighter-rouge">endswith</code></h3>

<p>지정한 문자열로 끝나는 객체를 검색한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">headline__endswith</span><span class="o">=</span><span class="s">'Lennon'</span><span class="p">)</span>

<span class="c1"># SQL
</span><span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">headline</span> <span class="n">LIKE</span> <span class="s">'%Lennon'</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="iendswith"><code class="language-plaintext highlighter-rouge">iendswith</code></h3>

<p>지정한 문자열(대소문자 구분하지 않음)으로 끝나는 객체를 검색한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">headline__iendswith</span><span class="o">=</span><span class="s">'Lennon'</span><span class="p">)</span>

<span class="c1"># SQL
</span><span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">headline</span> <span class="n">ILIKE</span> <span class="s">'%Lennon'</span>
</code></pre></div></div>

<h3 id="range"><code class="language-plaintext highlighter-rouge">range</code></h3>

<p>검색할 범위를 지정한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">datetime</span>
<span class="n">start_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">end_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">31</span><span class="p">)</span>
<span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">pub_date__range</span><span class="o">=</span><span class="p">(</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="p">))</span>

<span class="c1"># SQL
</span><span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">pub_date</span> <span class="n">BETWEEN</span> <span class="s">'2005-01-01'</span> <span class="ow">and</span> <span class="s">'2005-03-31'</span><span class="p">;</span>
</code></pre></div></div>

<p>날짜, 숫자, 문자 등 SQL BETWEEN을 사용할 수 있는 모든 곳에서 <code class="language-plaintext highlighter-rouge">range()</code>를 사용할 수 있다.</p>

<h3 id="date"><code class="language-plaintext highlighter-rouge">date</code></h3>

<p>datetime 필드는 date를 지정할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">pub_date__date</span><span class="o">=</span><span class="n">datetime</span><span class="p">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">pub_date__date__gt</span><span class="o">=</span><span class="n">datetime</span><span class="p">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="year"><code class="language-plaintext highlighter-rouge">year</code></h3>

<p>date와 datetime 필드는 year를 지정할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2005</span><span class="p">)</span>
<span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">pub_date__year__gte</span><span class="o">=</span><span class="mi">2005</span><span class="p">)</span>

<span class="c1"># SQL
</span><span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">pub_date</span> <span class="n">BETWEEN</span> <span class="s">'2005-01-01'</span> <span class="n">AND</span> <span class="s">'2005-12-31'</span><span class="p">;</span>
<span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">pub_date</span> <span class="o">&gt;=</span> <span class="s">'2005-01-01'</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="iso_year"><code class="language-plaintext highlighter-rouge">iso_year</code></h3>

<p>date, datetime 필드의 경우 ISO 8610 week-numbering year를 지정할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">pub_date__iso_year</span><span class="o">=</span><span class="mi">2005</span><span class="p">)</span>
<span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">pub_date__iso_year__gte</span><span class="o">=</span><span class="mi">2005</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="month"><code class="language-plaintext highlighter-rouge">month</code></h3>

<p>date, datetime 필드는 month를 지정할 수 있다. 정수 1~12까지 가능하다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">pub_date__month</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">pub_date__month__gte</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># SQL
</span><span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">EXTRACT</span><span class="p">(</span><span class="s">'month'</span> <span class="n">FROM</span> <span class="n">pub_date</span><span class="p">)</span> <span class="o">=</span> <span class="s">'12'</span><span class="p">;</span>
<span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">EXTRACT</span><span class="p">(</span><span class="s">'month'</span> <span class="n">FROM</span> <span class="n">pub_date</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="s">'6'</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="day"><code class="language-plaintext highlighter-rouge">day</code></h3>

<p>date, datetime 필드는 day를 지정할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">pub_date__day</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">pub_date__day__gte</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="c1"># SQL
</span><span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">EXTRACT</span><span class="p">(</span><span class="s">'day'</span> <span class="n">FROM</span> <span class="n">pub_date</span><span class="p">)</span> <span class="o">=</span> <span class="s">'3'</span><span class="p">;</span>
<span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">EXTRACT</span><span class="p">(</span><span class="s">'day'</span> <span class="n">FROM</span> <span class="n">pub_date</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="s">'3'</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="week"><code class="language-plaintext highlighter-rouge">week</code></h3>

<p>date, datetime 필드는 ISO-8601에 따른 week number(1-52 or 53)를 지정할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">pub_date__week</span><span class="o">=</span><span class="mi">52</span><span class="p">)</span>
<span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">pub_date__week__gte</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">pub_date__week__lte</span><span class="o">=</span><span class="mi">38</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="week_day"><code class="language-plaintext highlighter-rouge">week_day</code></h3>

<p>date, datetime 필드는 ‘day of the week’를 지정할 수 있다. 1을 일요일, 7은 토요일이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">pub_date__week_day</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">pub_date__week_day__gte</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="quarter"><code class="language-plaintext highlighter-rouge">quarter</code></h3>

<p>date, datetime 필드는 분기별로 지정이 가능하다. 1~4까지 가능하다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">pub_date__quarter</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="time"><code class="language-plaintext highlighter-rouge">time</code></h3>

<p>datetime 필드는 time을 지정할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">pub_date__time</span><span class="o">=</span><span class="n">datetime</span><span class="p">.</span><span class="n">time</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">30</span><span class="p">))</span>
<span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">pub_date__time__range</span><span class="o">=</span><span class="p">(</span><span class="n">datetime</span><span class="p">.</span><span class="n">time</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">datetime</span><span class="p">.</span><span class="n">time</span><span class="p">(</span><span class="mi">17</span><span class="p">)))</span>
</code></pre></div></div>

<h3 id="hour"><code class="language-plaintext highlighter-rouge">hour</code></h3>

<p>datetime, time 필드는 hour를 지정할 수 있다. 정수 0 ~ 23까지 가능하다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Event</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">timestamp__hour</span><span class="o">=</span><span class="mi">23</span><span class="p">)</span>
<span class="n">Event</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">time__hour</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">Event</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">timestamp__hour__gte</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># SQL
</span><span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">EXTRACT</span><span class="p">(</span><span class="s">'hour'</span> <span class="n">FROM</span> <span class="n">timestamp</span><span class="p">)</span> <span class="o">=</span> <span class="s">'23'</span><span class="p">;</span>
<span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">EXTRACT</span><span class="p">(</span><span class="s">'hour'</span> <span class="n">FROM</span> <span class="n">time</span><span class="p">)</span> <span class="o">=</span> <span class="s">'5'</span><span class="p">;</span>
<span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">EXTRACT</span><span class="p">(</span><span class="s">'hour'</span> <span class="n">FROM</span> <span class="n">timestamp</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="s">'12'</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="minute"><code class="language-plaintext highlighter-rouge">minute</code></h3>

<p>datetime, date 필드는 minute 를 지정할 수 있다. 정수 0 ~ 59까지 지정할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Event</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">timestamp__minute</span><span class="o">=</span><span class="mi">29</span><span class="p">)</span>
<span class="n">Event</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">time__minute</span><span class="o">=</span><span class="mi">46</span><span class="p">)</span>
<span class="n">Event</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">timestamp__minute__gte</span><span class="o">=</span><span class="mi">29</span><span class="p">)</span>

<span class="c1"># SQL
</span><span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">EXTRACT</span><span class="p">(</span><span class="s">'minute'</span> <span class="n">FROM</span> <span class="n">timestamp</span><span class="p">)</span> <span class="o">=</span> <span class="s">'29'</span><span class="p">;</span>
<span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">EXTRACT</span><span class="p">(</span><span class="s">'minute'</span> <span class="n">FROM</span> <span class="n">time</span><span class="p">)</span> <span class="o">=</span> <span class="s">'46'</span><span class="p">;</span>
<span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">EXTRACT</span><span class="p">(</span><span class="s">'minute'</span> <span class="n">FROM</span> <span class="n">timestamp</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="s">'29'</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="second"><code class="language-plaintext highlighter-rouge">second</code></h3>
<p>datetime, time 필드는 second를 지정할 수 있다. 정수 0 ~ 59까지 지정할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Event</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">timestamp__second</span><span class="o">=</span><span class="mi">31</span><span class="p">)</span>
<span class="n">Event</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">time__second</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Event</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">timestamp__second__gte</span><span class="o">=</span><span class="mi">31</span><span class="p">)</span>

<span class="c1"># SQL
</span><span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">EXTRACT</span><span class="p">(</span><span class="s">'second'</span> <span class="n">FROM</span> <span class="n">timestamp</span><span class="p">)</span> <span class="o">=</span> <span class="s">'31'</span><span class="p">;</span>
<span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">EXTRACT</span><span class="p">(</span><span class="s">'second'</span> <span class="n">FROM</span> <span class="n">time</span><span class="p">)</span> <span class="o">=</span> <span class="s">'2'</span><span class="p">;</span>
<span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">EXTRACT</span><span class="p">(</span><span class="s">'second'</span> <span class="n">FROM</span> <span class="n">timestamp</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="s">'31'</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="isnull"><code class="language-plaintext highlighter-rouge">isnull</code></h3>

<p>SQL의 ‘IS NULL’, ‘IS NOT NULL’에 해당하는 Boolean을 지정할 수 있다. 지정항 값이 null인 객체를 검색한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">pub_date__isnull</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># SQL
</span><span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">pub_date</span> <span class="n">IS</span> <span class="n">NULL</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="regex"><code class="language-plaintext highlighter-rouge">regex</code></h3>

<p>정규식(대소문자 구분)으로 조건을 지정할 수 있다. SQLite는 정규식 기능이 내장되어 있지 않기 때문에 파이썬의 <code class="language-plaintext highlighter-rouge">re</code> 모듈을 사용해야 한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">title__regex</span><span class="o">=</span><span class="sa">r</span><span class="s">'^(An?|The) +'</span><span class="p">)</span>

<span class="c1"># SQL
</span><span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">title</span> <span class="n">REGEXP</span> <span class="n">BINARY</span> <span class="s">'^(An?|The) +'</span><span class="p">;</span> <span class="o">--</span> <span class="n">MySQL</span>

<span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">REGEXP_LIKE</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="s">'^(An?|The) +'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">);</span> <span class="o">--</span> <span class="n">Oracle</span>

<span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">title</span> <span class="o">~</span> <span class="s">'^(An?|The) +'</span><span class="p">;</span> <span class="o">--</span> <span class="n">PostgreSQL</span>

<span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">title</span> <span class="n">REGEXP</span> <span class="s">'^(An?|The) +'</span><span class="p">;</span> <span class="o">--</span> <span class="n">SQLite</span>
</code></pre></div></div>

<p>정규식을 작성할때 원시 문자열(<code class="language-plaintext highlighter-rouge">r'foo'</code>)를 사용하는게 좋다.</p>

<h3 id="iregex"><code class="language-plaintext highlighter-rouge">iregex</code></h3>

<p>정규식(대소문자 구분 안함)으로 조건을 지정할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">Entry</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">title__iregex</span><span class="o">=</span><span class="sa">r</span><span class="s">'^(an?|the) +'</span><span class="p">)</span>

<span class="c1"># SQL
</span><span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">title</span> <span class="n">REGEXP</span> <span class="s">'^(an?|the) +'</span><span class="p">;</span> <span class="o">--</span> <span class="n">MySQL</span>

<span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">REGEXP_LIKE</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="s">'^(an?|the) +'</span><span class="p">,</span> <span class="s">'i'</span><span class="p">);</span> <span class="o">--</span> <span class="n">Oracle</span>

<span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">title</span> <span class="o">~*</span> <span class="s">'^(an?|the) +'</span><span class="p">;</span> <span class="o">--</span> <span class="n">PostgreSQL</span>

<span class="n">SELECT</span> <span class="p">...</span> <span class="n">WHERE</span> <span class="n">title</span> <span class="n">REGEXP</span> <span class="s">'(?i)^(an?|the) +'</span><span class="p">;</span> <span class="o">--</span> <span class="n">SQLite</span>
</code></pre></div></div>

<h1 id="집계-기능">집계 기능</h1>

<p>Django는 django.db.models 모듈에 여러 집계 함수들을 제공한다.</p>

<p>QuerySet이 비어있으면 모든 집계 함수들은 None을 반환한다.</p>

<h2 id="공통-파라미터">공통 파라미터</h2>

<h4 id="expressions"><code class="language-plaintext highlighter-rouge">expressions</code></h4>

<p>모델의 필드를 참조하는 문자열이나 쿼리 정규식</p>

<h4 id="output_field"><code class="language-plaintext highlighter-rouge">output_field</code></h4>

<p>리턴 값의 타입 필드를 지정할 수 있다.</p>

<h4 id="filter-1"><code class="language-plaintext highlighter-rouge">filter</code></h4>

<p>집계된 행을 필터링한다. Q 객체를 지정한다.</p>

<h4 id="extra-1"><code class="language-plaintext highlighter-rouge">**extra</code></h4>

<p>집계에 의해 생성된 QuerySet에 추가 컨텍스트를 키워드 인수로 지정한다.</p>

<h3 id="avg"><code class="language-plaintext highlighter-rouge">Avg</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Avg</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">output_field</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">extra</span><span class="p">)</span>
</code></pre></div></div>

<p>평균값(float)을 반환한다. output_field로 출력 필드 타입을 바꿀 수 있다.</p>

<h3 id="count-1"><code class="language-plaintext highlighter-rouge">Count</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Count</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">distinct</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">extra</span><span class="p">)</span>
</code></pre></div></div>

<p>조건에 해당하는 객체의 수를 반환한다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">distinct=True</code>인 경우 고유한 인스턴스만 포함된다. SQL의 COUNT(DISTINCT <field>)에 해당한다. 기본값은 False이다.</field></li>
</ul>

<h3 id="max"><code class="language-plaintext highlighter-rouge">Max</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Max</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">output_field</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">extra</span><span class="p">)</span>
</code></pre></div></div>

<p>최대값을 리턴한다.</p>

<h3 id="min"><code class="language-plaintext highlighter-rouge">Min</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Min</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">output_field</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="o">**</span><span class="n">extra</span><span class="p">)</span>
</code></pre></div></div>

<p>최소값을 반환한다.</p>

<h3 id="stddev"><code class="language-plaintext highlighter-rouge">StdDev</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">StdDev</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">output_field</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">sample</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">extra</span><span class="p">)</span>
</code></pre></div></div>

<p>데이터의 표준 편차를 반환한다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">sample=True</code>인 경우 반환 값은 샘플 표준 편차이다.</li>
</ul>

<h3 id="sum"><code class="language-plaintext highlighter-rouge">Sum</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Sum</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">output_field</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">extra</span><span class="p">)</span>
</code></pre></div></div>

<p>모든 값의 합계를 반환한다.</p>

<h3 id="variance"><code class="language-plaintext highlighter-rouge">Variance</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Variance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">output_field</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">sample</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">extra</span><span class="p">)</span>
</code></pre></div></div>

<p>데이터의 분산을 반환한다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">sample=True</code>인 경우 반환값은 샘플의 분산이다.</li>
</ul>

<h1 id="query-related-tools">Query-related tools</h1>

<h3 id="q-objects"><code class="language-plaintext highlighter-rouge">Q()</code> objects</h3>

<p><code class="language-plaintext highlighter-rouge">Q()</code>객체는 F 객체와 마찬가지로 DB 작업에 사용할 수 있는 파이썬의 SQL expression을 캡슐화한다.</p>

<p><code class="language-plaintext highlighter-rouge">Q()</code>객체는 조건을 정의하고 재사용할 수 있다.<code class="language-plaintext highlighter-rouge">|</code>(OR), <code class="language-plaintext highlighter-rouge">&amp;</code>(AND) 연산자를 사용하여 복잡한 DB 쿼리를 구축할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Q() prefetch_related_objects
</span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">Q</span>

<span class="n">Q1</span> <span class="o">=</span> <span class="n">Q</span><span class="p">(</span><span class="n">first_name__startswith</span><span class="o">=</span><span class="s">'J'</span><span class="p">)</span>
<span class="n">Q2</span> <span class="o">=</span> <span class="n">Q</span><span class="p">(</span><span class="n">first_name__endswith</span><span class="o">=</span><span class="s">'e'</span><span class="p">)</span>
<span class="n">User</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">Q1</span> <span class="o">&amp;</span> <span class="n">Q2</span><span class="p">)</span>
<span class="n">User</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">Q1</span> <span class="o">|</span> <span class="n">Q2</span><span class="p">)</span>

<span class="c1"># F() expression
# F()를 사용하면 Django는 파이썬 메모리가 아닌 DB 내부에서 계산 논리를 수행하는 쿼리를 생성한다.
</span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">F</span>

<span class="n">e</span> <span class="o">=</span> <span class="n">Event</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">e</span><span class="p">.</span><span class="n">event_date</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="s">'event_date'</span><span class="p">)</span> <span class="o">+</span> <span class="n">datetime</span><span class="p">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">e</span><span class="p">.</span><span class="n">save</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="prefetch-objects"><code class="language-plaintext highlighter-rouge">Prefetch()</code> objects</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Prefetch</span><span class="p">(</span><span class="n">lookup</span><span class="p">,</span> <span class="n">queryset</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">to_attr</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Prefetch()</code>객체를 사용하여 <code class="language-plaintext highlighter-rouge">prefetch_related</code>의 동작을 제어할 수 있다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">lookup</code> 인수에 따라야 할 관계를 지정하면 <code class="language-plaintext highlighter-rouge">prefetch_related()</code>에 전달된 문자열 기반 조회와 동일하게 동작한다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">Prefetch</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Question</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">prefetch_related</span><span class="p">(</span><span class="n">Prefetch</span><span class="p">(</span><span class="s">'choice_set'</span><span class="p">)).</span><span class="n">get</span><span class="p">().</span><span class="n">choice_set</span><span class="p">.</span><span class="nb">all</span><span class="p">()</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">Choice</span><span class="p">:</span> <span class="n">Not</span> <span class="n">much</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">Choice</span><span class="p">:</span> <span class="n">The</span> <span class="n">sky</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">Choice</span><span class="p">:</span> <span class="n">Just</span> <span class="n">hacking</span> <span class="n">again</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span>
<span class="c1"># This will only execute two queries regardless of the number of Question
# and Choice objects.
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">Question</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">prefetch_related</span><span class="p">(</span><span class="n">Prefetch</span><span class="p">(</span><span class="s">'choice_set'</span><span class="p">)).</span><span class="nb">all</span><span class="p">()</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">Question</span><span class="p">:</span> <span class="n">What</span><span class="s">'s up?&gt;]&gt;
</span></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">queryset</code> 인수는 주어진 조회에 대한 기본 QuerySet을 제공한다. 프리패치 조작을 추가로 필터링하거나, 프리패치된 관계에서 <code class="language-plaintext highlighter-rouge">select_related()</code>를 호출하여 조회수를 더 줄이게 해준다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">voted_choices</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">votes__gt</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">voted_choices</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">Choice</span><span class="p">:</span> <span class="n">The</span> <span class="n">sky</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">prefetch</span> <span class="o">=</span> <span class="n">Prefetch</span><span class="p">(</span><span class="s">'choice_set'</span><span class="p">,</span> <span class="n">queryset</span><span class="o">=</span><span class="n">voted_choices</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Question</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">prefetch_related</span><span class="p">(</span><span class="n">prefetch</span><span class="p">).</span><span class="n">get</span><span class="p">().</span><span class="n">choice_set</span><span class="p">.</span><span class="nb">all</span><span class="p">()</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">Choice</span><span class="p">:</span> <span class="n">The</span> <span class="n">sky</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">to_attr</code> 인수는 프리패치 작업의 결과를 사용자 정의 속성으로 설정한다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">prefetch</span> <span class="o">=</span> <span class="n">Prefetch</span><span class="p">(</span><span class="s">'choice_set'</span><span class="p">,</span> <span class="n">queryset</span><span class="o">=</span><span class="n">voted_choices</span><span class="p">,</span> <span class="n">to_attr</span><span class="o">=</span><span class="s">'voted_choices'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Question</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">prefetch_related</span><span class="p">(</span><span class="n">prefetch</span><span class="p">).</span><span class="n">get</span><span class="p">().</span><span class="n">voted_choices</span>
<span class="p">[</span><span class="o">&lt;</span><span class="n">Choice</span><span class="p">:</span> <span class="n">The</span> <span class="n">sky</span><span class="o">&gt;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Question</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">prefetch_related</span><span class="p">(</span><span class="n">prefetch</span><span class="p">).</span><span class="n">get</span><span class="p">().</span><span class="n">choice_set</span><span class="p">.</span><span class="nb">all</span><span class="p">()</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">Choice</span><span class="p">:</span> <span class="n">Not</span> <span class="n">much</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">Choice</span><span class="p">:</span> <span class="n">The</span> <span class="n">sky</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">Choice</span><span class="p">:</span> <span class="n">Just</span> <span class="n">hacking</span> <span class="n">again</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span>
</code></pre></div></div>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">to_attr</code>을 사용하면 프리패치된 결과가 리스트에 저장된다. 이건 QuerySet 인스턴스 내부에 저장하는 <code class="language-plaintext highlighter-rouge">prefetch_related</code>보다 속도를 크게 향상시킬 수 있다.</p>
</blockquote>

<h3 id="prefetch_related_objects"><code class="language-plaintext highlighter-rouge">prefetch_related_objects()</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">prefetch_related_objects</span><span class="p">(</span><span class="n">model_instance</span><span class="p">,</span> <span class="o">*</span><span class="n">related_lookups</span><span class="p">)</span>
</code></pre></div></div>

<p>반복 가능한 모델 인스턴스에서 지정된 조회를 프리패치한다. QuerySet과는 반대로 모델 인스턴스 목록을 받을 때 유용하다. (캐시에서 모델을 가져오거나, 수동으로 인스턴스화 할때)</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">prefetch_related_objects</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">restaurants</span> <span class="o">=</span> <span class="n">fetch_top_restaurants_from_cache</span><span class="p">()</span>  <span class="c1"># A list of Restaurants
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">prefetch_related_objects</span><span class="p">(</span><span class="n">restaurants</span><span class="p">,</span> <span class="s">'pizzas__toppings'</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="filteredrelation-objects"><code class="language-plaintext highlighter-rouge">FilteredRelation()</code> objects</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">FilteredRelation</span><span class="p">(</span><span class="n">relation_name</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">conditino</span><span class="o">=</span><span class="n">Q</span><span class="p">())</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">relation_name</code>: 관계를 필터링하려는 필드의 이름</li>
  <li><code class="language-plaintext highlighter-rouge">condition</code>: 필터링을 제어하는 Q 객체</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">FilteredRelation</code>은 JOIN이 수행될때 ON 구문을 만들기 위해 <code class="language-plaintext highlighter-rouge">annotate()</code>와 함께 사용해야 한다. 기본 관계가 아닌 annotate의 이름에 영향을 준다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 이름에 'mozzarella'가 포함된 vegetarial가 있는 식당 조회
</span><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">FilteredRelation</span><span class="p">,</span> <span class="n">Q</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Restaurant</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">annotate</span><span class="p">(</span>
<span class="p">...</span>    <span class="n">pizzas_vegetarian</span><span class="o">=</span><span class="n">FilteredRelation</span><span class="p">(</span>
<span class="p">...</span>        <span class="s">'pizzas'</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="n">Q</span><span class="p">(</span><span class="n">pizzas__vegetarian</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span>
<span class="p">...</span>    <span class="p">),</span>
<span class="p">...</span> <span class="p">).</span><span class="nb">filter</span><span class="p">(</span><span class="n">pizzas_vegetarian__name__icontains</span><span class="o">=</span><span class="s">'mozzarella'</span><span class="p">)</span>

<span class="c1"># 피자가 많은 경우
# 첫 번째 queryset의 WHERE 구문에서 필터링하면 vegetarial에서만 동작하기 때문에 성능이 위 코드보다 좋다.
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">Restaurant</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span>
<span class="p">...</span>     <span class="n">pizzas__vegetarian</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
<span class="p">...</span>     <span class="n">pizzas__name__icontains</span><span class="o">=</span><span class="s">'mozzarella'</span><span class="p">,</span>
<span class="p">...</span> <span class="p">)</span>
</code></pre></div></div>

<h4 id="filteredrelation가-지원하지-않는-것"><code class="language-plaintext highlighter-rouge">FilteredRelation</code>가 지원하지 않는 것</h4>

<ul>
  <li>관계형 필드에 조건을 추가</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Restaurant</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">annotate</span><span class="p">(</span>
<span class="p">...</span>    <span class="n">pizzas_with_toppings_startswith_n</span><span class="o">=</span><span class="n">FilteredRelation</span><span class="p">(</span>
<span class="p">...</span>        <span class="s">'pizzas__toppings'</span><span class="p">,</span>
<span class="p">...</span>        <span class="n">condition</span><span class="o">=</span><span class="n">Q</span><span class="p">(</span><span class="n">pizzas__toppings__name__startswith</span><span class="o">=</span><span class="s">'n'</span><span class="p">),</span>
<span class="p">...</span>    <span class="p">),</span>
<span class="p">...</span> <span class="p">)</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
<span class="p">...</span>
<span class="nb">ValueError</span><span class="p">:</span> <span class="n">FilteredRelation</span><span class="s">'s condition doesn'</span><span class="n">t</span> <span class="n">support</span> <span class="n">nested</span> <span class="n">relations</span> <span class="p">(</span><span class="n">got</span> <span class="s">'pizzas__toppings__name__startswith'</span><span class="p">).</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">QuerySet.only()</code>, <code class="language-plaintext highlighter-rouge">prefetch_related()</code></li>
  <li>부모 모델에서 상속된 <code class="language-plaintext highlighter-rouge">GenericForeignKey</code></li>
</ul>
:ET