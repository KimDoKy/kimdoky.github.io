---
layout: post
section-type: post
title: Two Scoops of Django - chap6. 장고에서 모델 이용하기
category: django
tags: [ 'django' ]
---

모델은 장고 프로젝트의 토대가 되는 부분이다. 성급하게 작성한다면 추후에 모델을 변경하거나 추가하게 될때, 최악의 경우 기존 데이터가 충돌하는 상황이 발생한다. 따라서 새 모델을 추가하거나 기존 모델을 수정할 때는 가능한한 탄탄하고 안전하게 다질 수 있는 방향으로 디자인을 고려해야 한다.

> #### 모델을 작업하면서 이용할 수 있는 장고 패키지들  
- django-model-utils: TimeStampedModel 같은 일반적인 패턴들을 처리하는 게 이용
- django-extensions: 모든 앱에 모델 클래스를 자동으로 로드해 주는 `shell_plus`라는 강력한 관리 명령을 제공한다. 단점은 '작지만 역할이 분명한 앱' 개념에 맞지 않게 너무 다양한 기능을 포함하고 있다.

## 6.1 시작하기

### 6.1.1 모델이 너무 많으면 앱을 나눈다.
앱 하나에 20개 이상의 모델이 있다면 크기가 작은 앱으로 분리할 것을 고민해야 한다. 각 앱이 가진 모델이 5개를 넘지 않는게 좋다.

### 6.1.2 모델 상속에 주의하자
장고는 3가지 모델 상속 방법을 제공한다. **추상화 기초 클래스(abstract base class)**, **멀티테이블 상속(multitable inheritance)**, **프락시 모델(proxy model)** 이다.

> #### 장고 추상화 기초 클래스 <> 파이썬 추상화 기초 클래스  
파이썬 표준 라이브러리의 abc 모듈에서 이야기하는 추상화 기초 클래스와 장고에서 말하는 추상화 기초 클래스는 목적이 전혀 다르므로 이 둘을 혼동하면 안된다.

모델의 상속 스타일 | 장점 | 단점
---|---|---
상속을 이용하지 않는 경우:<br>모델들 사이에 공통 필드가 존재할 경우, 두 모델에 전부 모델 필드를 만들어 준다. | 데이터베이스 테이블에 어떤 식으로 매핑되든지 상관없이 장고 모델을 한 눈에 이해하기 쉽게 구성된다. | 모델들 사이에 서로 중복되는 테이블이 많을 경우 이를 지속적으로 관리하는데 어려움이 따른다.
추상화 기초 클래스:<br>오직 상속받아 생성된 모델들의 테이블만 생성된다. | 추상화된 클래스에 공통적인 부분을 추려 놓음으로써 한 번만 타이핑을 하면 된다.<br>추가 테이블이 생성되지 않고 여러 테이블에 걸쳐 조인을 함으로써 발생하는 성능 저하도 없다. | 부모 클래스를 독립적으로 이용할 수 없다.
멀티테이블 상속:<br>자식 모델에 대해서도 모두 테이블이 생성된다. OneToOneField는 부모와 자식 간에 적용된다. | 각 모델에 대해 매칭되는 테이블이 생성된다. 따라서 부모 또는 자식 모델 어디로든지 쿼리를 할 수 있다. 부모 객체로부터 자식 객체를 호출하는 것이 가능하다: parent.child | 자식 테이블에 대한 각 쿼리에 대해 부모 테이블로의 조인이 필요하므로 이에 따른 상당한 부하가 발생한다. 멀티테이블 상속을 이용하지 않기를 권한다. 다음에 나오는 경고를 참고
프락시 모델:<br>원래 모델에 대해서만 테이블이 생성된다. | 각기 다른 파이썬 작용(behavior)을 하는 모델들의 별칭을 가질 수 있다. | 모델의 필드를 변경할 수 없다.

> #### 멀티테이블 상속은 피하자.  
접합 상속(concrete inheritance)라고도 부르는 멀티테이블 상속은 실제로 이를 만든 사람과 여타 개발자로부터 그닥 환영받지 못한다. 따라서 가능한 한 이용하지 않는 것이 좋다.

- 모델 사이에서 중복되는 내용이 최소라고 한다면(오직 한두 개의 명확한 필드만이 여러 개의 모델 사이에서 공유되는 경우), 모델의 상속 자체가 필요 없을 것이다. 그냥 모델 두 곳에 필드를 추가하면 된다.
- 모델들 사이에 중복된 필드가 혼란을 야기하거나 의도하지 않은 실수를 유발할 정도로 많을 때, 대부분의 경우 공통 필드 부분이 추상화 기초 모델로 이전 될 수 있게 리팩터링할 수 있다.
- 프락시 모델은 종종 편리하게 이용되지만 다른 두 가지 모델 상속 방식과는 사뭇 다르게 작동한다는 점을 주지해야 한다.
- 멀티테이블 상속은 혼란과 상당한 부하를 일으키므로 반드시 피해야 한다. 멀티테이블 상속을 이용하는 대신 모델들 사이에서 좀 더 명확한 OneToOneField와 ForeignKey를 이용함으로써 조인이 난립할 때도 좀 더 수월하게 컨트롤할 수 있다.

### 6.1.3 실제로 모델 상속해 보기: TimeStampedModel
장고의 모든 모델에서 created와 modified 타임스탬프 필드를 생성해 두는 것은 일반적이다. 전 모델에 걸쳐 일일이 이 두가지 필드를 추가할 수도 있지만 작업량도 많고 실수할 가능성도 높다. 이를 위해 TimeStampedModel을 만들어 이 모델이 우리 대신 필드 추가를 처리하게 하면 된다.

```python
# core/models.py
from django.db import models

class TimeStampedModel(models.Model):
    """
    'created'와 'modified' 필드를 자동으로 업데이트 해두는
    추상화 기반 클래스 모델
    """
    created = models.DateTimeField(auto_now_add=True)
    modified = models.DateTimeField(auto_now_add=True)

    class Meta:
        abstract = True
```

마지막 두줄이 추상화 기초 클래스로 변경해 주는 역할을 한다.

```python
class Meta:
    abstract = True
```
TimeStampedModel을 상속하는 새로운 클래스를 정의할 때 TimeStampedModel을 추상화 기초 클래스로 선언함으로써 장고에서 마이그레이션을 실행할 때 core_timestampedmodel 테이블이 생성되지 않는다.

```python
# flavors/models.py
from django.db import models

from core.models import TimeStampedModel

class flavor(TimeStampedModel):
    title = models.CharField(max_length=200)
```

이 코드는 오직 하나의 flavors_flavor 데이터베이스 테이블만 생성한다. 정확히 원했던 동작만 한다.  
TimeStampedModel이 추상화 클래스가 아니었다면 core_timestampedmodel 테이블이 같이 생성되었을 것이다. 뿐만 아니라 Flavor를 포함한 모든 서브클래스들이 자신만의 시간 필드를 가지지 못하고 TimeStampedModel과 연결되는 외부키를 통해 created/modified 타임스탬프를 처리하고 있었을 것이다. 따라서 Flavor에서 TimeStampedModel에 읽고 쓰는 모든 레퍼런스들은 늘 두 개의 테이블에 영향을 미쳤을 것이다.  

즉, 접합 기반 상속은 심각한 성능 문제를 일으킬 소지가 있고 여러번 서브클래스화해서 이용하면 문제는 더욱 커질 것이다.

### 6.1.4 데이터베이스 마이그레이션
마이그레이션을 생성하는 팁이다.

- 새로운 앱이나 모델이 생성되면 새 모델에 대해 django.db.migrations을 실행한다.
- 생성된 마이그레이션 코드를 실행하기 전에 생성된 코드를 살펴본다. 특히 복잡한 변경 사항이 적용된 경우 더욱 꼼꼼히 살핀다. 또한 `sqlmigrate` 명령을 통해 어떤 SQL 문이 실행되는지도 확인한다.
- 자체적인 django.db.migrations 스타일로 이루어지지 않은 외부 앱에 대해 마이그레이션을 처리할 때는 MIGRATION_MODULES 세팅을 이용한다.
- 생성되는 마이그레이션 갯수에 연연하지 않는다. 너무 많은게 불편하다면 `squashmigrations`를 이용한다.

마이그레이션의 배포와 관리 팁이다.

- 배포 전에 마이그레이션을 되돌릴(rollback) 수 있는지 확인해 보자. 완벽한 복구가 아닌 적정 수준까지 되돌리기가 불가능하다면 규모가 큰 프로젝트에서는 버그 트래킹이나 배포 시에 큰 문제가 될 수 있다.
- 데이블에 수백만 개의 데이터가 이미 존재한다면 운영 서버에서 실제로 마이그레이션을 실행하기 이전에 스테이징 서버에서 비슷한 크기의 데이터에 대해 충분히 테스트하자. 운영 서버에서의 마이그레이션은 생각하는 것보다 더 '많은' 시간이 걸린다.
- MySQL을 이용한다면 다음과 같이 한다.
  - 스키마를 변환하기 전에 데이터베이스를 반드시 백업해 둔다. MySQL은 스키마 변경에 대해 트랜젝션을 지원하지 않는다. 따라서 롤백이 불가능하다.
  - 가능하다면 데이터베이스를 변환하기 이전에 프로젝트를 읽기 전용(read-only) 모드로 변경해 준다.
  - 상당히 큰 테이블의 경우 주의하지 않으면 스키마 변경에 상당한 시간이 소요된다. 초 단위, 분 단위가 아니라 몇 시간이 걸릴 수도 있다.

  ![]({{site.url}}/img/post/django/two_scoops/6.1.png)
> 겨울이 오기 전에 남쪽(south)으로 이주(migration)하는 아이스크림 콘들.  
장고에 내장된 마이그레이션 시스템은 사우스라는 외부 프로젝트로부터 시작되었다.

## 6.2 장고 모델 디자인

### 6.2.1 정규화하기
**데이터베이스 정규화(database normalization)** 에 익숙해져야 한다.

- <https://en.wikipedia.org/wiki/DataBase_normalization>
- <https://en.wikipedia.org/wiki/Relational_Database_Design/Normalization>

장고 모델 디자인은 항상 정규화로부터 시작하자. 충분한 시간을 가지고 이미 모델에 포함된 데이터들이 중복되어 다시 다른 모델에 포함되지 않도록 신경써야 한다.  
이 단계에서는 관계 필드에 대해 제약을 느끼지 않아도 된다. 일단 미숙하게 비정규화하는 것부터 피한다. 바로 데이터의 형태와 틀에 대한 지각이 필요하다.

### 6.2.2 캐시와 비정규화
적절한 위치에서 캐시를 세팅하는 것은 모델을 비정규화할 때 발생하는 문제점들을 상당 부분 해결해 주기도 한다.

### 6.2.3 반드시 필요한 경우에만 비정규화를 하도록 하자
비정규화가 프로젝트의 해답처럼 보일수도 있지만 곧 프로젝트 자체를 더욱 복잡하게 만들고 데이터를 손상시킬 수 있는 위험을 증가시킬 것이다. 비정규화를 생각하기 이전에 캐시에 대해 좀 더 연구할 필요가 있다.

### 6.2.4 언제 널을 쓰고 공백을 쓸 것인가
모델 필드를 정의할 때 `null=True`와 `blank=True`를 설정하는 옵션을 선택할 수 있다. 기본값은 둘 다 False이다.  

모델 필드 인자들에 대한 일반적인 가이드이다.

필드 타입 | `null=True`로 설정하기 | `blank=True`로 설정하기
---|---|---
CharField, TextField, SlugField, EmailField, CommaSeparatedIntegerField, UUIDField | 이용하지 않는다. 장고 표준은 빈 값(empty value)을 빈 문자열(empty string)로 저장하는 것이다. 일관성을 위해 널값 또는 빈 값을 빈 문자열에 대해 반환하도록 한다. | 이용한다. 위젯이 빈 값을 허용하기를 원한다면 설정한다. 이렇게 설정하면 데이터베이스에서는 빈 값이 빈 문자열로 저장된다.
FileField, ImageField | 이용하지 않는다. 장고는 MEDIA_ROOT의 경로를 CharField에 파일 또는 이미지로 저장한다. 따라서 같은 패턴이 FileField에도 적용된다. | 이용한다. CharField에 적용된 것과 같은 규칙이 적용된다.
BooleanField | 이용하지 않는다. 대신 NullBooleanField를 이용한다. | 이용하지 않는다.
IntegerField, FloatField, DecimalField, DurationField 등 | 해당 값이 데이터베이스에 NULL로 들어가도 문제가 없다면 이용한다. | 위젯에서 해당 값이 빈 값을 받아와도 문제가 없다면 이용한다. 그럴 경우 null=True와 같이 이용한다.
DateTimeField, DateField, TimeField 등 | 데이터베이스에서 해당 값들을 NULL로 설정하는 게 가능하다면 이용한다. | 위젯에서 해당 값이 빈 값을 받아와도 문제가 없다거나 auto_now나 auto_now_add를 이용하고 있다면 이용한다. 그럴 경우 null=True와 같이 이용한다.
ForeignKey, ManyToManyField, OneToOneField | 데이터베이스에서 해당 값들을 NULL로 설정하는게 가능하다면 이용한다. | 위젯에서 해당 값(예를 들어 셀렉트박스)이 빈 값을 받아 와도 괜찮다면 이용한다.
GenericIPAddressField | 데이터베이스에서 해당 값들을 NULL로 설정하는게 가능하다면 이용한다. | 위젯에서 해당 값이 빈 값을 받아와도 괜찮다면 이용한다.
IPAddressField | 이용하지 않는다. | 이용하지 않는다.

> #### IPAddressField 대신에 GenericIPAddressField 이용하기  
IP4와 IP6의 동시 지원을 포함한 여러 이유로 GenericIPAddressField가 IPAddressField보다 훨씬 선호된다. IPAddressField는 장고 1.7 이후로 사라질 것이기 때문에 GenericIPAddressField를 이용하는 것이 좋다.

### 6.2.5 언제 BinaryField를 이용할 것인가?
BinaryField는 로우 바이너리 데이터(raw binary data) 또는 바이드(byte)를 저장하는 필드다. 해당 필드에서는 filter, exclude, 기타 SQL 액션들이 적용되지 않는다. BinaryField는 다음과 같은 내용을 저장하는데 쓰일 수 있다.

![]({{site.url}}/img/post/django/two_scoops/6.2.png)
> 일반적으로 우리가 헷갈리는 것  
바닐라 맛은 널 제로(zero)일까? 빈 문자열일까?

- 메시지팩 형식의 콘텐츠
- 원본 센서 데이터
- 압축된 데이터. 예를 들어 센트리(Sentry)가 블롭(BLOB)으로 저장했지만 레거시 이슈 등으로 base64로 인코딩된 데이터들의 형식

이외에도 다양한 곳에 이용될 수 있다. 하지만 바이너리 데이터는 크기가 방대할 수도 있고 그로 인해 데이터베이스가 느려질 수 있다, 실제로 그런 경우가 발생해서 바이너리 데이터 저장이 병목 지점이 된다면 해당 데이터를 파일 형태로 저장하고 FileField에 레퍼런스만 저장하는 방법으로 해결할 수 있다.

> #### BinaryField로부터 파일을 직접 서비스하는 것은 금물!  
데이터베이스 필드에 파일을 직접 저장하는 것은 피해야한다. 데이터베이스 필드에 파일을 직접 저장하는 방법을 고려 중이라면 주변에 데이터베이스 전문가에세 조언을 구해야 한다.  
PostgreSQL 전문가인 프랭크 와일스가 데이터베이스를 파일 저장소로 이용하는 것에 대한 문제점을 이야기한 사항은 다음과 같다.
- 데이터베이스의 '읽기/쓰기' 속도는 항상 파일 시스템의 '읽기/쓰기' 속도보다 느리다.
- 데이터베이스 백업에 드는 공간과 시간이 점점 증가하게 된다.
- 파일 자체에 접근하는 데 앱(장고) 레이어와 데이터베이스 레이어 둘 다를 거쳐야만 한다.  

### 6.2.6 범용 관계 피하기

**범용 관계(generic relations)** 이용과 `models.field.GenericForeignKey` 이용은 장점보다는 단점이 더 많다. 프로젝트에서 이 두가지가 빈번히 이용되고 있다면 머지 않아 큰 문제가 발생하게 될 것이다.  

범용 관계란 한 테이블로부터 다른 테이블을 서로 제약 조건이 없는 외부 키(unconstrained foreign key, GenericForeignKey)로 바인딩하는 것이다. 이러한 개념은 외부 키 제약(foreign key constraints)이란 조건이 원래부터 존재하지 않았던 NoSQL 데이터베이스를 이용하는 것과 비슷하다. 이는 마치 외부 키 제약 조건이 필요한 프로젝트에서 외부 키 제약 조건을 사용하지 않는 것과 같은 경우다. 따라서 다음과 같은 문제가 야기 된다.

- 모델 간의 인덱싱이 존재하지 않으면 쿼리 속도에 손해를 가져오게 된다.
- 다른 테이블에 존재하지 않는 레코드를 참조할 수 있는 데이터 충돌의 위험성이 존재한다.

제약 조건 부재로 인한 장점은 기존에 만들어 놓은 여러 모델 타입과 상호 작용하는 앱을 새로 제작할 때 훨씬 수월해진다는 점이다. 특히 즐겨찾기(favorites), 평점 매기기(ratings), 투표(voting), 메시지(messages), 태깅(tagging) 앱들의 경우 그러하다. 범용 관계에 기반한 앱을 달가와 하지 않지만, 사실 기존의 앱들이 이렇게 만들어져 있기도 하다. 그렇게 제작된 앱들은 다행히 단일 임무만 수행하는 앱이다.  

위 앱들은 ForeignKey와 ManyToManyField를 이용하지 않고도 구현할 수 있다. 또한 약간의 추가적인 작업으로 GenericForeignKey를 이용하지 않을 수 있고, 이를 통해 속도와 무결성을 개선할 수 있다.  

- 범용 관계와 GenericForeignKey 이용은 피한다.
- 범용 관계가 필요하다면, 모델 디자인을 새롭게 바꾸거나 새로운 PostgreSQL 필드를 통해 해결할 수 있는지 확인한다.
- 불가피하게 이용해야만 하는 경우라면 서드 파티 앱을 사용하는 것을 고려 해 보자. 독립적인 외부 앱의 경우 데이터들을 깔끔하게 유지하는 데 도움을 준다.

### 6.2.7 PostgreSQL에만 존재하는 필드에 대해 언제 널을 쓰고 언제 공백을 쓸 것인가

필드 타입 | null=True로 설정하기 | blank=True로 설정하기
---|---|---
ArrayField | 가능 | 가능
HStoreField | 가능 | 가능
IntegerRangeField, BigIntegerRangeField, FloatRangeField | 데이터베이스에서 해당 값들을 NULL로 설정할 수 있다면 이용 가능 | 위젯에서 해당하는 폼이 빈 값을 허용하기를 원한다면 null=True와 함께 사용
DateTimeRangeField, DateRangeField | 데이터베이스에서 해당 값들을 NULL로 설정할 수 잇다면 이용 가능 | 위젯에서 해당하는 폼이 빈 값을 허용하기를 원하는 경우 또는 auto_now나 auto_now_add를 이용하고 있다면 이용 가능하다. 단 이런 경우 null=True와 함게 사용해야 한다.

## 6.3 모델의 \_meta API
장고에서 \_meta의 원래 목적은 모델에 대한 부가적인 정보를 장고 내부적으로 이용하기 위해서이다.  

대부분의 프로젝트에서는 \_meta 기능까지는 필요 없다. 필요한 이유들은 다음과 같을 것이다.

- 모델 필드의 리스트를 가져올 때
- 모델의 특정 필드의 클래스를 가져올 때(또는 상속 관계나 상속 등을 통해 생성된 정보를 가져올 때)
- 앞으로의 장고 버전들에서 이러한 정보를 어떻게 가져오게 되었는지 확실하게 상수로 남기기를 원할 때

다음과 같은 상황에서 사용한다.

- 장고 모델의 자체 검사 도구
- 라이브러리를 이용해서 특별하게 커스터마이징된 자신만의 장고를 만들 때
- 장고의 모델 데이터를 조정하거나 변경할 수 있는 일종의 관리 도구를 제작할 때
- 시각화 또는 분석 라이브러리를 제작할 때, 예를 들어, 'foo'라는 단어로 시작하는 필드에 대한 분석 정보

더 읽어 볼 자료들

- 모델 \_meta 문서 : <https://docs.djangoproject.com/en/1.11/ref/models/meta/>
- 모델 \_meta에 대한 장고 릴리스 노트 : <https://docs.djangoproject.com/en/1.11/releases/1.11/#model-meta-api>

## 6.4 모델 매니저
모델에 질의를 하게 되면 장고의 ORM을 통하게 된다. 이때 **모델 매니저(model manager)** 라는 데이터베이스와 연동하는 인터페이스를 호출하게 된다. 이 모델 매니저는 우리가 원하는 클래스들을 제어하기 위해 모델 클래스(테이블 안의 모든 데이터)의 모든 인스턴스 세트에 작동하게 된다. 장고는 각 모델 클래스에 대한 기본 모델 매니저를 제공하고, 스스로 제작할 수도 있다.

```python
# 간단한 커스텀 모델 메니저 샘플
from django.db import models
from django.utils import timezone

class PublishedManager(models.Manager):

    use_for_related_fields = True

    def published(self, **kwargs):
        return self.filter(pub_date__lte=timezone.now(), **kwargs)

class FlavorReview(models.Model):
    review = models.CharField(max_length=255)
    pub_date = models.DateTimeField()

    # 커스텀 모델 매니저를 여기에 추가한다.
    objects = PublishedManager()
```

이제 아이스크림의 맛에 대한 평가가 몇 개인지, 그중에서 퍼블리시된 것들은 몇 개인지 알고 싶다면 다음처럼 하면 된다.

```python
>>> from reviews.models import FlavorReview
>>> FlavorReview.objects.count()
35
>>> FlavorReview.objects.published().count()
31
```

추가적인 모델 매니저를 만드는 것이 더 이치에 맞다고 생각한다면 다음과 같이 해야 한다.

```python
# 나쁜 예
>>> from reviews.models import FlavorReview
>>> FlavorReview.objects.filter().count()
35
>>> FlavorReview.published.filter().count()
31
```

피상적으로는 기존 모델 매니저를 교체하는 것이 좀 더 명확한 방법으로 보일수도 있지만 매우 주의를 기울여야 한다.  
첫째, 모델을 상속받아 이용할 때 추상화 기초 클래스들의 자식들은 부모 모델의 모델 매니저를 받게 되고 접합 기반 클래스들의 자식들은 그렇지 못하다.
둘째, 모델 클래스에 적용되는 첫 번째 매니저는 장고가 기본값으로 취급하는 매니저다. 이는 파이썬의 일반적인 패턴을 무시하는 것으로 쿼리세트(QuerySets)로부터의 결과를 예상할 수 없게 만든다.  
이러한 점을 반드시 숙지하고 모델 클래스에서 objects = models.Manager() 를 커스텀 모델 매니저 위에 일일이 정의해야 한다.

> #### 모델 매니저 적용 순서 알기  
objects = models.Manager()는 항상 새로운 이름의 커스텀 모델 매니저 위에 두도록 한다.

추가적으로 읽을 거리  
<https://docs.djangoproject.com/en/1.11/topics/db/managers/>

## 6.5 거대 모델 이해하기
**거대 모델(fat model)** 개념은 데이터 관련 코드를 뷰나 템플릿에 넣기보다는 모델 메서드, 클래스 매서드, 프로퍼티, 매니저 메서드 안에 넣어 캡슐화하는 것이다. 이러면 어떤 뷰나 여타의 작업이라도 같은 로직을 이용할 수 있습니다. 예를 들어 아이스크림 리뷰를 보여주는 모델이 있다면 다음 메서드를 덧붙일 수 있다.

- Review.create_view(cls, user, title, description): 리뷰를 생성하는 class-method. HTML과 REST 뷰에서 호출되는 모델 클래스 그리고 스프레드시트를 처리하는 임포트 도구에서 호출된다.
- review.product_average: 리뷰된 프로젝트의 평균 점수를 반환하는 리뷰 인스턴스의 속성. 리뷰 상세 뷰에 이용되며 사용자가 페이지를 떠나지 않고 평가 의견 전부를 알 수 있게 한다.
- review.found_useful(self, user, yes): 해당 리뷰가 유용했는지 아닌지 사용자가 기록할 수 있는 메서드. 세부 항목 뷰와 리스트 뷰에서 HTML과 REST 구현에 둘 다 이용한다.

거대 모델은 프로젝트 전체를 통해 코드 재사용을 개선할 수 있는 최고의 방법이다.  
하지만 모든 로직을 모델 안으로 넣으려는 데 따르는 문제점은 모델 크기의 크기를 **신의 객체(god object)** 수준으로 폭발적으로 증가시킨다는 데 있다. 이런 안티 패턴의 결과고 모델 클래스가 수백, 수천, 수만 줄의 코드가 되어 버리기도 한다. 코드의 어마어마한 크기와 복잡성으로 이런 신의 객체들을 이해하기도 어렵고 테스트하거나 유지 보수하기에도 매우 어려워진다.  

로직들을 모델로 이전할 때 큰 문제를 여러 작은 문제로 쪼갰을 때 더 풀기 쉬워진다는 객체 지향 언어의 기본적인 아이디어를 늘 염두해 두고 작업해야 한다. 모델이 너무 커졌다면 다른 모델들 사이에 공통적으로 쓰일 수 있거나 덜 복잡하게 관리할 수 있는 기본적인 형태로 코드를 분리한다. 메서드들과 클래스 메서드, 프로퍼티들을 그대로 유지한 채 그것들이 지닌 로직들을 모델 행동(model behavior)이나 상태 없는 헬퍼 함수(stateless helper function)로 이전한다.

### 6.5.1 모델 행동(믹스인)
모덿 행동은 믹스인을 통한 캡슐화와 구성화의 개념으로 이루어진다. 모델은 추상화 모델로부터 로직들을 상속받는다.
- 케빈 스톤이 쓴 코드 중복을 막는 작성법 : <http://blog.kevinastone.com/django-model-behaviors.html>
- 10.2 클래스 기반 뷰와 믹스인 이용하기

### 6.5.2 상태 없이 헬퍼 함수
모델로부터 로직을 떼어내 유틸리티 함수로 넣음으로써 좀 더 독립적인 구성이 가능하다. 독립적으로 구성하면 로직에 대한 테스트가 좀 더 쉬워진다. 단점은 해당 함수들이 자신의 상태를 가지지 않음(stateless)으로 함수에 더 많은 인자를 필요로 하게 된다는 점이다.

### 6.5.3 모델 행동과 헬퍼 함수
두 가지 모두 완벽하지는 않지만, 잘 이용한다면 프로젝트를 더 빛나게 할 도구이다. 언제 어떻게 써야할지는 아직 명확하지 않다. 지금도 발전하는 중이기 때문이다.

## 6.6 요약
모델은 대부분의 장고 프로젝트의 기초가 된다. 따라서 모델은 더 신중하게 디자인해야 한다.  
정규화를 시작하고 다른 방법이 충분히 고려해도 방법이 없을 때 비정규화를 고려해야한다. 어쩌면 로우 쿼리(raw SQL)를 적용함으로써 느리고 복잡한 쿼리를 단순화할 수도 있다. 또는 적절한 위치에 캐시를 이용함으로써 성능 문제를 해결할 수도 있다.  
프로젝트 전반에 걸쳐 데이터를 이용하는 데 익숙해졌을땐 인덱스를 사용할 때가 된 것이다.  
모델 간의 상속을 이용하기로 했다면, 접합 모델(concrete model)이 아니라 추상화 기초 클래스로부터 상속해야 한다. 아마 필요 없이 생성된 암시적 구조의 조인을 처리하는데서 오는 혼돈을 막을 수 있다.  
모델에서 null=True와 blank=True 옵션을 이용할 때 애매한 부분을 주의하고 위의 가이드 라인을 참고한다.  
django-model-utils와 django-extensions를 유용하게 쓸 수도 있다.  
마지막으로 거대 모델은 로직을 모델 안에 캡슐화해서 넣는 방법으로 모델 전부를 신의 객체로 만들 위험도 있다.
