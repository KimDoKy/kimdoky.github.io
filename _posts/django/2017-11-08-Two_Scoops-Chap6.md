---
layout: post
section-type: post
title: Two Scoops of Django - chap6. 장고에서 모델 이용하기
category: django
tags: [ 'django' ]
---

모델은 장고 프로젝트의 토대가 되는 부분이다. 성급하게 작성한다면 추후에 모델을 변경하거나 추가하게 될때, 최악의 경우 기존 데이터가 충돌하는 상황이 발생한다. 따라서 새 모델을 추가하거나 기존 모델을 수정할 때는 가능한한 탄탄하고 안전하게 다질 수 있는 방향으로 디자인을 고려해야 한다.

> #### 모델을 작업하면서 이용할 수 있는 장고 패키지들  
- django-model-utils: TimeStampedModel 같은 일반적인 패턴들을 처리하는 게 이용
- django-extensions: 모든 앱에 모델 클래스를 자동으로 로드해 주는 `shell_plus`라는 강력한 관리 명령을 제공한다. 단점은 '작지만 역할이 분명한 앱' 개념에 맞지 않게 너무 다양한 기능을 포함하고 있다.

## 6.1 시작하기

### 6.1.1 모델이 너무 많으면 앱을 나눈다.
앱 하나에 20개 이상의 모델이 있다면 크기가 작은 앱으로 분리할 것을 고민해야 한다. 각 앱이 가진 모델이 5개를 넘지 않는게 좋다.

### 6.1.2 모델 상속에 주의하자
장고는 3가지 모델 상속 방법을 제공한다. **추상화 기초 클래스(abstract base class)**, **멀티테이블 상속(multitable inheritance)**, **프락시 모델(proxy model)** 이다.

> #### 장고 추상화 기초 클래스 <> 파이썬 추상화 기초 클래스  
파이썬 표준 라이브러리의 abc 모듈에서 이야기하는 추상화 기초 클래스와 장고에서 말하는 추상화 기초 클래스는 목적이 전혀 다르므로 이 둘을 혼동하면 안된다.

모델의 상속 스타일 | 장점 | 단점
---|---|---
상속을 이용하지 않는 경우:<br>모델들 사이에 공통 필드가 존재할 경우, 두 모델에 전부 모델 필드를 만들어 준다. | 데이터베이스 테이블에 어떤 식으로 매핑되든지 상관없이 장고 모델을 한 눈에 이해하기 쉽게 구성된다. | 모델들 사이에 서로 중복되는 테이블이 많을 경우 이를 지속적으로 관리하는데 어려움이 따른다.
추상화 기초 클래스:<br>오직 상속받아 생성된 모델들의 테이블만 생성된다. | 추상화된 클래스에 공통적인 부분을 추려 놓음으로써 한 번만 타이핑을 하면 된다.<br>추가 테이블이 생성되지 않고 여러 테이블에 걸쳐 조인을 함으로써 발생하는 성능 저하도 없다. | 부모 클래스를 독립적으로 이용할 수 없다.
멀티테이블 상속:<br>자식 모델에 대해서도 모두 테이블이 생성된다. OneToOneField는 부모와 자식 간에 적용된다. | 각 모델에 대해 매칭되는 테이블이 생성된다. 따라서 부모 또는 자식 모델 어디로든지 쿼리를 할 수 있다. 부모 객체로부터 자식 객체를 호출하는 것이 가능하다: parent.child | 자식 테이블에 대한 각 쿼리에 대해 부모 테이블로의 조인이 필요하므로 이에 따른 상당한 부하가 발생한다. 멀티테이블 상속을 이용하지 않기를 권한다. 다음에 나오는 경고를 참고
프락시 모델:<br>원래 모델에 대해서만 테이블이 생성된다. | 각기 다른 파이썬 작용(behavior)을 하는 모델들의 별칭을 가질 수 있다. | 모델의 필드를 변경할 수 없다.

> #### 멀티테이블 상속은 피하자.  
접합 상속(concrete inheritance)라고도 부르는 멀티테이블 상속은 실제로 이를 만든 사람과 여타 개발자로부터 그닥 환영받지 못한다. 따라서 가능한 한 이용하지 않는 것이 좋다.

- 모델 사이에서 중복되는 내용이 최소라고 한다면(오직 한두 개의 명확한 필드만이 여러 개의 모델 사이에서 공유되는 경우), 모델의 상속 자체가 필요 없을 것이다. 그냥 모델 두 곳에 필드를 추가하면 된다.
- 모델들 사이에 중복된 필드가 혼란을 야기하거나 의도하지 않은 실수를 유발할 정도로 많을 때, 대부분의 경우 공통 필드 부분이 추상화 기초 모델로 이전 될 수 있게 리팩터링할 수 있다.
- 프락시 모델은 종종 편리하게 이용되지만 다른 두 가지 모델 상속 방식과는 사뭇 다르게 작동한다는 점을 주지해야 한다.
- 멀티테이블 상속은 혼란과 상당한 부하를 일으키므로 반드시 피해야 한다. 멀티테이블 상속을 이용하는 대신 모델들 사이에서 좀 더 명확한 OneToOneField와 ForeignKey를 이용함으로써 조인이 난립할 때도 좀 더 수월하게 컨트롤할 수 있다.

### 6.1.3 실제로 모델 상속해 보기: TimeStampedModel
장고의 모든 모델에서 created와 modified 타임스탬프 필드를 생성해 두는 것은 일반적이다. 전 모델에 걸쳐 일일이 이 두가지 필드를 추가할 수도 있지만 작업량도 많고 실수할 가능성도 높다. 이를 위해 TimeStampedModel을 만들어 이 모델이 우리 대신 필드 추가를 처리하게 하면 된다.

```python
# core/models.py
from django.db import models

class TimeStampedModel(models.Model):
    """
    'created'와 'modified' 필드를 자동으로 업데이트 해두는
    추상화 기반 클래스 모델
    """
    created = models.DateTimeField(auto_now_add=True)
    modified = models.DateTimeField(auto_now_add=True)

    class Meta:
        abstract = True
```

마지막 두줄이 추상화 기초 클래스로 변경해 주는 역할을 한다.

```python
class Meta:
    abstract = True
```
TimeStampedModel을 상속하는 새로운 클래스를 정의할 때 TimeStampedModel을 추상화 기초 클래스로 선언함으로써 장고에서 마이그레이션을 실행할 때 core_timestampedmodel 테이블이 생성되지 않는다.

```python
# flavors/models.py
from django.db import models

from core.models import TimeStampedModel

class flavor(TimeStampedModel):
    title = models.CharField(max_length=200)
```

이 코드는 오직 하나의 flavors_flavor 데이터베이스 테이블만 생성한다. 정확히 원했던 동작만 한다.  
TimeStampedModel이 추상화 클래스가 아니었다면 core_timestampedmodel 테이블이 같이 생성되었을 것이다. 뿐만 아니라 Flavor를 포함한 모든 서브클래스들이 자신만의 시간 필드를 가지지 못하고 TimeStampedModel과 연결되는 외부키를 통해 created/modified 타임스탬프를 처리하고 있었을 것이다. 따라서 Flavor에서 TimeStampedModel에 읽고 쓰는 모든 레퍼런스들은 늘 두 개의 테이블에 영향을 미쳤을 것이다.  

즉, 접합 기반 상속은 심각한 성능 문제를 일으킬 소지가 있고 여러번 서브클래스화해서 이용하면 문제는 더욱 커질 것이다.

### 6.1.4 데이터베이스 마이그레이션
마이그레이션을 생성하는 팁이다.

- 새로운 앱이나 모델이 생성되면 새 모델에 대해 django.db.migrations을 실행한다.
- 생성된 마이그레이션 코드를 실행하기 전에 생성된 코드를 살펴본다. 특히 복잡한 변경 사항이 적용된 경우 더욱 꼼꼼히 살핀다. 또한 `sqlmigrate` 명령을 통해 어떤 SQL 문이 실행되는지도 확인한다.
- 자체적인 django.db.migrations 스타일로 이루어지지 않은 외부 앱에 대해 마이그레이션을 처리할 때는 MIGRATION_MODULES 세팅을 이용한다.
- 생성되는 마이그레이션 갯수에 연연하지 않는다. 너무 많은게 불편하다면 `squashmigrations`를 이용한다.

마이그레이션의 배포와 관리 팁이다.

- 배포 전에 마이그레이션을 되돌릴(rollback) 수 있는지 확인해 보자. 완벽한 복구가 아닌 적정 수준까지 되돌리기가 불가능하다면 규모가 큰 프로젝트에서는 버그 트래킹이나 배포 시에 큰 문제가 될 수 있다.
- 데이블에 수백만 개의 데이터가 이미 존재한다면 운영 서버에서 실제로 마이그레이션을 실행하기 이전에 스테이징 서버에서 비슷한 크기의 데이터에 대해 충분히 테스트하자. 운영 서버에서의 마이그레이션은 생각하는 것보다 더 '많은' 시간이 걸린다.
- MySQL을 이용한다면 다음과 같이 한다.
  - 스키마를 변환하기 전에 데이터베이스를 반드시 백업해 둔다. MySQL은 스키마 변경에 대해 트랜젝션을 지원하지 않는다. 따라서 롤백이 불가능하다.
  - 가능하다면 데이터베이스를 변환하기 이전에 프로젝트를 읽기 전용(read-only) 모드로 변경해 준다.
  - 상당히 큰 테이블의 경우 주의하지 않으면 스키마 변경에 상당한 시간이 소요된다. 초 단위, 분 단위가 아니라 몇 시간이 걸릴 수도 있다.

  ![]({{site.url}}/img/post/django/two_scoops/6.1.png)
> 겨울이 오기 전에 남쪽(south)으로 이주(migration)하는 아이스크림 콘들.  
장고에 내장된 마이그레이션 시스템은 사우스라는 외부 프로젝트로부터 시작되었다.

## 6.2 장고 모델 디자인

### 6.2.1 정규화하기
**데이터베이스 정규화(database normalization)** 에 익숙해져야 한다.

- <https://en.wikipedia.org/wiki/DataBase_normalization>
- <https://en.wikipedia.org/wiki/Relational_Database_Design/Normalization>

장고 모델 디자인은 항상 정규화로부터 시작하자. 충분한 시간을 가지고 이미 모델에 포함된 데이터들이 중복되어 다시 다른 모델에 포함되지 않도록 신경써야 한다.  
이 단계에서는 관계 필드에 대해 제약을 느끼지 않아도 된다. 일단 미숙하게 비정규화하는 것부터 피한다. 바로 데이터의 형태와 틀에 대한 지각이 필요하다.

### 6.2.2 캐시와 비정규화
적절한 위치에서 캐시를 세팅하는 것은 모델을 비정규화할 때 발생하는 문제점들을 상당 부분 해결해 주기도 한다.

### 6.2.3 반드시 필요한 경우에만 비정규화를 하도록 하자
비정규화가 프로젝트의 해답처럼 보일수도 있지만 곧 프로젝트 자체를 더욱 복잡하게 만들고 데이터를 손상시킬 수 있는 위험을 증가시킬 것이다. 비정규화를 생각하기 이전에 캐시에 대해 좀 더 연구할 필요가 있다.

### 6.2.4 언제 널을 쓰고 공백을 쓸 것인가
모델 필드를 정의할 때 `null=True`와 `blank=True`를 설정하는 옵션을 선택할 수 있다. 기본값은 둘 다 False이다.  

모델 필드 인자들에 대한 일반적인 가이드이다.

필드 타입 | `null=True`로 설정하기 | `blank=True`로 설정하기
---|---|---
CharField, TextField, SlugField, EmailField, CommaSeparatedIntegerField, UUIDField | 이용하지 않는다. 장고 표준은 빈 값(empty value)을 빈 문자열(empty string)로 저장하는 것이다. 일관성을 위해 널값 또는 빈 값을 빈 문자열에 대해 반환하도록 한다. | 이용한다. 위젯이 빈 값을 허용하기를 원한다면 설정한다. 이렇게 설정하면 데이터베이스에서는 빈 값이 빈 문자열로 저장된다.
FileField, ImageField | 이용하지 않는다. 장고는 MEDIA_ROOT의 경로를 CharField에 파일 또는 이미지로 저장한다. 따라서 같은 패턴이 FileField에도 적용된다. | 이용한다. CharField에 적용된 것과 같은 규칙이 적용된다.
BooleanField | 이용하지 않는다. 대신 NullBooleanField를 이용한다. | 이용하지 않는다.
IntegerField, FloatField, DecimalField, DurationField 등 | 해당 값이 데이터베이스에 NULL로 들어가도 문제가 없다면 이용한다. | 위젯에서 해당 값이 빈 값을 받아와도 문제가 없다면 이용한다. 그럴 경우 null=True와 같이 이용한다.
DateTimeField, DateField, TimeField 등 | 데이터베이스에서 해당 값들을 NULL로 설정하는 게 가능하다면 이용한다. | 위젯에서 해당 값이 빈 값을 받아와도 문제가 없다거나 auto_now나 auto_now_add를 이용하고 있다면 이용한다. 그럴 경우 null=True와 같이 이용한다.
ForeignKey, ManyToManyField, OneToOneField | 데이터베이스에서 해당 값들을 NULL로 설정하는게 가능하다면 이용한다. | 위젯에서 해당 값(예를 들어 셀렉트박스)이 빈 값을 받아 와도 괜찮다면 이용한다.
GenericIPAddressField | 데이터베이스에서 해당 값들을 NULL로 설정하는게 가능하다면 이용한다. | 위젯에서 해당 값이 빈 값을 받아와도 괜찮다면 이용한다.
IPAddressField | 이용하지 않는다. | 이용하지 않는다.

> #### IPAddressField 대신에 GenericIPAddressField 이용하기  
IP4와 IP6의 동시 지원을 포함한 여러 이유로 GenericIPAddressField가 IPAddressField보다 훨씬 선호된다. IPAddressField는 장고 1.7 이후로 사라질 것이기 때문에 GenericIPAddressField를 이용하는 것이 좋다.

### 6.2.5 언제 BinaryField를 이용할 것인가?
BinaryField는 로우 바이너리 데이터(raw binary data) 또는 바이드(byte)를 저장하는 필드다. 해당 필드에서는 filter, exclude, 기타 SQL 액션들이 적용되지 않는다. BinaryField는 다음과 같은 내용을 저장하는데 쓰일 수 있다.

![]({{site.url}}/img/post/django/two_scoops/6.2.png)
> 일반적으로 우리가 헷갈리는 것  
바닐라 맛은 널 제로(zero)일까? 빈 문자열일까?

- 메시지팩 형식의 콘텐츠
- 원본 센서 데이터
- 압축된 데이터. 예를 들어 센트리(Sentry)가 블롭(BLOB)으로 저장했지만 레거시 이슈 등으로 base64로 인코딩된 데이터들의 형식

이외에도 다양한 곳에 이용될 수 있다. 하지만 바이너리 데이터는 크기가 방대할 수도 있고 그로 인해 데이터베이스가 느려질 수 있다, 실제로 그런 경우가 발생해서 바이너리 데이터 저장이 병목 지점이 된다면 해당 데이터를 파일 형태로 저장하고 FileField에 레퍼런스만 저장하는 방법으로 해결할 수 있다.

> #### BinaryField로부터 파일을 직접 서비스하는 것은 금물!  
데이터베이스 필드에 파일을 직접 저장하는 것은 피해야한다. 데이터베이스 필드에 파일을 직접 저장하는 방법을 고려 중이라면 주변에 데이터베이스 전문가에세 조언을 구해야 한다.  
PostgreSQL 전문가인 프랭크 와일스가 데이터베이스를 파일 저장소로 이용하는 것에 대한 문제점을 이야기한 사항은 다음과 같다.
- 데이터베이스의 '읽기/쓰기' 속도는 항상 파일 시스템의 '읽기/쓰기' 속도보다 느리다.
- 데이터베이스 백업에 드는 공간과 시간이 점점 증가하게 된다.
- 파일 자체에 접근하는 데 앱(장고) 레이어와 데이터베이스 레이어 둘 다를 거쳐야만 한다.  

### 6.2.6 범용 관계 피하기

### 6.2.7 PostgreSQL에만 존재하는 필드에 대해 언제 널을 쓰고 언제 공백을 쓸 것인가



## 6.3 모델의 \_meta API

## 6.4 모델 매니저

## 6.5 거대 모델 이해하기

### 6.5.1 모델 행동(믹스인)

### 6.5.2 상태 없이 헬퍼 함수

### 6.5.3 모델 행동과 헬퍼 함수


## 6.6 요약
