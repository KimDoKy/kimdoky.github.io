---
layout: post
section-type: post
title: Two Scoops of django 3.x - Chap31. What About Those Random Utilities?
category: django
tags: [ 'django' ]
---

> [Two Scoops of Django 3.x](https://www.feldroy.com/books/two-scoops-of-django-3-x)
 
---

## 31.1 Create a Core App for Your Utilities

유틸리티들을 위한 코어 앱 만들기

프로젝트 전반에 걸쳐 쓰이는 함수들과 객체들을 넣어 두는 Django 앱을 생성하여 보관하자.

그렇지 않으면 추후에 필요한 함수들이 어디 있는지 찾기 힘들어질 것입니다.

일반적으로 앱 이름은 core, common, generic, util, utils 라는 이름을 사용함니다.

```python
# core앱의 구성
# 코어는 비추상화(non-abstract) 모델을 가지게 된다.
# 코어에 어드민 자동 발견(admin auto-descovery)을 적용한다.
# 코어에 쳄플릿 태그와 필터를 위치시킨다.
core/
	__init__.py
	managers.py # 커스텀 모델 매니저 포함
	models.py
	views.py    # 커스텀 뷰 믹스인 포함

# 임포트 방법
from core.managers import PublishedManager
from core.views import IceCreamMixin
```

## 31.2 Optimize Apps With Utility Modules

유틸리티 모듈들을 이용하여 앱을 최적화하기

헬퍼와 같은 의미로 utils.py와 helpers.py로 쓰이기도 합니다.

이 파일 안에는 일반적인 패턴들을 좀 더 쉽고 간결하게 만들어 주는 함수와 클래스가 들어갑니다.

### 31.2.1 Storing Code Used in Many Places

여러 곳에서 공통으로 쓰이는 코드를 저장해 두기

여러 곳에서 공통으로 쓰여서 특정 앱에만 넣기 어려울 때, [utils.py](http://utils.py) 모듈에 위치시키면 됩니다.

### 31.2.2 Trimming Models

모델을 좀 더 간결하게 만들기

특정 앱이 너무 비대해진다면, 프로퍼티나 클래스 매서드를 포함한 여러 메서드에서 app_name/[utils.py](http://utils.py) 안으로 캡슐화해 넣을 수 있는 부분을 찾아 분산시킴으로써, 재사용과 테스팅이 수월해집니다.

### 31.2.3 Easier Testing

좀 더 손쉬운 테스팅

복잡한 로직들로부터 함수들을 독립시킴으로써 좀 더 손쉬운 테스트가 가능해집니다.

독립적이란 것은 프로젝트 전반에 걸친 것 뿐만 아니라, 하나의 앱 안에서도 이루어지는 것도 의미합니다.

## 31.3 Django’s Own Swiss Army Knife

장고 자체에 내장된 스위스 군용 칼

- 스위스 군용 칼: 작지만 매우 유용한 다목적 도구를 의미
- Django는 다수의 유용한 헬퍼 함수를 django.utils 패키지에 내장하고 있습니다.
    - 버전에 따라 용도와 내용이 바뀌기 때문에, 버전에 따라 문서를 읽고 사용하자.
    - [https://docs.djangoproject.com/en/3.2/ref/utils/](https://docs.djangoproject.com/en/3.2/ref/utils/)

### 31.3.1 `django.contrib.humanize`

- `django.contrib.humanize`: 사용자 친화적인 기능들을 제공하는 템플릿 필터
    - ex) `intcomma` 라는 필터는 정수를 3자리마다 쉼표를 찍어 문자열로 변경해 줌

### 31.3.2 `django.utils.decorators.method_decorator(decorator)`

- 함수 데코레이터를 메서드 데코레이터로 변환
- [https://docs.djangoproject.com/en/3.2/ref/utils/#module-django.utils.decorators](https://docs.djangoproject.com/en/3.2/ref/utils/#module-django.utils.decorators)
- [https://docs.djangoproject.com/en/3.2/topics/class-based-views/intro/#id1](https://docs.djangoproject.com/en/3.2/topics/class-based-views/intro/#id1)

### 31.3.3 `django.utils.decorators.decorator_from_middleware(middleware)`

- middleware: 프로젝트 전반에 광범위하게 이용하기 위한 도구
- 추가적인 쿼리를 생성하거나 더 복잡한 일들을 수행
- 뷰 데코레이터를 이용하면 미들웨어를 뷰에 한정시킬 수 있음
- `decorator_from_middleware_with_args`는 `decorator_from_middleware`에 인수를 수락하는 함수
    - [https://docs.djangoproject.com/en/3.2/ref/utils/](https://docs.djangoproject.com/en/3.2/ref/utils/)

### 31.3.4 `django.utils.encoding.force_text(value)`

- 무엇이든지 일반 문자열로 반환
- `django.utils.functional.__proxy__` 객체를 더 이상 보여주지 않음
- [Appendix D]() 참고

### 31.3.5 `django.utils.functional.cached_property`

- `self` 인자만을 단독으로 가진 메서드의 결과를 프로퍼티로 메모리에 캐시해 주는 기능
    - 리소스를 많이 요구하는 연산의 결과를 캐시하는 역할로 유용
    - [https://docs.djangoproject.com/en/3.2/ref/utils/#django.utils.functional.cached_property](https://docs.djangoproject.com/en/3.2/ref/utils/#django.utils.functional.cached_property)
    - 해당 객체가 존재하는 동안 메서드의 값이 항상 일정한지 확인하는 용도로도 사용 가능
        - 외부 서드파티 API나 DB 트랜잭션 관련 작업에 유용
- Django 외부에서는 멀티 스레드 환경 문제가 있기 때문에 다음의 라이브러리를 고려해 볼 수 있다.
    - [https://docs.python.org/dev/library/functools.html?highlight=#functools.cached_property](https://docs.python.org/dev/library/functools.html?highlight=#functools.cached_property)
    - https://github.com/pydanny/cached-property
    - [https://daniel.feldroy.com/posts/cached-property](https://daniel.feldroy.com/posts/cached-property)

### 31.3.6 `django.utils.html.format_html(format_str, args, **kwargs)`

- HTML을 처리하기 위해 제작된 점 외에는 `str.format()` 메서드와 비슷
- 모든 args, kwargs는 `str.format()`으로 전달되기 전에 처리되며, 그 이후 처리된 값들 각각이 서로 연결됨
- [https://docs.djangoproject.com/en/3.2/ref/utils/#django.utils.html.format_html](https://docs.djangoproject.com/en/3.2/ref/utils/#django.utils.html.format_html)

### 31.3.7 `django.utils.html.strip_tags(value)`

- 사용자로부터 받은 콘텐츠에서 HTML 코드가 있다면 태그들을 제거
- 그렇다고 해도 보안 문제가 없다고 생각하면 안됨
    - [https://www.djangoproject.com/weblog/2014/mar/22/strip-tags-advisory/](https://www.djangoproject.com/weblog/2014/mar/22/strip-tags-advisory/)

### 31.3.8 `django.utils.text.slugify(value)`

개별적으로 `slugify()` 함수를 만드는 것은 지양해야 합니다. 그것은 데이터에 큰 문제를 초래할 수 있습니다.

대신 Django가 사용하는 `slugify()`를 사용해야 합니다.

`django.templates.defaultfilters.slugify()`를 직접 호출할 수도 있으나, utils 디렉터리 안의 것을 가져다 사용하는 것이 임포트 경로를 깔끔하게 작성할 수 있습니다.

### 31.3.9 Slugification and Language Besides English

영어 이외의 언어들과 slugify에 대해

```python
# slugify() 는 현지화 과정에서 문제가 될 수 있습니다.
>>> from django.utils.text import slugify 
>>> slugify('straße') # 독일어
'strae'

# allow_unicode로 해결할 수 있습니다.
>>> slugify('straße', allow_unicode=True)
'straße'
```

- https://github.com/un33k/python-slugify
    - slugification에 더 많은 제어를 원한다면 위 라이브러리를 살펴보세요.

### 31.3.10 `django.utils.timezone`

사용자들이 늘 같은 시간대에 있다고 보장할 수 없기 때문에, 시간대를 활성화하는 것이 좋습니다.

Django의 시간대 지원 기능을 이용할 때 DB에는 UTC 포맷 형태로 저장하고 필요에 따라 지역 시간대에 맞게 변형해서 이용해야 합니다.

### 31.3.11 `django.utils.translation`

Django는 국제화(i18n) 기능을 제공합니다.

- [Appendix D: Internationalization and Localization]()

## 31.4 Exceptions

- [https://docs.djangoproject.com/en/dev/ref/exceptions/](https://docs.djangoproject.com/en/dev/ref/exceptions/)

### 31.4.1 `django.core.exceptions.ImproperlyConfigured`

- Django 셋팅 모듈을 임포트하는데 셋팅 모듈의 문제 여부 검사를 이행하는 코드가 작동하게 됨
- [Chap5: Settings and RequirementsFiles]()
- [Appendix E: Settings Alternatives]()

### 31.4.2 `django.core.exceptions.ObjectDoesNotExist`

- 모든 ObjectDoesNotExist 예외가 상속하는 기본 Exception

```python
# 기본 모델 인스턴스를 패치해서 커스텀 가능
# core/utils.py
from django.core.exceptions import ObjectDoesNotExist 

class BorkedObject:
    loaded = False

def generic_load_tool(model, pk):
    try:
        instance = model.objects.get(pk=pk)
    except ObjectDoesNotExist: 
        return BorkedObject()
    instance.loaded = True 
    return instance

# 404 대신 403 예외를 발생시키는 함수를 만들 수도 있음
# core/utils.py
from django.core.exceptions import MultipleObjectsReturned 
from django.core.exceptions import ObjectDoesNotExist 
from django.core.exceptions import PermissionDenied

def get_object_or_403(model, **kwargs): 
    try:
        return model.objects.get(**kwargs) 
    except ObjectDoesNotExist:
        raise PermissionDenied 
    except MultipleObjectsReturned:
        raise PermissionDenied
```

### 31.4.3 `django.core.exceptions.PermissionDenied`

- 인증된 사용자가 허가되지 않은 곳에 접속을 시도할 때 사용
- `django.http.HttpResponseForbidden`을 유발할 수 있음
- 보안이 매우 중요한 프로젝트의 컴포넌트와 함수에서 유용하게 사용
    - 500 에러대신 ‘Permission Denied’를 보여주어 경고를 줄 수 있음

```python
# stores/calc.py
def finance_data_adjudication(store, sales, issues):

    if store.something_not_right:
        msg = 'Something is not right. Please contact the support team.'
        raise PermissionDenied(msg)
       
    # 다른 비즈니스 로직들이 이 아래에 위치
```

403 에러 페이지를 어떤 뷰에서든지 이용하려면 프로젝트 루트 디렉터리 URLConf에 추가하면 됩니다.

```python
# urls.py
# 커스텀 거부 뷰를 이용하는 방법
# 기본 뷰는 django.views.defaults.permission_denied 이다.
handler403 = 'core.views.permission_denied_view'
```

예외 처리 뷰에서는 FBV를 선호합니다.

## 31.5 Serializers and Deserializers

Django는 JSON, Python, YAML, XML 데이터를 위한 직렬화/역직렬화 도구를 제공합니다.

이 기능들은 모델 인스턴스를 직렬화 데이터로 변환 후 다시 모델 인스턴스로 변환하는 기능을 포함합니다.

```python
# serializer_example.py
from django.core.serializers import get_serializer 
from favorites.models import Favorite

# serializer 클래스 생성
# json을 python이나 xml로 바꿔도 됨
# pyyaml이 설치되어 있다면 pyyaml을 바꿔도됨
JSONSerializer = get_serializer('json')
serializer = JSONSerializer()
favs = Favorite.objects.filter()[:5]

serialized_data = serializer.serialize(favs)

with open('data.json', 'w') as f:
    f.write(serialized_data)

----------------------------------
# deserializer_example.py
from django.core.serializers import get_serializer 
from favorites.models import Favorite

JSONSerializer = get_serializer('json')
serializer = JSONSerializer()

with open('data.txt') as f:
    serialized_data = f.read()

# python_data로 역직렬화된 모델 데이터 넣기
python_data = serializer.deserialize(serialized_data)

for element in python_data:
    # 'django.core.serializers.base.DeserializedObject' 출력
    print(type(element))
    # element들은 모델 인스턴스에서 생성된 객체들을 가지고 있게 됨
    # 여기서는 favorites.models.Favorite가 element에 들어 잇음
    print(
        element.object.pk,
        element.object.created
    )
```

Django는 직렬화/역직렬화를 위해 `dumpdata`, `loaddata` 라는 명령어를 제공하고 있습니다.

하지만 위의 예만큼 직접적으로 데이터 컨트롤을 할 수 없습니다.

- 가이드라인
    - 간단한 데이터에 대해서만 직렬화한다.
    - 데이터베이스 스키마의 변화는 언제라도 직렬화된 데이터와 문제를 일으킬 수 있다.
    - 그냥 단순히 직렬화된 데이터를 임포트하지 말고, 언제나 Django 폼 라이브러리나 DRF를 이용하여 해당 데이터에 대한 확인 작업을 해당 데이터를 저장하기 이전에 꼭 해야 한다.

### 31.5.1 `django.core.serializers.json.DjangoJSONEncoder`

Python 내장 JSON 모듈은 날짜, 시간, 소수점 데이터에 대한 인코딩 기능이 빠져 있습니다.

Django의 JSONEncoder 클래스는 이러한 기능을 제공합니다.

```python
# json_encoding_example.py
import json

from django.core.serializers.json import DjangoJSONEncoder
from django.utils import timezone 

data = {'date': timezone.now()}

# DjangoJsonEncoder 클래스를 추가하지 않으면 
# json 라이브러리가 Type Error 발생시킴
json_data = json.dumps(data, cls=DjangoJSONEncoder)

print(json_data)
```

### 31.5.2 `django.core.serializers.pyyaml`

Django의 YAML 직렬화 도구는 pyyaml 라이브러리를 사용하는데, pyyaml이 지원하지 않는 Python-to-YAML로부터 시간 변환을 처리할 수 잇습니다.

역직렬화를 위해 내장된 yaml.safe_load() 함수를 이용하면 코드 인젝션 문제를 해결할 수 있습니다.

- [Chap28.10.3: Third-Party Libraries That Can Execute Code]()

### 31.5.3 `django.core.serializers.xml_serializer`

Django XML 직렬화는 기본적으로 파이썬 내장 XML 핸들러를 이용합니다.

XML 폭탄 공격을 방지하기 위해 defusedxml 라이브버리를 포함하고 있습니다.

- [Chap28.21: Guard Against XML bombing With defusedxml]()

### 31.5.4 `rest_framework.serializers`

Django의 내장 직렬화로는 충분하지 않은 경우들이 있습니다.

- 필드에 저장된 데이터만 직렬화합니다. 메서드나 속성의 데이터는 포함할 수 없습니다.
- 직렬화된 필드를 제한할 수 없습니다. 이는 보안이나 성능 고려사항일 수 있습니다.

이런 경우 DRF로 전환하는 것을 고려할 수 있습니다.

- [https://www.django-rest-framework.org/api-guide/serializers/](https://www.django-rest-framework.org/api-guide/serializers/)
- [https://www.django-rest-framework.org/api-guide/serializers/#serializing-objects](https://www.django-rest-framework.org/api-guide/serializers/#serializing-objects)
- [https://www.django-rest-framework.org/api-guide/serializers/#deserializing-objects](https://www.django-rest-framework.org/api-guide/serializers/#serializing-objects)

## 31.6 Summary

- 유틸리티 패키지 관리 방법
- Django 유틸리티 도구들
    - 이러한 도구들로부터 최대한 도움이 되는 기능들을 끌어냄으로써 숙련된 Django 개발자들은 프로젝트 개발속도를 높이고, 여러 기능이 얽혀서 생기는 문제들을 피할 수 있습니다.
