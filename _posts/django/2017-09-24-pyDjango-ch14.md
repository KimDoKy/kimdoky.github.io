---
layout: post
section-type: post
title: pyDjango - chap14. 장고 핵심 기능 - Model
category: django
tags: [ 'django' ]
---

모델이란 테이블을 정의하는 장고의 클래스를 의미하며, models.py 파일에 테이블 관련 사항들을 정의합니다. models.py에 테이블을 정의하는 것이 기본이지만, 그 외에도 관련 속성 및 메소드를 추가적으로 정의할 수 있습니다. 이는 ORM 방식에 기반해 테이블을 클래스로 정의하고 있어, 클래스의 특징인 속성와 메소드를 가질 수 있기 때문입니다. ORM 방식의 장점입니다.  

모델의 가장 기본이라 할 수 있는 모델 클래스 정의 방법을 살펴보고, 이해가 쉽지 않은 Manager 클래스에 대해 다룹니다. 또한 모델 자체를 이해한 이후에는 그들 간의 관계에 대해서도 다룹니다. 관계형 데이터베이스(RDB, Relational Database) 용어에서도 알 수 있듯이, 테이블 간에 관계를 맺고 이를 활용하는 것은 필수입니다. 따라서 장고에서 제공하는 3가지 관계 모델에 대해서도 다룹니다.  

## 14.1 모델 정의

테이블을 클래스로 처리하는 ORM 기법의 특징에 따라, 테이블을 정의하는 모델 클래스는 속성과 메소드를 갖게 됩니다. 테이블의 컬럼은 모델 클래스의 속성으로 정의하고, 테이블에는 메소드가 없지만 모델 클래스에는 메소드를 정의할 수 있습니다. 물론 테이블에 관련된 메소드들입니다. 이렇게 함으로써 테이블에 관련된 데이터와 행위를 모두 모델 클래스 한 곳에서 정의 할 수 있는 장점이 생깁니다. 즉 테이블의 컬럼은 모델 클래스의 속성으로 정의하고 테이블과 관련된 함수는 모델 클래스의 메소드로 정의하는 것입니다.

![]({{site.url}}/img/post/python/django/book_14_1.png)

### 14.1.1 모델 속성

ORM 기법의 특징에 따라 테이블의 컬럼은 모델 클래스의 속성으로 정의합니다. 장고에서는 테이블의 컬럼을 테이블의 필드 또는 모델의 필드라고 하는데, 결국 모델의 필드들은 모델 클래스의 속성으로 정의되고 모델 클래스의 속성들은 테이블의 컬럼으로 1:1 매핑됩니다.  

따라서 모델 클래스의 속성 중에서 모델 필드는 가장 중요한 속성이며 필수입니다. 테이블의 컬럼이 필수인 것과 같습니다. (테이블 <-> 컬럼 | 모델 클래스 <-> 모델 필드)  

위 Album 모델은 objects 속성을 포함해 4개의 모델 속성을 정의하고 있고, 이 중 3개의 속성은 테이블 컬럼에 해당하는 모델 필드입니다. 모델 클래스에서 필드를 정의하기 위해서는 항상 필드명, 필드 타입과 필드 옵션을 지정해주어야 합니다.  

각 필드는 용도에 따라 적절한 타입을 지정해주어야 합니다.  
- 테이블의 컬럼 타입을 지정합니다. 예를 들어 CharField 필드 타입은 VARCHAR 타입으로 반환됩니다.
- 폼으로 렌더링되는 경우, HTML 위젯을 지정합니다. 예를 들어 CharField 필드 타입은 폼으로 사용될 때 `<input type="text">` HTML 태그로 변환되고 그에 상응하는 위젯을 지정합니다.
- 필드 또는 폼에 대한 유효성 검사 시 최소 기준이 됩니다.

또한 각 필드는 필드 타입에 따른 부가적인 옵션을 지정할 수 있습니다. CharField는 max_length 인자가 필수인데, 이는 테이블을 생성할 때 VARCHAR 타입 컬럼의 최대 길이를 지정합니다.  

모델 속성과 관련해서는 필드 이외에도 Meta 내부 클래스 속성 및 Manager 속성에 대한 이해가 필요합니다.  

> ### 장고의 커스텀 필드 타입  
장고는 테이블의 컬럼을 표현하기 위해 Field 추상 클래스를 제공하고 CharField 등의 필드 타입은 Field 추상 클래스를 상속받아 정의하고 있습니다. 장고는 약 30여 가지의 다양한 필드 타입과 모든 타입에 공통으로 사용할 수 있는 필드 옵션 17가지를 제공합니다. 또한 개발자가 임의로 새로운 필드를 정의하는 것도 가능한데, Field 추상 클래스 또는 기존 장고의 필드 클래스를 상속받아 관련 로직을 코딩하면 됩니다.

### 14.1.2 모델 메소드

테이블에는 메소드가 없지만 모델 클래스에는 메소드를 정의할 수 있습니다. 여기서 주의할 점은 클래스 메소드와 객체 메소드를 구분하는 것입니다. 클래스 메소드는 테이블 레벨에서 동작하는 메소드이고, 객체 메소드는 레코드 레벨에서 동작하는 메소드입니다. 장고에서는 클래스 메소드는 사용하지 않고 객체 메소드만 사용합니다. 즉 모델 클래스에 정의하는 모델 메소드는 모두 객체 메소드이며, 이 메소드들을 호출하면 테이블 단위가 아니라 레코드 단위에만 영향을 미칩니다.  

테이블의 모든 레코드 수를 카운트하는 것처럼, 장고는 클래스 메소드 대신, 별도의 Manager 클래스를 정의하고 MAnager 클래스의 메소드를 통해서 테이블에 대한 CRUD 동작을 수행합니다.  

다음 메소드는 객체의 문자열 표현을 리턴합니다. 객체는 모두 파이썬의 내부 포맷으로 저장되므로 우리가 읽을 수 없습니다. 이런 객체를 읽을 수 있는 문자열로 표현하고자 할때 다음 메소드를 정의합니다. 보통 장고 셸이나 Admin 사이트에서 객체에 대한 문자열 표현을 많이 사용합니다.  

다음 메소드를 오버라이딩 정의하지 않으면 장고의 디폴트 `__unicode__()` 메소드에 의해 객체의 문자열이 표현됩니다. 디폴트 문자열(ex: Bookmark object)은 보는 사람이 이해하기 어렵습니다. 그래서 객체를 알기 쉬운 문자열로 표시되도록, 다음 메소드는 항상 정의해주는게 좋습니다.

```python
__str__()
```

다음 메소드가 정의된 객체를 지칭하는 URL을 반환합니다. URLconf에서 DetailView 제네릭 뷰를 사용하는 경우가 좋은 예입니다. DetailView 뷰는 특정 객체에 대해 상세 정보를 보여주는 제네릭 뷰이므로, DetailView와 매핑된 URL을 get_absolute_url() 메소드를 사용해 구할 수 있기 때문입니다. 특정 객체의 URL을 구하는 기능은 여러 곳에서 필요하므로, 다음 메소드는 항상 정의해주는게 좋습니다.  

또한 이 메소드를 정의하면, Admin 사이트에서도 해당 객체 수정 화면에서 **[View on site]** 버튼이 오른쪽 상단에 보이게 됩니다. 이 버튼을 클릭하면 해당 객체의 상세 정보를 볼 수 있는 페이지로 이동합니다.  

이 메소드는 템플릿에서도 자주 사용하는데, 이 메소드의 가장 큰 장점은 URL을 표현하기 위해 하드 코딩을 하지 않아도 된다는 점입니다.
```python
get_absolute_url()
```

필드 타입이 DateField 또는 DateTimeField이면서 필드 옵션이 null=True가 아닌 경우는 다음 메소드를 사용할 수 있습니다. Foo는 필드명을 의미하고, 필요하면 키워드 인자를 사전 형식으로 전달할 수 있습니다. 이 함수는 Foo 필드 기준으로 다음 객체를 반환합니다. 다음 객체가 없는 경우는 DoesNotExist 예외가 발생합니다.

```python
get_next_by_Foo(**kwargs)
```

다음 객체가 아니라 이전 객체를 반환하는 메소드입니다.

```python
get_previous_by_Foo(**kwargs)
```

필드 옵션에 choices 인자가 있으면, 그 모델 객체는 다음 메소드를 제공합니다. Foo는 choices 인자를 갖는 필드를 의미합니다. 이 메소드는 Foo 필드의 설명 문자열을 반환합니다.

```python
get_Foo_display()
```

### 14.1.3 Meta 내부 클래스 속성
Meta 내부 클래스를 정의해 모델에 대한 메타데이터를 정의할 수 있습니다. 장고에서는 모델 클래스는 아니지만 모델 클래스에 필요한 항목을 Meta 내부 클래스에 정의합니다. 즉, 필드는 모델 클래스의 속성으로 모델 이외 항목은 Meta 내부 클래스의 속성으로 정의해, 모델의 필드 속성과 그 외 속성을 구분합니다.

#### ordering
모델 객체의 리스트를 출력시, 정렬하기 위해 사용합니다. 디폴트 값은 오름차순이고, 마이너스(-) 접두사를 붙이면 내림차순으로 정렬합니다.  

```python
ordering = ['-pub_date', 'author']
# pub_date 필드를 기준으로 내림차순으로 정렬 후에 author 필드를 기준으로 오름차순으로 정렬합니다.
```
#### db_table
데이터베이스에 저장되는 테이블의 이름을 지정합니다. 이 항목을 지정하지 않으면, 장고는 디폴트로 **앱명_클래스명(소문자)** 를 테이블명으로 지정합니다.

```python
db_table = 'tb_post'
# 블로그 앱의 모델 클래스명이 Post라면, 디폴트 테이블명은 blog_post가 됩니다. 디폴트 테이블명을 tb_post 으로 변경합니다.
```

#### verbose_name
사용자가 이해하기 쉬운 모델 객체의 별칭입니다. 이 항목을 지정하지 않으면 장고는 모델 클래스명을 변형해서 디폴트 verbose_name으로 사용합니다.  

예를 들어, 모델 클래스명이 FavoritePost라면 디폴트 verbose_name은 **favorite post** 가 됩니다.
```python
verbose_name = "my favorite post"
# 디폴트 verbose_name을 변경합니다.
```

#### verbose_name_plural
verbose_name에 대한 복수 명칭을 지정합니다. 지정하지 않으면 디폴트로 **verbose_name + 's'** 를 사용합니다. 위의 예를 인용하면 디폴트 verbose_name_plural는 **favorite posts** 가 됩니다.

> #### 장고의 메타 항목  
장고는 약 20여 가지의 메타 항목을 정의합니다.
(https://docs.djangoproject.com/ko/1.11/ref/models/options/)

### 14.1.4 Manager 속성
모델 속성 중에서 예외적으로 필드, 즉 테이블의 컬럼으로 매핑되지 않는 속성이 Manager 속성입니다.  

모든 모델은 반드시 Manager 속성을 가져야 합니다. 만일 모델을 정의할 때 명시적으로 지정하지 않으면 Manager 속성의 디폴트 이름은 objects가 됩니다. 또한 Manager 속성은 모델 클래스를 통해서만 액세스할 수 있고 모델 객체를 통해서는 액세스할 수 없습니다.  

Manager 속성은 models.Manager 타입으로 정의되므로, 장소의 Manager 클래스를 이해하는 것이 중요합니다. Manager 클래스를 통해서 데이터베이스 쿼리가 이뤄지기 때문입니다. 즉 레코드 레벨이 아니라 테이블 레벨에서의 Read 동작은 Manager 클래스의 메소드를 통해 이뤄집니다.  

예를 들어 Album.objects.all() 는 Manager 클래스가 사용된 것입니다.

![]({{site.url}}/img/post/python/django/book_14_2.png)

위 문장은 QuerySet 객체를 반환합니다. QuerySet 클래스의 메소드와 Manager 클래스의 메소드는 동일합니다.(완전히 같지는 않습니다.) 그래서 다음과 같은 QuerySet 메소드는 모두 Manager 메소드로도 사용이 가능합니다.
- all(), filter(), exclude(), get(), count()

모델 클래스에서 Manager 속성을 여러 개 정의할 수 있고, 첫 번째로 정의된 Manager 속성을 디폴트 Manager라고 합니다.

```python
class SecondAlbumManager(models.Manager):
    def get_queryset(self):
        return super(SecondAlbumManager, self).get_queryset().filter(owner__username = 'makingfunk')

class Album(models.Model):
    name = models.CharField(max_length=50)
    description = models.CharField('One Line Description', max_length=100, blank=True)
    owner = models.ForeignKey(User, null=True)

    objects = models.Manager() # 디폴트 매니저
    second_objects = SecondAlbumManager() # 추가 매니저
```
위에서 objects와 second_objects 두 새의 Manager를 정의했고, 첫 번째로 정의된 objects가 디폴트 Manager가 됩니다. second_objects를 지정하기 위해 SecondAlbumManager 클래스를 새로 정의하면서 get_queryset() 메소드를 오버라이딩 했습니다.  

이렇게 되면, Album.objects.all() 문장은 테이블에 있는 모든 앨범 레코드를 반환하고 Album.second_objects.all() 문장은 소유자가 makingfunk 인 앨범들만 반환합니다.

## 14.2 모델 간 관계
장고는 테이블 간의 관계를 3가지로 분류해 제공합니다.

- 1:N(one-to-many)
- N:N(many-to-many)
- 1:1(one-to-one)

두 가지 점을 유념해야합니다.

1. 관계라는 것은 양방향 개념이므로, 양쪽 모델에서 정의가 필요한게 원칙이지만, 장고에서는 한쪽 클래스에서만 관계를 형성하면 이를 바탕으로 상대편 정의는 자동으로 정의해줍니다. 따라서 개발자는 한쪽 클래스에서 관계를 정의했다면, 반대 방향의 정의는 명시적으로 보이지 않더라도 이해할 수 있어야 합니다.
2. 한쪽 방향으로 관계를 생성하거나 변경하면, 반대 방향으로의 관계도 그에 따라 변한다는 것입니다. 이 또한 장고가 알아서 처리해두는 동작입니다.

### 14.2.1 1:N(One-to-Many) 관계
테이블 간에 1:N 관계를 맺기 위해서는 모델의 필드를 정의할 때 ForeignKey 필드 타입을 사용하면 됩니다. ForeignKey 필드 타입은 필수 인자로 관계를 맺고자 하는 모델 클래스를 지정해야 합니다. 즉 N 모델에서 ForeignKey 필드를 정의하면, ForeignKey 필드의 필수 인자로 1 모델을 지정하는 방식입니다.

> #### 관계 표현, 1:N 또는 N:1  
장고는 테이블 간 1:N 관계를 정의하기 위해 ForeignKey 필드를 사용합니다. 그리고 ForeignKey 필드는 1 모델이 아니라 N 모델을 정의해야 합니다. 이런 특징을 강조해서 장고 공식 문서에서는 1:N(one-to-many) 용어 대신 N:1(many-to-one) 용어를 사용합니다.  
2 가지 용어를 굳이 구분할 필요는 없습니다. 중요한 점은 ForeignKey 필드는 N 모델에 명시적으로 정의해줘야한다는 점과, 상대편 모델에서의 관계는 장고가 알아서 정의해 준다는 점입니다.

일전의 User:Album 모델 간 관계도 1:N 입니다. 한 사람이 여러 개의 앨범을 소유하는 관계이기 때문입니다. 다음처럼 N 모델에 해당하는 Album 모델에서 owner 속성을 ForeignKey 필드로 정의한 바 있습니다.

```python
from django.contrib.auth.models import User

class Album(models.Model):
    name = models.CharField(max_length=50)
    description = models.CharField('One Line Description', max_length=100, blank=True)
    owner = models.ForeignKey(User, null=True)
```

User와 Album 2개의 모델을 이용해 ForeignKey 관계를 사용할 수 있는 API들을 실습합니다.

```
$ python manage.py shell
Python 3.5.2 (default, Apr 30 2017, 16:26:35)
[GCC 4.2.1 Compatible Apple LLVM 8.1.0 (clang-802.0.42)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
>>>


```
