---
layout: post
section-type: post
title: Two Scoops of django 3.x - Chap28. Security Best Practices
category: django
tags: [ 'django' ]
---

> [Two Scoops of Django 3.x](https://www.feldroy.com/books/two-scoops-of-django-3-x)
 
---

> 보안 위기에 처했다면 [Chap37. Appendix G: Handling Security Failures.]()를 참고하자.
> 

## 28.1 Reference Security Sections in Other Chapters

- [Section 5.3: Separate Configuration From Code]()
- [Section 13.3: Always Use CSRF Protection With HTTP Forms That Modify Data]()
- [Section 28.28: Never Display Sequential Primary Keys]()
- [Section 21.8: Secure the Django Admin]()
- [Chapter 37: Appendix G: Handling Security Failures]()

## 28.2 Harden Your Servers

서버 강화에 대한 지침과 체크 리스트를 조사하세요.

- [방화벽 설정]([help.ubuntu.com/](http://help.ubuntu.com/) community/UFW)
- SSH 포트 변경
- 불필요한 서비스 비활성화/제거
- etc

## 28.3 Know Django's Security Features

- Cross-site scripting (XSS) 보안
- Cross-site request forgery (CSRF) 보안
- SQL injection 보안
- Clickjacking 보안
- 보안쿠키(secure cookies)를 포함한 TLS/HTTPS/HSTS 지원
- 자동 HTML escaping
- expat parser 통한 XML bomb attacks 대비
- 강력해진 JSON, YAML, XML serialization/deserialization tools
- 기본적으로 SHA256 hash와 함께 PBKDF2 알고리즘을 사용하여 암호저장을 보호
    - [Section 28.29: Upgrade Password Hasher to Argon2]

## 28.4 Turn Off DEBUG Mode in Production

product 환경에서 `DEBUG` 모드로 절대로 운영해서는 안됩니다.

`DEBUG` 모드를 비활성화시 `ALLOWED_HOSTS`도 반드시 설정해야합니다.

- [Section 28.7 Use Allowed Hosts Validation]()

`ALLOWED_HOSTS` 세팅은 호스트/도메인 이름의 문자열 리스트에 있는 호스트로만 서비스합니다.

`DEBUG`

가 False라면 강력한 보안 시스템이지만, 잘못 설정된 `ALLOWED_HOSTS` 설정은 500 Error를 발생시킵니다. 로그는 `SuspiciousOperation` 에러만 뱉을뿐 자세한 에러 메시지를 알려주지 않아 디버깅이 어렵습니다.

- `DEBUG`가 False
- `ALLOWED_HOSTS`에 매치되는 요청을 찾을 수 없음
- 먼가 의심스러운 일이 벌어진다고 판단되면 `SuspiciousOperation` 에러 발생시킴

## 28.5 Keep Your Secret Keys Secret

API 키를 비롯한 다른 비밀키들은 버전 컨트롤로 관리해서는 안됩니다.

## 28.6 HTTPS Everywhere

사이트의 내용이 Public 한 것이라 할지라도 사이트의 신뢰성을 위해 사이트 전체를 HTTPS로 배포해야 합니다.

HTTP로 접속시 HTTPS로 리다이렉트되어야 하는데, 성능면에서는 웹서버에서 처리해야하지만, 웹서버 접근이 어렵다면 Django 미들웨어에서 리다이렉트를 처리할 수 있습니다.

최근 SSL 인증서는 저렴하고, 무료로 제공하는 곳도 있습니다. 

- [https://letsencrypt.org/](https://letsencrypt.org/)
- [https://www.cloudflare.com/](https://www.cloudflare.com/)

AWS, Google, MicroSoft 같은 대형 클라우드 업체에서도 옵션으로 제공하기도 합니다.

중요한 개인 정보가 포함된 사이트는 대형 클라우드 업체가 아닌 자체 SSL을 설정해야 합니다.(POLP.Principle of Least Privilege. 최소 권한의 원칙)

> Django는 전체 사이트에 HTTPS/SSL을 작동시키는 기능을 기본으로 내장하고 있습니다.
> 
- `settings.MIDDLEWARE`에`django.middleware.security.SecurityMiddleware` 를 추가한다.
- `settings.SECURE_SSL_REDIRECT` 를 True로 설정한다.

> Static/Media(JS, CSS, 이미지 등)은 웹 서버에 의해 서비스 됩니다. HTTPS로 서비스될 수 있도록 설정되었는지 확인해야 합니다. AWS S3 같은 곳에서는 기본적으로 지원합니다.
> 

### 28.6.1 Use Secure Cookies

HTTPS만 브라우저가 쿠키를 전송할 수 있도록 셋팅해야 합니다.

```python
SESSION_COOKIE_SECURE = True
CSRF_COOKIE_SECURE = True
```

- [django doc: ssl-https]([https://docs.djangoproject.com/en/3.2/topics/security/#ssl-https](https://docs.djangoproject.com/en/3.2/topics/security/#ssl-https))

### 28.6.2 Use HTTP Strict Transport Security(HSTS)

HSTS(HTTP Strict transport security)는 웹 서버 레벨에서 설정할 수 있습니다.

자체 웹 서버를 세팅하여 사용중이라면 [wiki - HSTS]([https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security](https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security))를 참고할 수 있습니다.

HSTS가 설정되면 HSTS 호환 브라우저에게 오직 안전한 연결을 통해서만 사이트를 연결하라고 알려주는 HTTP 헤더를 포함하게 됩니다.

- HSTS 호환 브라우저는 HTTP 링크들을 HTTPS로 리다이렉트한다.
- 안전한 연결이 불가능할 때(자체 서명 인증서나 기한 만료)는 에러 메시지와 함께 사이트 접근 불가 처리

### HSTS 설정 주의사항

- 초기 배포시 max-age를 300(5분)처럼 짧게 설정
    - HSTS는 단방향 스위치
    - 한번 설정되면 사용자 브라우저의 기한을 재설정할 수 없음
- 사이트가 안전하게 작동되는 것을 확인하면 1주(604800), 1달(2592000), 1년(31536000) 으로 점진적으로 증가시킨다.
- max-age가 1년 이상으로 설정되면 [hstspreload.org](http://hstspreload.org/) 에 HSTS 사전 로드를 위해 프로젝트를 제출할 수 있습니다.
    - 공격자가 사이트에 대한 첫 요청을 가로채지 못하도록 차단하는데 도움

모든 페이지를 HTTPS로 리다이렉트하고, HSTS 활성화까지 설정되어 있어야 합니다.

> includeSubDomains 설정을 고려하기 전에 HSTS로 설정된 도메인에는 어떤 것들이 호스팅되어야 하는지 확실하게 이해하여야 합니다.
> 

### 28.6.3 HTTPS configuration Tools

- [Mozilla SSl 설정 생성 도구]([https://ssl-config.mozilla.org/](https://ssl-config.mozilla.org/))
- [Qualys SSL Labs 서버 테스트]([https://www.ssllabs.com/ssltest/index.html](https://www.ssllabs.com/ssltest/index.html)**)**

## 28.7 Use Allowed Hosts Validation

- product 환경에서 `SuspiciousOperation` 예외 피하기
- 가짜 HTTP 호스트 헤더 요청의 방어
- 와일드카드 설정 금지
- [docs.djangoproject.com/en/3.2/ref/settings/#allowed-hosts](http://docs.djangoproject.com/en/3.2/ref/settings/#allowed-hosts)
- [docs.djangoproject.com/en/3.2/ref/request-response/#django](http://docs.djangoproject.com/en/3.2/ref/request-response/#django).http.HttpRequest.get_host

## 28.8 Always Use CSRF Protection With HTTP Forms That Modify Data

데이터를 수정하는 HTTP 폼은 항상 CSRF 보안을 사용해야 합니다. 

Django는 CSRF 보안 기능이 내장되어 있고, 기본 기능으로 미들웨어를 통해 사이트 전채에 적용되어 있습니다.

## 28.9 Prevent Against Cross-Site Scripting(XSS) Attacks

XSS 공격은 일반적으로 이용자가 템플릿에서 렌더링 가능한 악성 자바스크립트 코드를 직접 입력하여 발생합니다.(다른 방법들도 있음)

Django는 HTML 이스케이핑을 위한 `<`, `>`, `'`, `"`, `&` 에 대한 처리를 기본적으로 처리해 줍니다.

### 28.9.1 Use `format_html` Over `mark_safe`

작은 HTML 코드라도 `mark_safe`가 아닌 `django.utils.html.format_html`을 사용하세요.

- `django.utils.html.format_html` 는 모든 인수를 이스케이프 처리
    - [https://docs.djangoproject.com/en/3.2/ref/utils/#django.utils.html.format_html](https://docs.djangoproject.com/en/3.2/ref/utils/#django.utils.html.format_html)
- `mark_safe`: [https://www.kite.com/python/docs/django.utils.safestring.mark_safe](https://www.kite.com/python/docs/django.utils.safestring.mark_safe)
- `mark_safe`는 편집하면 안전하지 않게 됩니다.
    - [https://stackoverflow.com/questions/32799615/why-and-when-to-use-django-mark-safe-function/32799736](https://stackoverflow.com/questions/32799615/why-and-when-to-use-django-mark-safe-function/32799736)

```jsx
from django.utils.safestring import mark_safe
>>> mystr = '<b>Hello World</b>   '
>>> mystr = mark_safe(mystr)
>>> type(mystr)
<class 'django.utils.safestring.SafeBytes'>

>>> mystr = mystr.strip()
>>> type(mystr)
<type 'str'>
```

### 28.9.2 Don't Allow Users to Set Individual HTML Tag Attributes

사용자들이 개별적인 HTML 태그 속성을 이용하지 못하게 해야 합니다. 이는 악의적인 자바스크립트 인젝션을 방지합니다.

### 28.9.3 Use JSON Encoding for Data Consumed by JavaScript

파이썬 구조체를 직접 사용하지 말고 JSON 인코딩을 사용하세요.

클라이언트 사이드의 자바스크립트와 통합할 보안적으로 안전한 방법입니다.

json_script 필터를 통해 사용할 수 있습니다.

- [https://docs.djangoproject.com/en/3.2/ref/templates/builtins/#json-script](https://docs.djangoproject.com/en/3.2/ref/templates/builtins/#json-script)

```jsx
{{ value|json_script:"hello-data" }}

**const** value = JSON.parse(document.getElementById(
    'hello-data').textContent);
```

### 28.9.4 Beware Unusual JavaScript

자바스크립는 작은 문자들(더하기, 느낌표, 괄호 등)의 조합으로 실행 가능한 코드를 작성할 수 있습니다.

> [http://www.jsfuck.com/](http://www.jsfuck.com/)
> 

### 28.9.5 Add Content Security Policy Headers

CSP(Content Security Policy)는 웹사이트에서 브라우저가 로드할 수 있도록 허용해야 하는 콘텐츠(JS, CSS, font, image, ActiveX, Audio, Video, etc..)의 승인된 출처를 선언하는 표준 방법을 제공합니다.

- [https://en.wikipedia.org/wiki/Content_Security_Policy](https://en.wikipedia.org/wiki/Content_Security_Policy)
- [https://github.com/mozilla/django-csp](https://github.com/mozilla/django-csp)

```python
$ pip install django-scp

MIDDLEWARE = (
    # ...
    'csp.middleware.CSPMiddleware',
    # ...
)
```

### 28.9.6 Additional Reading

- [https://docs.djangoproject.com/en/3.2/ref/templates/builtins/](https://docs.djangoproject.com/en/3.2/ref/templates/builtins/)
- [https://en.wikipedia.org/wiki/Cross-site_scripting](https://en.wikipedia.org/wiki/Cross-site_scripting)

## 28.10 Defend Against Python Code Injection Attacks

view에 `eval()` 가 있다면 이를 통해 Python 인젝션이 가능합니다.

### 28.10.1 Python Built-Ins That Execute Code

`eval()`, `exec()`, `execfile()`에 임의 문자열이나 파일이 전달된다면 공격에 무방비하게 됩니다.

- [https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html](https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html)

### 28.10.2 Python Standard Library Modules That Can Execute Code

파이썬 표준 라이브러리 `pickle` 모듈을 사용자에게 수정된 데이터를 deserializer하는데 사용하면 안됩니다.

일반적인 규칙은 사용자로부터 어떠한 피클화된 값도 받지 않습니다.

- [https://lincolnloop.com/blog/playing-pickle-security/](https://lincolnloop.com/blog/playing-pickle-security/)
- [https://blog.nelhage.com/2011/03/exploiting-pickle/](https://blog.nelhage.com/2011/03/exploiting-pickle/)

### 28.10.3 Third-Party Libraries That Can Execute Code

PyYAML을 사용한다면 `safe_load()` 만 사용하세요.

`yaml.load()` 는 파이썬 객체를 생성할 수 있습니다.

- [https://nedbatchelder.com/blog/201302/war_is_peace.html](https://nedbatchelder.com/blog/201302/war_is_peace.html)

### 28.10.4 Be Careful With Cookie-Based Sessions

쿠키 기반 세션을 조심하자

- Django의 세션
    - 데이터베이스 기반 세션
    - 캐시 기반 세션
    - 세션값의 키로 쓰일 랜덤 해시값을 쿠키에 넣어 이 쿠키를 데이터베이스나 캐시에 보관하는 방법
- 장점
    - 클라이언트에 세션 데이터의 키값만 전달된다는 것
    - 악의적인 사용자가 Django의 세션 메커니즘을 뚫고 들어가기 어렵게 만듬
    

Django는 사용자의 기기에 세션 데이터를 전부 저장하는 쿠키 기반 세션도 구성이 가능하지만, 다음의 보안 이슈가 있을 수 있습니다.

- 사용자가 직접 쿠키 기반 세션의 내용을 볼 수 있다.
- 공격자가 프로젝트의 `SECRET_KEY` 에 접근할 수 있고, 세션이 JSON 기반으로 직렬화한다면 세션을 위조할 수도 있다.
- 세션이 피클 기반으로 직렬화되었다면, 세션 위조 뿐만아니라 임의의 코드를 실행할 수도 있다. 이는 공격자가 새로운 권한을 획득 및 공격 코드를 업로드할 수도 있다는 의미이다.
- 쿠키의 만료기간 외에는 쿠키를 삭제할 방법이 없다.(만료기간이 없다면 불가능)

Django의 쿠키 직렬화의 기본 형식을 JSON으로, 공격자가 `SECRET_KEY` 를 얻어도 임의로 코드를 실행할 수 없습니다. 절대 pickle 직렬화 도구를 이용하면 안됩니다.

- [https://docs.djangoproject.com/en/3.2/topics/http/sessions/#session-serialization](https://docs.djangoproject.com/en/3.2/topics/http/sessions/#session-serialization)
- [https://docs.djangoproject.com/en/3.2/ref/settings/#session-serializer](https://docs.djangoproject.com/en/3.2/ref/settings/#session-serializer)

서버에서 클라이언트로 세션 데이터로 전송하는 것에 비해 클라이언트에서 서버로 세션 데이터를 전송하는 것은 상대적으로 느리기 때문에 클라이언트 사이트에서 병목 현상이 발생할 수 있습니다.

- [https://docs.djangoproject.com/en/3.2/topics/http/sessions/#using-cookie-based-sessions](https://docs.djangoproject.com/en/3.2/topics/http/sessions/#using-cookie-based-sessions)
- [https://threatpost.com/security-vulnerability-in-django-could-allow-attackers-access-to-cookies/102501/](https://threatpost.com/security-vulnerability-in-django-could-allow-attackers-access-to-cookies/102501/)

## 28.11 Validate All Incoming Data With Django Forms

Django 폼을 이용하여 모든 들어오는 데이터 검사하기

Django로 들어오는 모든 데이터는 Django 폼이나 DRF Serializers을 통해 검사되어야 합니다.

[Chap13.1: Validate All Incoming Data With Django Forms](https://kimdoky.github.io/django/2021/10/13/django-chap13[/](https://kimdoky.github.io/django/2021/10/13/django-chap13/))

## 28.12 Disable the Autocomplete on Payment Fields

결제 필드에서 자동 완성 기능 비활성화하기

```python
from django import forms

class SpecialForm(forms.Form):
    my_secret = forms.CharField(
        widget=forms.TextInput(attrs={'autocomplete': 'off'}))
```

```python
# 공공장소라면 폼 필드자체를 PasswordInput으로 변경해도 좋다.
from django import forms

class SecretInPublicForm(forms.Form):
       my_secret = forms.CharField(widget=forms.PasswordInput())
```

## 28.13 Handle User-Uploaded Files Carefully

사용자가 올린 파일 다루기

사용자가 올린 콘텐츠를 안전하게 서비스하는 유일한 방법은 서로 다른 도메인을 이용하는 것입니다.

CDN을 이용하면 잠재적 위험이 있을지 모르는 파일들을 따로 저장할 수 있습니다.

임의의 파일 타입에 대해 업/다운로드를 해야 한다면 서버에서 `Content-Disposition: attachment` 헤더를 이용하여 브라우저에서 컨텐츠를 인라인으로 보여주지 못하게 해야 합니다.

### 28.13.1 When a CDN Is Not an Option

CDN을 이용할 수 없는 경우

- 업로드된 파일들을 실행이 불가능한 폴더에 저장
- HTTP 서버가 이미지 컨텐츠 타입 헤더(image content type header)를 가지고 이미지를 서비스해야 함
- 업로드의 경우 확장자를 화이트 리스트를 사용하여 필터링해야 함
- 웹 서버 셋팅
    - CGI / PHP 스크립트를 업로드하고 URL을 통해 접근하여 실행이 가능하기 때문에 주의 필요
    - 웹 서버 문서 참고
    - 혹은 PaaS 제공자에게 문의 필요

### 28.13.2 Django and User-Uploaded Files

- Django 제공하는 필드
    - FileField
    - ImageField
    - Django에서 제공하는 필드들은 내장된 validation 기능을 제공함
- 특정 파일 타입만 업로드를 허용한다면 업로드할 다양한 방법을 구현해야 함
    - python-magic 라이브러리를 이용하여 업로드된 파일의 헤더를 확인
        - https://github.com/ahupp/python-magic
    - 특정 파일 타입에만 작동하는 파이썬 라이브러리를 통해 파일을 확인
        - ImageField 소스엔 진짜 이미지인지 PIL(Python Image Library)를 이용하여 확인
    - 네이티브 파이썬 XML 또는 lxml 대신 defusexml을 이용
        - [Chap28.21: Guard Against XML Bombing With defusedxml]()
- 추가 자료
    - [https://docs.djangoproject.com/en/3.2/ref/models/fields/#filefield](https://docs.djangoproject.com/en/3.2/ref/models/fields/#filefield)
    - [https://www.youtube.com/watch?v=HS8KQbswZkU](https://www.youtube.com/watch?v=HS8KQbswZkU)

## 28.14 Don't Use ModelForms.Meta.exclude

- ModelForms를 사용할 때
    - Meta.fields를 이용해야 함
    - Meta.exclude는 절대 금지
        - 대량 매개 변수 입력 취약점(Mass Assignment Vulnerability)과 같은 심각한 보안 위협이 있음
        - 모델 필드가 변경 될 때 exclude로 지정한 필드를 제외한 부분들만 변경
            - 모델 변경에 따라폼을 변경해줘야 함

```python
# 예제 모델
# stores/models.py
from django.conf import settings
from django.db import models

class Store(models.Model):
    title = models.CharField(max_length=255)
    slug = models.SlugField()
    owner = models.ForeignKey(settings.AUTH_USER_MODEL)
    # 주소와 연락처 관련된 10개의 필드가 더 있다고 가정

# 이렇게 하지 말자!
from django import forms
from .models import Store

class StoreForm(forms.ModelForm):
    class Meta:
        model = Store
        # 필드에 대한 이런 암시적 선언은 문제가 될 가능성이 높다.
        # Store에 새로운 필드가 추가되었을때 excludes에 수정하는걸 놓쳤다면 문제가 된다.
        excludes = ("pk", "slug", "modified", "created", "owner")

# 이렇게 하자!
from django import forms
from .models import Store
class StoreForm(forms.ModelForm):
    class Meta:
        model = Store
        # 필드를 명확하게 정의해 주자.
        fields = (
            "title", "address_1", "address_2", "email",
            "usstate", "postal_code", "city",
        )
```

### 28.14.1 Mass Assignment Vulnerabilities

대량 매개 변수 입력 취약점

Active Record는 개발을 위해 더 많은 권한을 주는 것인데, 이것은 보안의 위협이 될 수 있습니다.

이에 대한 방안은 수정 가능한 필드들에 대해 명확하게 정의하여 이용하는 것입니다.

- [https://en.wikipedia.org/wiki/Mass_assignment_vulnerability](https://en.wikipedia.org/wiki/Mass_assignment_vulnerability)

## 28.15 Don't Use `ModelForms.Meta.fields = "__all__"`

`ModelForms.Meta.fields = "__all__"` 은 모델 폼 안의 모든 모델 필드를 전부 지칭합니다.

이것은 exclude를 사용하는 것과 같이 대량 매개 변수 입력 취약점에 노출될 수 있습니다.

될 수 있으면 피해야 하는 방법입니다.

## 28.16 Beware of SQL Injection Attacks

SQL 인젝션 공격 피하기

Django ORM은 SQL 인젝션 방어 기능이 있습니다.

하지만 Django는 ORM을 우회하여 SQL문을 직접 실행할 수 있는 기능도 제공하기 때문에, 이런 기능을 사용할 때에는 SQL 인젝션 공격에 대비해야 합니다.

- `.raw()` ORM 메서드
- `.extra()` ORM 메서드
- 데이터베이스 커서에 직접 접근하는 경우
- [https://docs.djangoproject.com/en/3.2/topics/security/#sql-injection-protection](https://docs.djangoproject.com/en/3.2/topics/security/#sql-injection-protection)

## 28.17 Don't Store Unnecessary Data

### 28.17.1 Never Store Credit Card Data

- 신용카드 정보를 저장해도 되는경우
    - [PCI-DSS 보안표준](https://www.pcisecuritystandards.org/)에 대한 충분한 지식이 있다.
    - PCI 규약을 확인할 충분한 자원이 확보된 경우

위 경우가 아니라면 신용 카드 정보를 저장하면 안됩니다.

스트라이프(stripe), 브레인트리(Braintree), 아이덴(Adyen), 페이팔(Paypal)과 같은 결제 정보를 대신 보관해주는 서드 파티 서비스를 이용할 수 있습니다.

### 28.17.2 Don't Store PII or PHI Unless Required(By Law)

- PII(Personally Identifying Information): 개인 식별 정보
- PHI(Protected Health Information): 보호되는 건강 정보

PII와 PHI는 다양한 계정에 대한 액세스 권한을 얻는 것에 악용될 수 있기 때문에 저장하는 것을 피해야 합니다.

법에서 요구하는 경우라도 단방향 해시로 데이터를 저장해야 합니다.

- [https://en.wikipedia.org/wiki/Health_Insurance_Portability_and_Accountability_Act#Security_Rule](https://en.wikipedia.org/wiki/Health_Insurance_Portability_and_Accountability_Act#Security_Rule)

## 28.18 Monitor Your Sites

웹 서버의 접근과 에러 로그를 주기적으로 확인해야 합니다.

모니터링 도구를 설치하고 주기적으로 확인하며 의심이 가는 활동에 주의를 기울여야 합니다.

## 28.19 Keep Your Dependencies Up-to-Date

의존성 최신으로 유지하기

프로젝트가 Django 최신 안정화 버전과 최신 서드 파티 의존성에 호환되도록 항상 업데이트해야 합니다.

특히 보안 패치를 담고 있을 때 최신 버전들과 호환이 중요합니다.

[https://pyup.io/](https://pyup.io/)는 PyPI가 제공하는 최신버전에 대한 requirements 파일을 자동을 확인해줍니다.

- Django 공식 블로그 [https://www.djangoproject.com/weblog/](https://www.djangoproject.com/weblog/)
- Django 공식 공지 메일링 리스트 [https://groups.google.com/g/django-announce](https://groups.google.com/g/django-announce)

## 28.20 Prevent Clickjacking

클릭재킹 예방하기

- 클릭재킹
    - 악의적인 사이트에서 숨겨진 프레임이나 아이프레임 등에 다른 사이트를 로드해서 유저가 숨겨진 엘레먼트를 클릭하게 만드는 것
    - ex. 로그인 버튼에 다른 기능(구매 기능 등)을 작동하게 만듬
- 예방하는 컴포넌트와 방법
    - [https://docs.djangoproject.com/en/3.2/ref/clickjacking/](https://docs.djangoproject.com/en/3.2/ref/clickjacking/)

## 28.21 Guard Against XML Bombing With defusedxml

defusedxml을 이용하여 XML 폭탄 막기

XML 라이브러리를 이용한 공격들이 있습니다.

- [https://en.wikipedia.org/wiki/Billion_laughs_attack](https://en.wikipedia.org/wiki/Billion_laughs_attack)

lxml과 같은 서드 파티 파이썬 라이브러리들도 4개 이상의 잘 알려진 XML 기반 공격에 취약합니다.

- [https://pypi.org/project/defusedxml/#python-xml-libraries](https://pypi.org/project/defusedxml/#python-xml-libraries)

defusedxml이라는 파이썬 코어 XML 라이브러리와 서드 파티 라이브러리들을 패치하기 위한 라이브러리가 제작되었습니다.

- [https://pypi.org/project/defusedxml/](https://pypi.org/project/defusedxml/)

## 28.22 Explore Two-Factor Authentication

이중 인증 살펴보기

- 비밀번호를 입력하고, 모바일 기기에서 제공하는 또 다른 값들을 또 한번 입력해야 함
- 일회용 비밀번호(OTP)에 대한 옵션
- 장점
    - 보안 컴포넌트를 인증 절차에 추가했다는 것
    - 개인 정볼르 다루거나 금융/의료 정보를 요구하는 사이트에 적합
- 단점
    - 사용자가 로그인하려면 모바일 기기가 충전된 상태이어야 함
    - 모바일 기기가 방전되었거나 네트워크에 쉽게 액세스할 수 없는 사용자에겐 적합하지 않음
- [https://en.wikipedia.org/wiki/Multi-factor_authentication](https://en.wikipedia.org/wiki/Multi-factor_authentication)
- [https://pypi.org/project/django-two-factor-auth/](https://pypi.org/project/django-two-factor-auth/)

## 28.23 Embrace SecurityMiddleware

SecurityMiddleware 이용하기

`django.middleware.security.SecurityMiddleware` 를 활용하세요.

## 28.24 Force the Use of Strong Password

강력한 패스워드 이용하게 만들기

복잡한 패스워드보다 길이가 긴 패스워드가 더 안전합니다.

Quality | Password Specification
---|---
Bad | 6 ~ 10개의 알파벳
Okay | 최소 8개 이상의 대소문자 혼용 + 숫자 + 특수문자
Better | 최소 30자 이상의 알파벳
Best | 최소 302자 이상의 대소문자 혼옹 + 숫자 + 특수문자

## 28.25 Don't Prevent Copy/Pasting of Password

비밀번호 복사 / 붙여넣기를 금지하고 수동으로만 암호를 입력하도록 강제하는 것은 1Password나 LastPass 같은 암호 관리자 기능(강력한 암호보호)을 사용하지 못하고 기억하기 쉽고 반복적인 암호에 의존하게 만드는 끔찍한 패턴입니다.

## 28.26 Give Your Site a Security Checkup

사이트 보안 검사하기

- https://github.com/pyupio/safety
    - [https://pyup.io/](https://pyup.io/)의 안전 라이브러리
    - 사이트에 대한 자동 점검을 제공하는 서비스
    - 기본적으로 Safety DB를 사용
        - `—key` 옵션으로 Safety API를 사용할 수 있음

## 28.27 Put Up a Vulnerability Reporting Page

취약점 보고 페이지 만들기

사이트 이용자들이 보안 취약점을 발견했을 때 제보하는 방법을 제공할 수 있습니다.

- ex. [https://docs.github.com/en/github/site-policy/coordinated-disclosure-of-security-vulnerabilities](https://docs.github.com/en/github/site-policy/coordinated-disclosure-of-security-vulnerabilities)
- 문제를 보고한 사용자의 이름을 사이트에 나타내 줌으로써 감사에 보답할 수 있습니다.

## 28.28 Never Display Sequential Primary Keys

순차적인 Primary Key를 표시하면 안되는 이유

- 업계의 라이벌이나 해커에게 서비스 볼륨이 노출됨
- 불안전한 직접 객체 객체 참조를 악용하는 것을 사소하게 만든다..?
- XSS 공격의 타겟이 됨

### 28.28.1 Lookup by Slug

Django에서는 Slug를 사용하는 것이 매우 일반적입니다.

그러나 중복 Slug에 문제가 있는 경우 다른 방법을 적용해야 합니다.

### 28.28.2 UUIDs

사용자들에게 Primary Key를 숨기려고 한다면 `models.UUIDField` 가 유용합니다.

```python
import uuid
from django.db import models

class IceCreamPayment(models.Model):
    uuid = models.UUIDField(
        unique=True, 
        default=uuid.uuid4, 
        editable=False)

    def __str__(self):
        return str(self.pk)
```

```python
>>> from payments import IceCreamPayment
>>> payment = IceCreamPayment()
>>> IceCreamPayment.objects.get(id=payment.id) <IceCreamPayment: 1>
>>> payment.uuid
UUID('0b0fb68e-5b06-44af-845a-01b6df5e0967')
>>> IceCreamPayment.objects.get(uuid=payment.uuid)
<IceCreamPayment: 1>
```

순차적인 ID는 인간이 기억할 수 있지만, UUID는 기억하기 어렵습니다.

모델에 대한 유일한 접근이 UUID라면, 데이터 작업은 조금 더 어려워집니다.

조회를 위해 UUID를 사용할때 성능도 고려해야 합니다.(보안과 성능은 반비례)

[uuid performance]([https://www.percona.com/blog/2019/11/22/uuids-are-popular-but-bad-for-performance-lets-discuss/](https://www.percona.com/blog/2019/11/22/uuids-are-popular-but-bad-for-performance-lets-discuss/))

프로젝트가 수십억 개의 기록을 처리해야 한다면 성능을 고려하여 UUID를 대체할 접근법(순차적 ID 포함)을 고려해야 합니다.

순차적 ID는 난독화가 가능하지만 다음과 같은 이유로 비추천.

- 난독화는 순차 ID를 숨기는 효과적인 방법이 아님
    - Base64 인코딩에서 hashids 라이브러리까지 난독화 방법은 다양
    - 숫자를 영숫자로 변환하고 다시 되돌리는 방식으로 작동
    - 숫자를 숨길뿐만 아니라 단축하기도 함
    - 순차 ID 난독화는 근본적으로 안전하지 않음
        - Base64 인코딩은 실행취소가 쉬움
        - hashids 같은 라이브러리는 무차별 대입 공격이나 이와 관련된 깊은 지식이 있는 사람은 누구나 깨뜨릴 수 있음

## 28.29 Upgrade Password Hasher to Argon2

Django의 암호 해시

- PBKDF2
    - Python 표준 라이브러리에서 지원되기 때문에 추가 설치 필요없이 사용 가능
    - Django의 기본값
- Argon2
    - 권장 알고리즘
    - 추가 패키지 설치해야 함
- [https://docs.djangoproject.com/en/3.2/topics/auth/passwords/#using-argon2-with-django](https://docs.djangoproject.com/en/3.2/topics/auth/passwords/#using-argon2-with-django)
- [https://docs.djangoproject.com/en/3.2/topics/auth/passwords/#argon2](https://docs.djangoproject.com/en/3.2/topics/auth/passwords/#argon2)
- [https://latacora.micro.blog/2018/04/03/cryptographic-right-answers.html](https://latacora.micro.blog/2018/04/03/cryptographic-right-answers.html)

## 28.30 Use SRI When Loading Static Assets From External Sources

외부 소스를 로드할 때 SRI 사용하기

JQuery, GoogleFonts, Bootstrap, React, Vue 등의 외부 라이브러리를 로드하여 사용합니다.

SRI(Subresource Integrity)를 사용하여 소스를 확인하지 않으면 공격자에 의해 코드가 수정될 수 있습니다.

```html
<!-- DON'T DO THIS - loading static assets without SRI -->
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css">
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"></
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"></scr
```

SRI를 사용하여 코드의 무결성을 체크함으로써 안전하게 외부 라이브러리를 로드할 수 있습니다.

```html
<!-- Loading Static Assets with SRI -->
<link rel="stylesheet" 
	href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" 
	integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T crossorigin="anonymous">
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" 
	integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" 
	integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1 crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" 
	integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin="anonymous"></script>
```

- [https://cdnjs.com/](https://cdnjs.com/)
- [https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity)
- [https://www.w3.org/TR/SRI/](https://www.w3.org/TR/SRI/)

## 28.31 Reference Our Security Settings Appendix

Django와 보안 관련 이슈를 전부 챙기는 것은 어렵지만, [Appendix G: Security Settings Reference]()를 참고하면 도움이 될 것입니다.

## 28.32 Review the list of Security Packages

[Appendix A: Packages. security section]()에서는 10개 이상의 보안 관련 패키지들이 있습니다.

## 28.33 Keep Up-to-Date on General Security Practices

보안 사항 일반에 대해 늘 최신 정보를 유지하라

1. 보안 관련 업무는 Django 커뮤니티와 그 외 다른 부분들에서 계속 진화하고 있습니다.
    - [https://groups.google.com/g/django-announce](https://groups.google.com/g/django-announce) 구독
    - Twitter, Hacker News 등 다양한 보안 블로그를 정기적으로 확인
2. Django를 벗어난 다양한 분야에 걸쳐있음
    - 웹 어플리케이션 스택 전반의 보안 이슈를 연구하며 항상 최신 정보를 유지
- 보안 관련 추천 글과 책
    - “The Tangled Web: A Guide to Securing Modern Web Applications”
        - [https://www.amazon.com/The-Tangled-Web-Securing-Applications/dp/1593273886/?ie=UTF8&tag=cn-001-20](https://www.amazon.com/The-Tangled-Web-Securing-Applications/dp/1593273886/?ie=UTF8&tag=cn-001-20)
    - “The Web Application Hacker’s Handbook”
        - [https://www.amazon.com/The-Web-Application-Hackers-Handbook/dp/1118026470/?ie=UTF8&tag=cn-001-20](https://www.amazon.com/The-Web-Application-Hackers-Handbook/dp/1118026470/?ie=UTF8&tag=cn-001-20)
    - [https://wiki.mozilla.org/WebAppSec/Secure_Coding_Guidelines](https://wiki.mozilla.org/WebAppSec/Secure_Coding_Guidelines)

## 28.34 Summary

Django 문서의 추가적인 보안 주제를 읽으세요.

- [https://docs.djangoproject.com/en/3.2/topics/security/#additional-security-topics](https://docs.djangoproject.com/en/3.2/topics/security/#additional-security-topics)

보안 관련 분야에 도움을 청하는 것은 권장되는 것이기 때문에, 미심쩍은 부분이 있다면 Django 커뮤니티에 질문을 남기고 도움을 요청하세요.

### 문제가 일어났을 때의 대응 방법

1. 모든 것을 정지하거나 읽기 전용 모드로 변경한다.
    - 503 페이지 나타내기
        - [https://www.cyberciti.biz/faq/custom-nginx-maintenance-page-with-http503/](https://www.cyberciti.biz/faq/custom-nginx-maintenance-page-with-http503/)
    - `django-db-tools` 으로 데이터베이스를 읽기 전용 모드로 변환하기
    - 그 외 여러 도구 이용하기
        - [https://djangopackages.org/grids/g/emergency-management/](https://djangopackages.org/grids/g/emergency-management/)
2. 정적 HTML 페이지를 띄운다.
3. 백업을 시작한다.
4. 실수로 발생한 문제라도 security@djangoproject.com으로 메일을 보낸다.
    - 간략한 요약을 씀으로써 생각을 정리하고 이에 대한 정보를 모으는데 도움이 됨
    - Django 보안 팀이 좋은 충고나 답을 가지고 있을 수도 있다.
    - Django 자체의 문제라면, 해당 문제가 확대대기 전에 조취를 취할 수 있다.
5. 문제를 살펴본다.
    - 모두 날려버릴 수도 있는 성급한 패치를 하지 않도록 올바른 수정 사항인지 확인해 보자
        - CI/CD 의 힘을 발휘할 때다!
    - 긍정적으로 생각하고, 화이팅...?!
    - zero-day 공격
        - 아직 패치되지 않은, 공개적이거나 비공개적인 보안 취약점에 대한 공격
