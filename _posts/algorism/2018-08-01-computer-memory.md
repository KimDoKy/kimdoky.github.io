---
layout: post
section-type: post
title: 컴퓨터 공학 - 가상 메모리
category: algorism
tags: [ 'algorism' ]
---

# 가상 주소 공간
프로그램이 실행되면, 하드 디스크에 있던 프로그램이 메인 메모리에 올라오면서 프로세스가 생성되고, 4GB 메모리를 할당 받음(32비트 운영체제의 경우)
4GB는 메인 메모리의 실제는 아니지만, 실제로 운영체제에게 할당받은 것처럼 사용

- 커널 영역 : 운영체제가 담당하는 2GB
- 유저 영역 : 실제 프로그램이 담당하는 2GB
 - 코드 세그먼트(code segment) : 프로그램의 인스트럭션이 저장되는 공간
  - 함수나 클래스 정의 코드는 인스트럭션으로 변환되어 하드디스크에 저장되어 있다가 프로세스가 실행되면 가상 주소 공간의 코드 세그먼트에 올라감
  - 함수를 호출하면 프로그램 카운터가 함수의 인스트럭션이 있는 메모리 주소를 가리킴으로 함수를 실행 함
 - 데이터 세그먼트(data segment) : 전역 변수가 저장되는 공간
  - 전역 변수는 프로세스가 실행될 때 데이터 세그먼트로 올라가고 프로세스 종료시 소멸
 - 스택 세그먼트(stack segment) : 지역 변수가 저장되는 공간
  - 함수를 호출했을 때 그 스택 프레임이 스택 세그먼트에 생성됨
  - 함수 호출이 끝나면 스택 프레임이 사라지면서 해제됨
  - 스택 세그먼트는 최대 크기를 정할 수 있는데, 기본값은 1MB
  - 스택 프레임에 쌓이다가 크기를 넘기면 스택 오버플로(Stack over flow)가 발생
 - 힙 세그먼트(heap segment) : 프로그래머가 자유롭게 메모리를 할당/해제할 수 있는 공간
  - 힙 세그먼트에 할당한 메모리는 함수 호출이 끝나도 해제하지 않으면 남아있다.
  - 메모리를 해제하지 않고 계속 남아있으면 메모리누수가 발생한다(memory leak)
  - 힙은 최대 크기가 정해져 있지 않다.
  - 힙 세그먼트를 사용하면 모메리 할당과 해제 시점을 프로그래머가 정할 수 있다.
  - 할당된 메모리를 해제하지 않고 메모리 주소 값을 참조 및 리턴으로 전달하여 접근할 수 있다.
  - 메모리를 할당할 때 메모리가 들어갈 만한 공간을 찾을 때까지 검색하여 느려질 수 있다.
  - 성능을 고려한다면 힙보다는 스택을 활용하는 것이 좋다.
  - 잦은 할당과 해제로 메모리 단편화가 발생하여 캐시 미스(cache miss) 확률이 높아진다.

## 가상 메모리
메인 메모리를 확장하기 위해 페이지 파일(page file)로 불리는 하드디스크의 일정 부분을 메인 메모리처럼 사용하는 것
메인 메모리(RAM)와 하드 디스크의 페이지 파일을 합쳐 물리 메모리(physical memory)라고 함

가상 메모리 관리 기법으로는 가상 주소 공간을 쪼개는 기준에 따라 세그먼테이션(segmentation)기법과 페이징(paging)기법이 있다.

## MMU(Memory Management Unit)
- 가상 주소 공간(virtual address space) : 프로세스에 주어지는 메모리 공간
- 논리 주소(logical address) : 가상 주소 공간의 메모리 주소
- 물리 주소(physical address) : 메인 메모리의 메모리 주소
- MMU : 프로세스를 실행하려면 실제 데이터와 코드를 올릴 물리메모리가 필요한데, 논리 주소를 물리주소로 변환하서 사용할때 필요한 하드웨어
- 과거에는 하드웨어가 따로 있었지만, 지금은 CPU 내부에 존재

## 페이징
- 페이징 기법 : 가상 주소 공간과 메인 메모리를 일정한 크기로 나누어 다룸
- 페이지(page) : 가상 주소 공간을 일정한 크기로 쪼개진 한 부분
- VPN(Virtual Paeg Number) : 페이지 순서를 나타내는 비트
- offset : 페이지 안에서 특정 바이트를 가리키는 비트
- VPN + offset = 논리 주소
- 이 논리 주소는 CPU가 요청하는 주소. 프로글매 카운터에 저장된 값

## 페이지 프레임
- 페이지 프레임(page frame) : 메인 메모리도 가상 주소 공간과 같은 크기로 쪼개는데, 쪼개진 부분의 하나.
실제로 존재하지 않는 페이지를 실제로 존재하는 프레임에 할당하기 위함.
- PPN(physical page number) : 프레임 순서를 나타내는 비트

## 페이지 테이블
- 페이지 테이블(page table) : 프로세스의 VPN, PPN, 상태 등을 저장하는 테이블. 모든 프로세스마다 고유의 페이지 테이블이 있음
- PTBA(page table base address) : 페이지 테이블의 시작 주소
- PTBR(page table base register) : PTBA를 가리키는 레지스터
- 논리 주소는 프로그램 카운터에 저장된 인스트럭션의 주소 값
- 유효 비트(valid bit) : 프레임이 실제 메인 메모리에 있는지(1), 하드디스크에 있는지(0)를 나타내는 비트
- 물리 주소 = PPN + 논리주소의 offset
- MMU는 PTBR에 저장된 페이지 테이블의 시작 주소를 참조하고, 프로그램 카운터에서 VPN 비트를 참조한다.
- 페이지 테이블에서 VPN을 찾고 이에 상응하는 PPN을 가져와 프로그램 카운터의 offset 비트와 합쳐 물리 주소를 만듬.
- 이 물리 주소를 MAR(Memory Address Register)에 저장하고, CPU는 이 레지스터의 주소 값을 읽어와 메인 메모리에서 인스트럭션을 가져오고(fetch) 실행(execute)한다.

## 요구 페이징
프로세스를 실행할 때, 필요한 페이지만 메인 메모리에 올려 실행하는 것

## 페이지 폴트
- CPU가 요청한 페이지가 메인 메모리에 없을 때 발생
- 페이지 폴트가 발생하면 해당 페이지를 하드 디스크에서 가져와 빈 프레임에 할당
- 메인 메모리에 빈 프레임이 없다면, 페이지 교체 알고리즘에 의해 메인 메모리에 있는 페이지를 하드디스크로 내리고, 요청도니 페이지를 메인 메모리로 올림
- 희생 페이지(victim page) : 메인 메모리에서 하드디스트로 내려지는 희생 페이지
- 페이지 아웃(page-out) : 페이지를 메인 메모리에서 하드 디스크로 내리는 것
- 페이지 인(page-in) : 하드디스트에서 멩ㄴ이 메모리로 올리는 것
- 페이지 폴트가 자주 일어나면 프로그램 성능 저하
 - 하드디스크에서 데이터를 읽어 오는 속도가 메인 메모리보다 훨씬 느리기 때문
- 페이지 폴트를 줄이려면 지역을 고려해야함.
 - ex. 프로그램에서 데이터 저장시 연결 리스트 자료 구조를 사용하면 메모리 단편화가 심하게 발생하는 경우
 - 자료 구조를 배열로 변경하면 어느정도 해결 됨
 - 배열을 사용하기 힘들다면, 다이나믹 힙(dynamic heap)을 이용해 메모리 단편화를 없애고 지역성을 좋게 할 수 있다.

> 다이나믹힙(dynamic heap) : 프로세스에 기본적으로 할당되는 디폴트 힙 외에 프로그래머가 따로 할당해 만든 힙

## 변환 색인 버퍼
- 주소 변환 속도를 높이기 위한 일종의 캐시
- 변환 색인 버퍼(TLB)에는 최근 사용된 페이지 테이블의 일부가 저장되어 있음
- MMU가 페이지 테이블에서 프레임 넘버를 읽기 전에 TLB에 해당 항목(페이지 넘버, 그에 매핑되는 프레임 넘버)가 있는지 확인
- 있으면 'TLB 히트'
- 히트 확률 99%
